diff --git a/Config.in b/Config.in
old mode 100644
new mode 100755
index 3c13f33..104d651
--- a/Config.in
+++ b/Config.in
@@ -19,6 +19,7 @@ config CONFIG_PROJECT
 
 choice
 	prompt "Image Loading Strategy"
+	default CONFIG_LOAD_LINUX if CONFIG_STAMP9G45 || CONFIG_NANOSG20 || CONFIG_PICOSG20
 	default CONFIG_LOAD_UBOOT
 
 config CONFIG_LOAD_UBOOT
@@ -60,28 +61,28 @@ menu "Linux Image Storage Setup"
 
 config CONFIG_OS_MEM_BANK
 	string "Extern Memory Bank Base Address"
-	default "0x70000000" if CONFIG_AT91SAM9M10G45EK
+	default "0x70000000" if CONFIG_AT91SAM9M10G45EK || CONFIG_STAMP9G45
 	default "0x20000000"
 	
 config CONFIG_OS_MEM_SIZE
 	string "Extern Memory Bank Size"
-	default "0x20000000" if CONFIG_AT91SAMA5D3XEK
-	default "0x8000000" if CONFIG_AT91SAM9X5EK || CONFIG_AT91SAM9N12EK
+	default "0x10000000" if CONFIG_STAMP9G45 && (CONFIG_RAM_512MB || CONFIG_RAM_256MB)
+	default "0x08000000" if (CONFIG_STAMP9G45 || CONFIG_NANOSG20) && CONFIG_RAM_128MB
 	default "0x4000000"
 	
 config CONFIG_LINUX_KERNEL_ARG_STRING
 	string "Linux kernel parameters"
-	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9260EK && !CONFIG_SDCARD
-	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9261EK && !CONFIG_SDCARD
-	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9263EK && !CONFIG_SDCARD
-	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9RLEK && !CONFIG_SDCARD
-	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9XEEK && !CONFIG_SDCARD
-	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9G10EK && !CONFIG_SDCARD
-	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9G20EK && !CONFIG_SDCARD
-	default "mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs" if CONFIG_AT91SAM9X5EK && !CONFIG_SDCARD
-	default "mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs" if CONFIG_AT91SAM9N12EK && !CONFIG_SDCARD
-	default "mem=512M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs" if CONFIG_AT91SAMA5D3XEK && !CONFIG_SDCARD
-	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9M10G45EK && !CONFIG_SDCARD
+	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9260EK && !CONFIG_SDCARD
+	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9261EK && !CONFIG_SDCARD
+	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9263EK && !CONFIG_SDCARD
+	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9RLEK && !CONFIG_SDCARD
+	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9XEEK && !CONFIG_SDCARD
+	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9G10EK && !CONFIG_SDCARD
+	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9G20EK && !CONFIG_SDCARD
+	default "mem=128M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9X5EK && !CONFIG_SDCARD
+	default "mem=128M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9N12EK && !CONFIG_SDCARD
+	default "mem=512M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAMA5D3XEK && !CONFIG_SDCARD
+	default "mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2" if CONFIG_AT91SAM9M10G45EK && !CONFIG_SDCARD
 	default "mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2" if CONFIG_AT91SAM9RLEK && CONFIG_SDCARD
 	default "mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2" if CONFIG_AT91SAM9G10EK && CONFIG_SDCARD
 	default "mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2" if CONFIG_AT91SAM9261EK && CONFIG_SDCARD
@@ -103,6 +104,9 @@ config CONFIG_IMG_ADDRESS
 	string "Flash Offset for Linux Kernel Image"
 	default "0x00008000" if CONFIG_FLASH
 	default "0x00042000" if CONFIG_DATAFLASH
+	default "0x00060000" if CONFIG_NANDFLASH && CONFIG_STAMP9G45
+	default "0x00020000" if CONFIG_NANDFLASH && CONFIG_NANOSG20
+	default "0x000a0000" if CONFIG_NANDFLASH && CONFIG_PICOSG20
 	default "0x00200000" if CONFIG_NANDFLASH
 	default	"0x00000000" if CONFIG_SDCARD
 	help
@@ -110,43 +114,40 @@ config CONFIG_IMG_ADDRESS
 config CONFIG_IMG_SIZE
 	depends on CONFIG_DATAFLASH || CONFIG_NANDFLASH
 	string "Linux Kernel Image Size"
+	default "0x3a0000" if CONFIG_STAMP9G45
+	default "0x2e0000" if CONFIG_NANOSG20
+	default "0x360000" if CONFIG_PICOSG20
 	default "0x300000"
 
 config CONFIG_JUMP_ADDR
 	string "The External Ram Address to Load Kernel Image"
-	default "0x72000000" if CONFIG_AT91SAM9M10G45EK
+	default "0x72000000" if CONFIG_AT91SAM9M10G45EK || CONFIG_STAMP9G45
+	default "0x21000000" if CONFIG_NANOSG20 || CONFIG_PICOSG20
 	default "0x22000000"
 	help
 	  The entry point to which the bootstrap will pass control.
 
-config CONFIG_OF_LIBFDT
-	bool "Flattened Device Tree Support"
-	default y
-
-config CONFIG_OF_OFFSET
-	string "The Offset of Flash Device Tree Blob "
-	depends on CONFIG_OF_LIBFDT && (CONFIG_DATAFLASH || CONFIG_NANDFLASH)
-	default "0x00008400" if CONFIG_DATAFLASH
-	default "0x00180000" if CONFIG_NANDFLASH
-	default	"0x00000000" if CONFIG_SDCARD
+config CONFIG_LINUX_DT
+	bool "Boot Linux with Device Tree"
+	default y if CONFIG_PICOSG20
+	default n
 
-config CONFIG_OF_LENGTH
-	string "The Length of Flash Device Tree Blob"
-	depends on CONFIG_OF_LIBFDT && (CONFIG_DATAFLASH || CONFIG_NANDFLASH)
-	default "0x2FFFF"
-
-config CONFIG_OF_FILENAME
-	string "Device Tree Filename on SD Card"
-	depends on CONFIG_OF_LIBFDT && CONFIG_SDCARD
-	default "ek.dtb"
-
-config CONFIG_OF_ADDRESS
-	string "The External Ram Address to Load Device Tree Blob"
-	depends on CONFIG_OF_LIBFDT
-	default "0x71000000" if CONFIG_AT91SAM9M10G45EK
-	default "0x21000000"
+config CONFIG_DTIMG_ADDRESS
+	string "Flash Offset for Device Tree Image"
+	depends on CONFIG_LINUX_DT && (CONFIG_DATAFLASH || CONFIG_NANDFLASH)
+	default "0x00010000" if CONFIG_NANDFLASH && CONFIG_PICOSG20
 	help
 
+config CONFIG_DTIMG_SIZE
+	string "Device Tree Image Size"
+	depends on CONFIG_LINUX_DT && (CONFIG_DATAFLASH || CONFIG_NANDFLASH)
+	default "0x10000" if CONFIG_PICOSG20
+
+config CONFIG_DT_ADDRESS
+	string "The External Ram Address to Load Device Tree Image"
+	depends on CONFIG_LINUX_DT
+	default "0x20f00000" if CONFIG_PICOSG20
+	default "0x22000000"
 endmenu
 
 #
@@ -165,22 +166,25 @@ config CONFIG_IMG_ADDRESS
 	depends on CONFIG_DATAFLASH || CONFIG_NANDFLASH
 	default "0x00008000" if CONFIG_FLASH
 	default "0x00008400" if CONFIG_DATAFLASH
-	default "0x00040000" if CONFIG_NANDFLASH
+	default "0x00040000" if CONFIG_NANDFLASH && (CONFIG_AT91SAM9X5EK || CONFIG_AT91SAMA5D3XEK)
+	default "0x00020000" if CONFIG_NANDFLASH && !(ONFIG_AT91SAM9X5EK || CONFIG_AT91SAMA5D3XEK)
 	default	"0x00000000" if CONFIG_SDCARD
 	help
 
 config CONFIG_IMG_SIZE
 	string "U-Boot Image Size"
 	depends on CONFIG_DATAFLASH || CONFIG_NANDFLASH
-	default	"0x00080000"
+	default	"0x00040000" if CONFIG_STAMP9G20
+	default	"0x00050000"
 	help
 	  at91bootstrap will copy this size of U-Boot image
 
 config CONFIG_JUMP_ADDR
 	string "The External Ram Address to Load U-Boot Image"
 	default "0x73F00000" if CONFIG_AT91SAM9M10G45EK
-	default "0x26F00000" if CONFIG_AT91SAM9X5EK || CONFIG_AT91SAM9N12EK || CONFIG_AT91SAMA5D3XEK
-	default "0x21F00000" if CONFIG_AT91SAM9260EK || CONFIG_AT91SAM9261EK || CONFIG_AT91SAM9263EK || CONFIG_AT91SAM9G10EK || CONFIG_AT91SAM9G20EK || CONFIG_AT91SAM9RLEK
+	default "0x26F00000" if CONFIG_AT91SAM9X5EK
+	default "0x26F00000" if CONFIG_AT91SAM9N12EK
+	default "0x26F00000" if CONFIG_AT91SAMA5D3XEK
 	default "0x23F00000"
 	help
 	  The entry point to which the bootstrap will pass control.
@@ -202,7 +206,8 @@ config CONFIG_IMG_ADDRESS
 	string "Flash Offset for Demo-App"
 	depends on CONFIG_DATAFLASH || CONFIG_NANDFLASH
 	default "0x00008400" if CONFIG_DATAFLASH
-	default "0x00040000" if CONFIG_NANDFLASH
+	default "0x00040000" if CONFIG_NANDFLASH && CONFIG_AT91SAM9X5EK
+	default "0x00020000" if CONFIG_NANDFLASH && !CONFIG_AT91SAM9X5EK
 	default	"0x00000000" if CONFIG_SDCARD
 
 config CONFIG_IMG_SIZE
@@ -236,6 +241,7 @@ config CONFIG_LONG_TEST
 	  
 config CONFIG_DEBUG
 	bool "Debug Support"
+	default y if CONFIG_STAMP9G45 || CONFIG_STAMP9G20 || CONFIG_NANOSG20 || CONFIG_PICOSG20
 	default n
 	help
 	  Output Debug messages
@@ -271,13 +277,7 @@ config CONFIG_THUMB
 	  Build code in thumb mode
 
 config CONFIG_SCLK	  
-	depends on CONFIG_AT91SAM9RLEK || CONFIG_AT91SAM9M10G45EK || CONFIG_AT91SAM9X5EK || CONFIG_AT91SAM9N12EK || CONFIG_AT91SAMA5D3XEK
+	depends on CONFIG_AT91SAM9RLEK || CONFIG_AT91SAM9M10G45EK || CONFIG_AT91SAM9X5EK || CONFIG_AT91SAM9N12EK || CONFIG_AT91SAMA5D3XEK || CONFIG_STAMP9G45
 	bool "Use external 32KHZ oscillator as source of slow clock"
 	help
 	  Use external 32KHZ oscillator as source of slow clock
-
-config CONFIG_DISABLE_WATCHDOG
-	bool "Disable Watchdog"
-	default y
-	help
-	  Disable the watchdog in the boostrap
diff --git a/KNOWN_ISSUES b/KNOWN_ISSUES
deleted file mode 100644
index 8fa5054..0000000
--- a/KNOWN_ISSUES
+++ /dev/null
@@ -1,10 +0,0 @@
-KNOWN ISSUES
-
-1./ Using the toolchain comes with ubuntu 12.04(arm-linux-gnueabi-gcc), it builds OK
-    without warning and error, But for ek with "926ej-s" core, it fails to run on the board.
-    It seems there is some problem with "__aeabi_uidiv", "__aeabi_uidivmod" symbol of its gcclib.
-    and for sama5d3xek with "cortex-a5" core, it is OK to run on the boards.
-
-2./ Using the toolchain from the buildroot-2011.05 to build for at91sam9g10ek boards
-    after introducing the gcclibc, it builds OK without warning and error,
-    but it fails to run on the boards.
diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index 284bda4..a90fcac
--- a/Makefile
+++ b/Makefile
@@ -18,8 +18,7 @@ endif
 BINDIR:=$(TOPDIR)/binaries
 
 DATE := $(shell date)
-VERSION := 3.5.2
-REVISION :=
+VERSION := 3.4
 
 noconfig_targets:= menuconfig defconfig $(CONFIG) oldconfig
 
@@ -96,14 +95,13 @@ SIZE=$(CROSS_COMPILE)size
 OBJCOPY=$(CROSS_COMPILE)objcopy
 OBJDUMP=$(CROSS_COMPILE)objdump
 
+CCVERSION := $(strip $(subst .,, $(shell expr `$(CC) -dumpversion`)))
+CCVERSIONGE441 := $(shell test $(CCVERSION) -ge 441 && echo 1 || echo 0)
+
 PROJECT := $(strip $(subst ",,$(CONFIG_PROJECT)))
 IMG_ADDRESS := $(strip $(subst ",,$(CONFIG_IMG_ADDRESS)))
 IMG_SIZE := $(strip $(subst ",,$(CONFIG_IMG_SIZE)))
 JUMP_ADDR := $(strip $(subst ",,$(CONFIG_JUMP_ADDR)))
-OF_OFFSET := $(strip $(subst ",,$(CONFIG_OF_OFFSET)))
-OF_LENGTH := $(strip $(subst ",,$(CONFIG_OF_LENGTH)))
-OF_FILENAME := $(strip $(subst ",,$(CONFIG_OF_FILENAME)))
-OF_ADDRESS := $(strip $(subst ",,$(CONFIG_OF_ADDRESS)))
 BOOTSTRAP_MAXSIZE := $(strip $(subst ",,$(CONFIG_BOOTSTRAP_MAXSIZE)))
 MEMORY := $(strip $(subst ",,$(CONFIG_MEMORY)))
 IMAGE_NAME:= $(strip $(subst ",,$(CONFIG_IMAGE_NAME)))
@@ -113,6 +111,13 @@ OS_MEM_SIZE := $(strip $(subst ",,$(CONFIG_OS_MEM_SIZE)))
 OS_IMAGE_NAME := $(strip $(subst ",,$(CONFIG_OS_IMAGE_NAME)))
 LINUX_KERNEL_ARG_STRING := $(strip $(subst ",,$(CONFIG_LINUX_KERNEL_ARG_STRING)))
 
+DTIMG_SIZE := $(strip $(subst ",,$(CONFIG_DTIMG_SIZE)))
+DTIMG_ADDRESS := $(strip $(subst ",,$(CONFIG_DTIMG_ADDRESS)))
+DT_ADDRESS := $(strip $(subst ",,$(CONFIG_DT_ADDRESS)))
+
+SW_ECC_BCH_BLOCKSIZE := $(strip $(subst ",,$(CONFIG_SW_ECC_BCH_BLOCKSIZE)))
+SW_ECC_BCH_BITS := $(strip $(subst ",,$(CONFIG_SW_ECC_BCH_BITS)))
+
 # Board definitions
 BOARDNAME=$(strip $(subst ",,$(CONFIG_BOARDNAME)))
 
@@ -137,17 +142,15 @@ else
 REV:=-$(strip $(subst ",,$(REVISION)))
 endif
 
-ifeq ($(CONFIG_OF_LIBFDT), y)
-BLOB:=-dt
-else
-BLOB:=
-endif
-
 obj=build/$(BOARDNAME)/
 
-BOOT_NAME=$(BOARDNAME)-$(PROJECT)$(CARD_SUFFIX)boot-$(IMAGE_NAME)$(BLOB)-$(VERSION)$(REV)
+BOOT_NAME=$(BOARDNAME)-$(PROJECT)$(CARD_SUFFIX)boot-$(IMAGE_NAME)-$(VERSION)$(REV)
 AT91BOOTSTRAP:=$(BINDIR)/$(BOOT_NAME).bin
 
+ifeq ($(DESTDIR),)
+DESTDIR=install
+endif
+
 ifeq ($(IMAGE),)
 IMAGE=$(BOOT_NAME).bin
 endif
@@ -171,10 +174,10 @@ OBJS:= $(SOBJS-y) $(COBJS-y)
 INCL=board/$(BOARD)
 GC_SECTIONS=--gc-sections
 
-CPPFLAGS=-ffunction-sections -g -Os -Wall \
+CPPFLAGS=-ffunction-sections -g -O2 -Wall \
 	-fno-stack-protector \
 	-I$(INCL) -Iinclude -Ifs/include \
-	-DAT91BOOTSTRAP_VERSION=\"$(VERSION)$(REV)\" -DCOMPILE_TIME="\"$(DATE)\""
+	-DAT91BOOTSTRAP_VERSION=\"$(VERSION)\"  -DCOMPILE_TIME="\"$(DATE)\""
 
 ASFLAGS=-g -Os -Wall -I$(INCL) -Iinclude
 
@@ -188,18 +191,13 @@ include	driver/driver_cpp.mk
 #    --cref:    add cross reference to map file
 #  -lc 	   : 	tells the linker to tie in newlib
 #  -lgcc   : 	tells the linker to tie in newlib
-LDFLAGS+=-nostartfiles -Map=$(BINDIR)/$(BOOT_NAME).map --cref -static
+LDFLAGS+=-nostartfiles -Map=$(BINDIR)/$(BOOT_NAME).map --cref
 LDFLAGS+=-T elf32-littlearm.lds $(GC_SECTIONS) -Ttext $(LINK_ADDR)
 
 ifneq ($(DATA_SECTION_ADDR),)
 LDFLAGS+=-Tdata $(DATA_SECTION_ADDR)
 endif
 
-gccversion := $(shell expr `$(CC) -dumpversion`)
-
-gcclibdir := $(shell dirname `$(CC) -print-libgcc-file-name`)
-LIBPATH := -lgcc -L$(gcclibdir)
-
 ifdef YYY   # For other utils
 ifeq ($(CC),gcc) 
 TARGETS=no-cross-compiler
@@ -217,16 +215,13 @@ all: PrintFlags $(AT91BOOTSTRAP) ChkFileSize
 PrintFlags:
 	@echo CC
 	@echo ========
-	@echo $(CC) $(gccversion)&& echo
+	@echo $(CC) && echo
 	@echo as FLAGS
 	@echo ========
 	@echo $(ASFLAGS) && echo
 	@echo gcc FLAGS
 	@echo =========
 	@echo $(CPPFLAGS) && echo
-	@echo lib Path
-	@echo ========
-	@echo $(LIBPATH) && echo
 	@echo ld FLAGS
 	@echo ========
 	@echo $(LDFLAGS) && echo
@@ -234,7 +229,7 @@ PrintFlags:
 $(AT91BOOTSTRAP): $(OBJS)
 	$(if $(wildcard $(BINDIR)),,mkdir -p $(BINDIR))
 	@echo "  LD        "$(BOOT_NAME).elf
-	@$(LD) $(LDFLAGS) -n -o $(BINDIR)/$(BOOT_NAME).elf $(OBJS) ${LIBPATH}
+	@$(LD) $(LDFLAGS) -n -o $(BINDIR)/$(BOOT_NAME).elf $(OBJS)
 #	@$(OBJCOPY) --strip-debug --strip-unneeded $(BINDIR)/$(BOOT_NAME).elf -O binary $(BINDIR)/$(BOOT_NAME).bin
 	@$(OBJCOPY) --strip-all $(BINDIR)/$(BOOT_NAME).elf -O binary $@
 
@@ -246,8 +241,22 @@ $(AT91BOOTSTRAP): $(OBJS)
 	@echo "  AS        "$<
 	@$(AS) $(ASFLAGS)  -c -o $@  $<
 
+$(AT91BOOTSTRAP).fixboot:	$(AT91BOOTSTRAP)
+	./scripts/fixboot.py $(AT91BOOTSTRAP)
+
+boot:	$(AT91BOOTSTRAP).fixboot
+
+install:	bootstrap
+
+bootstrap:	$(AT91BOOTSTRAP).fixboot
+	-install -d $(DESTDIR)
+	install $(AT91BOOTSTRAP).fixboot $(DESTDIR)/$(IMAGE)
+	-rm -f $(DESTDIR)/$(SYMLINK)
+	(cd ${DESTDIR} ; \
+	 ln -sf ${IMAGE} ${SYMLINK} \
+	)
 
-PHONY+= boot bootstrap
+PHONY+= boot install bootstrap
 
 rebuild: clean all
 
@@ -255,15 +264,14 @@ ChkFileSize: $(AT91BOOTSTRAP)
 	@( fsize=`stat -c%s $(BINDIR)/$(BOOT_NAME).bin`; \
 	  echo "Size of $(BOOT_NAME).bin is $$fsize bytes"; \
 	  if [ "$$fsize" -gt "$(BOOTSTRAP_MAXSIZE)" ] ; then \
-		echo "[Failed***] It's too big to fit into SRAM area. the support maxium size is $(BOOTSTRAP_MAXSIZE)"; \
-		rm -rf $(BINDIR); \
+		echo "[Failed***] It's too big to fit into SRAM area."; \
 		exit 2;\
 	  else \
 	  	echo "[Succeeded] It's OK to fit into SRAM area"; \
 	  fi )
 endif  # HAVE_DOT_CONFIG
 
-PHONY+= rebuild
+PHONY+= rebuild chkFilesize
 
 %_defconfig:
 	echo $(shell find ./board/ -name $@)
@@ -349,7 +357,7 @@ tarball: distrib
 	bzip2  ../source/at91bootstrap-$(VERSION).tar
 	cp ../source/at91bootstrap-$(VERSION).tar.bz2 /usr/local/install/downloads
 
-tarballx: clean
+tarballx:	clean
 	F=`basename $(CURDIR)` ; cd .. ; \
 	T=`basename $(CURDIR)`-$(VERSION).tar ;  \
 	tar --force-local -cvf $$T $$F; \
diff --git a/README.txt b/README.txt
deleted file mode 100644
index 49fb1a6..0000000
--- a/README.txt
+++ /dev/null
@@ -1,113 +0,0 @@
-Compiling an at91bootstrap project
-
-1 GNU ARM Toolchain
-===========================================================================================
-1.1 Linux
-
-AT91Bootstrap 3.5.1 has been compiled and tested under Linux using the following GNU ARM Toolchain
-- Coudesourcery 2007 Q1
-- Coudesourcery 2008 Q1
-- Coudesourcery 2009 Q3
-- Coudesourcery 2010 Q1
-- Coudesourcery 2011.03
-- Toolchain generated by OE (2011.03)
-- Toolchain generated by buildroot(2011.05)
-
-1.2 Compile DataFlashBoot
-===========================================================================================
-
-Let's use at91sam9x5ek as an example,
-
-1.2.1 Compile booting u-boot image from DataFlash
-
-$ cd <project directory>
-$ make mrproper
-$ make at91sam9x5ekdf_uboot_defconfig
-$ make
-
-If the building process is successful, the final .bin image can be found under binaries/
-
-1.2.2 Compile booting kernel image from DataFlash
-
-$ cd <project directory>
-$ make mrproper
-$ make at91sam9x5ekdf_linux_defconfig
-$ make
-
-If the building process is successful, the final .bin image can be found under binaries/
-
-
-1.2.3 Compile booting kernel & dt image from DataFlash
-
-$ cd <project directory>
-$ make mrproper
-$ make at91sam9x5ekdf_linux_dt_defconfig
-$ make
-
-If the building process is successful, the final .bin image can be found under binaries/
-
-1.3 Compile NandFlashBoot
-===========================================================================================
-
-Let's use at91sam9m10g45ek as an example,
-
-1.3.1 Compile bootiing u-boot image from NandFlash
-
-$ cd <project directory>
-$ make mrproper
-$ make at91sam9m10g45eknf_uboot_defconfig 
-$ make
-
-If the building process is successful, the final .bin image can be found under binaries/
-
-1.3.2 Compile booting kernel image from NandFlash
-
-$ cd <project directory>
-$ make mrproper
-$ make at91sam9m10g45eknf_linux_defconfig
-$ make
-
-If the building process is successful, the final .bin image can be found under binaries/
-
-1.3.3 Compile booting kernel & dt image from NandFlash
-
-$ cd <project directory>
-$ make mrproper
-$ make at91sam9m10g45eknf_linux_dt_defconfig
-$ make
-
-If the building process is successful, the final .bin image can be found under binaries/
-
-1.4 Compile SDCardBoot
-===========================================================================================
-
-Let's use at91sam9m10g45ek as an example,
-
-1.4.1 Compile booting u-boot image from SDCard
-
-$ cd <project directory>
-$ make mrproper
-$ make at91sam9m10g45eksd_uboot_defconfig
-$ make
-
-If the building process is successful, the final .bin image can be found under binaries/
-
-1.4.2 Compile booting linux image from SDCard
-
-$ cd <project directory>
-$ make mrproper
-$ make at91sam9m10g45eksd_linux_defconfig
-$ make
-
-If the building process is successful, the final .bin image can be found under binaries/
-
-1.4.2 Compile booting linux & dt image from SDCard
-
-$ cd <project directory>
-$ make mrproper
-$ make at91sam9m10g45eksd_linux_dt_defconfig
-$ make
-
-If the building process is successful, the final .bin image can be found under binaries/
-
--End-
diff --git a/board/Config.in b/board/Config.in
old mode 100644
new mode 100755
index a8285c0..7d3bee4
--- a/board/Config.in
+++ b/board/Config.in
@@ -4,6 +4,11 @@ config	HAVE_DOT_CONFIG
 
 config CONFIG_BOARDNAME
 	string "Board Name"
+	default "ag11005" if CONFIG_AG11005
+	default "stamp9g20" if CONFIG_STAMP9G20
+	default "stamp9g45" if CONFIG_STAMP9G45
+	default "nanosg20" if CONFIG_NANOSG20
+	default "picosg20" if CONFIG_PICOSG20
 	default "at91sam9260ek"
 	help
 	  Name of the target
@@ -152,7 +157,6 @@ config	CONFIG_AT91SAM9X5EK
 	select ALLOW_NANDFLASH_RECOVERY
 	select ALLOW_PIO3
 	select CPU_HAS_PMECC
-	select CONFIG_LOAD_ONE_WIRE
 	help
 	  Use the AT91SAM9X5EK Development board
 
@@ -184,13 +188,42 @@ config CONFIG_AT91SAMA5D3XEK
 	select ALLOW_CPU_CLK_533MHZ
 	select ALLOW_CRYSTAL_12_000MHZ
 	select ALLOW_BOOT_FROM_DATAFLASH_CS0
+	select ALLOW_DATAFLASH_RECOVERY
+	select ALLOW_NANDFLASH_RECOVERY
 	select ALLOW_PIO3
 	select CPU_HAS_PMECC
-	select CONFIG_LOAD_ONE_WIRE
-	select CONFIG_MMC_SUPPORT
 	help
 	  Use the AT91SAM9N12EK Development board
 
+config	CONFIG_STAMP9G20
+	bool "stamp9g20"
+	select CONFIG_SDRAM
+	select ALLOW_NANDFLASH
+	select ALLOW_CPU_CLK_400MHZ
+	select ALLOW_CRYSTAL_18_432MHZ
+
+config	CONFIG_STAMP9G45
+	bool "stamp9g45"
+	select CONFIG_DDR2
+	select ALLOW_NANDFLASH
+	select ALLOW_CPU_CLK_400MHZ
+	select ALLOW_CRYSTAL_18_432MHZ
+
+config	CONFIG_NANOSG20
+	bool "nanosg20"
+	select CONFIG_SDRAM
+	select ALLOW_NANDFLASH
+	select ALLOW_CPU_CLK_400MHZ
+	select ALLOW_CRYSTAL_18_432MHZ
+
+config	CONFIG_PICOSG20
+	bool "picosg20"
+	select CONFIG_SDRAM
+	select ALLOW_NANDFLASH
+	select ALLOW_CPU_CLK_400MHZ
+	select ALLOW_CRYSTAL_18_432MHZ
+	select ALLOW_NANDFLASH_RECOVERY
+
 endchoice
 
 config CONFIG_CHIP
@@ -206,6 +239,10 @@ config CONFIG_CHIP
 	default "AT91SAM9X5"	if CONFIG_AT91SAM9X5EK
 	default "AT91SAM9N12"	if CONFIG_AT91SAM9N12EK
 	default "AT91SAMA5D3X"	if CONFIG_AT91SAMA5D3XEK
+	default "AT91SAM9G20"	if CONFIG_STAMP9G20
+	default "AT91SAM9G45"	if CONFIG_STAMP9G45
+	default "AT91SAM9G20"	if CONFIG_NANOSG20
+	default "AT91SAM9G20"	if CONFIG_PICOSG20
 	help
 	  Name of the board, A Board Support package
 	  (BSP) must be available.
@@ -223,6 +260,10 @@ config CONFIG_BOARD
 	default "at91sam9n12ek"	if CONFIG_AT91SAM9N12EK
 	default "at91sam9m10g45ek"	if CONFIG_AT91SAM9M10G45EK
 	default "at91sama5d3xek"	if CONFIG_AT91SAMA5D3XEK
+	default "stamp9g20"	if CONFIG_STAMP9G20
+	default "stamp9g45"	if CONFIG_STAMP9G45
+	default "nanosg20"	if CONFIG_NANOSG20
+	default "picosg20"	if CONFIG_PICOSG20
 	help
 	  Name of the board, A Board Support package
 	  (BSP) must be available.
@@ -240,10 +281,16 @@ config CONFIG_MACH_TYPE
 	default "3373"	if CONFIG_AT91SAM9X5EK		# 3373
 	default "9999"	if CONFIG_AT91SAM9N12EK
 	default "9999"	if CONFIG_AT91SAMA5D3XEK
+	default "1824"	if CONFIG_STAMP9G20
+	default "2761"	if CONFIG_STAMP9G45
+	default "2759"	if CONFIG_NANOSG20
+	default "0"	if CONFIG_PICOSG20
 	help
 
 config CONFIG_LINK_ADDR
 	string
+	default "0x300000" if CONFIG_AT91SAM9N12EK
+	default "0x300000" if CONFIG_AT91SAMA5D3XEK
 	default "0x000000"
 	help
 
@@ -265,6 +312,10 @@ config CONFIG_TOP_OF_MEMORY
 	default "0x308000"	if CONFIG_AT91SAM9X5EK
 	default "0x308000"	if CONFIG_AT91SAM9N12EK
 	default "0x310000"	if CONFIG_AT91SAMA5D3XEK
+	default "0x304000"	if CONFIG_STAMP9G20
+	default "0x30A000"	if CONFIG_STAMP9G45
+	default "0x304000"	if CONFIG_NANOSG20
+	default "0x304000"	if CONFIG_PICOSG20
 	help
 
 choice
diff --git a/board/ag11005/ag11005.c b/board/ag11005/ag11005.c
new file mode 100755
index 0000000..4b6b29e
--- /dev/null
+++ b/board/ag11005/ag11005.c
@@ -0,0 +1,313 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "common.h"
+#include "hardware.h"
+#include "arch/at91_ccfg.h"
+#include "arch/at91_wdt.h"
+#include "arch/at91_rstc.h"
+#include "arch/at91_pmc.h"
+#include "arch/at91_smc.h"
+#include "arch/at91_pio.h"
+#include "arch/at91_ddrsdrc.h"
+#include "gpio.h"
+#include "pmc.h"
+#include "dbgu.h"
+#include "debug.h"
+#include "ddramc.h"
+#include "slowclk.h"
+#include "ag11005.h"
+
+unsigned int get_cp15();
+void set_cp15(unsigned int);
+#define I_CACHE (1<<12)
+
+#ifdef CONFIG_USER_HW_INIT
+extern void hw_init_hook(void);
+#endif
+
+static void at91_dbgu_hw_init(void)
+{
+	/* Configure DBGU pin */
+	const struct pio_desc dbgu_pins[] = {
+		{"RXD", AT91C_PIN_PB(12), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"TXD", AT91C_PIN_PB(13), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Configure the dbgu pins */
+	pio_configure(dbgu_pins);
+	writel((1 << AT91C_ID_PIOB), (PMC_PCER + AT91C_BASE_PMC));
+}
+
+static void initialize_dbgu(void)
+{
+	at91_dbgu_hw_init();
+	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
+}
+
+static void ddramc_reg_config(struct ddramc_register *ddramc_config)
+{
+	ddramc_config->mdr = (AT91C_DDRC2_DBW_16_BITS
+			| AT91C_DDRC2_MD_DDR2_SDRAM);
+
+	ddramc_config->cr = (AT91C_DDRC2_NC_DDR10_SDR9	/* 10 column bits */
+			| AT91C_DDRC2_NR_14		/* 14 row bits(8K)*/
+			| AT91C_DDRC2_CAS_3		/* CAS Latency 3 */
+			| AT91C_DDRC2_EBISHARE		/* DQM is shared with other controller */
+			| AT91C_DDRC2_DLL_RESET_DISABLED);	/* DLL not reset*/
+
+	ddramc_config->rtr = 0x24B;
+
+	ddramc_config->t0pr = (AT91C_DDRC2_TRAS_6	/* 6 * 7.5 = 45 ns */
+			| AT91C_DDRC2_TRCD_2	/* 2 * 7.5 = 22.5 ns */
+			| AT91C_DDRC2_TWR_2	/* 2 * 7.5 = 15 ns */
+			| AT91C_DDRC2_TRC_8	/* 8 * 7.5 = 75 ns */
+			| AT91C_DDRC2_TRP_2	/* 2 * 7.5 = 22.5 ns */
+			| AT91C_DDRC2_TRRD_1	/* 1 * 7.5 = 7.5 ns */
+			| AT91C_DDRC2_TWTR_1	/* 1 clock cycle */
+			| AT91C_DDRC2_TMRD_2);	/* 2 clock cycles */
+
+	ddramc_config->t1pr = (AT91C_DDRC2_TXP_2	/* 2 * 7.5 = 15 ns */
+			| 200 << 16			/* 200 clock cycles */
+			| 16 << 8			/* 16 * 7.5 = 120 ns */
+			| AT91C_DDRC2_TRFC_14 << 0);	/* 14 * 7.5 = 142 ns */
+
+	ddramc_config->t2pr = (AT91C_DDRC2_TRTP_1	/* 1 * 7.5 = 7.5 ns */
+			| AT91C_DDRC2_TRPA_0		/* 0 * 7.5 = 0 ns */
+			| AT91C_DDRC2_TXARDS_7		/* 7 clock cycles */
+			| AT91C_DDRC2_TXARD_2);		/* 2 clock cycles */
+}
+
+static void ddramc_init(void)
+{
+	unsigned long csa;
+	struct ddramc_register  ddramc_reg;
+
+	ddramc_reg_config(&ddramc_reg);
+
+	/* ENABLE DDR2 clock */ 
+	writel(AT91C_PMC_DDR, AT91C_BASE_PMC + PMC_SCER);
+
+	/* Chip select 1 is for DDR2/SDRAM */
+	csa = readl(AT91C_BASE_CCFG + CCFG_EBICSA);
+	csa |= AT91C_EBI_CS1A_SDRAMC;
+	csa &= ~AT91C_VDDIOM_SEL_33V;
+	writel(csa, AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/* DDRAM2 Controller initialize */
+	ddram_initialize(AT91C_BASE_DDRSDRC, AT91C_DDRAM_BASE_ADDR, &ddramc_reg);
+	/*
+	* EBI IO in 1.8V mode 
+	*/
+	writel(readl(AT91C_BASE_CCFG + CCFG_EBICSA) & ~(1 << 16),
+		AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/*
+	* EBI DDRAM controller 
+	*/
+	ddram_initialize(AT91C_BASE_DDRSDRC1, AT91C_BASE_CS1, &ddramc_reg);	
+}
+
+#ifdef CONFIG_HW_INIT
+void hw_init(void)
+{
+    unsigned int cp15;
+    int i;
+
+	/* Disable watchdog */
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDTC + WDTC_MR);
+
+	/* At this stage the main oscillator
+	 * is supposed to be enabled PCK = MCK = MOSC */
+	writel(0x00, AT91C_BASE_PMC + PMC_PLLICPR);
+
+	/* Configure PLLA = MOSC * (PLL_MULA + 1) / PLL_DIVA */
+	pmc_cfg_plla(PLLA_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* PCK = PLLA/2 = 3 * MCK */
+	pmc_cfg_mck(BOARD_PRESCALER, PLL_LOCK_TIMEOUT);
+
+	/* Switch MCK on PLLA output */
+	pmc_cfg_mck(0x1302, PLL_LOCK_TIMEOUT);
+
+	/* Enable External Reset */
+	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
+
+    /*
+     * Configure CP15 
+     */
+    cp15 = get_cp15();
+    cp15 |= I_CACHE;
+    set_cp15(cp15);
+
+	/* Initialize dbgu */
+	initialize_dbgu();
+	dbgu_print("Start AT91Bootstrap...\n\r");
+
+#ifdef CONFIG_SCLK
+	slowclk_enable_osc32();
+#endif
+
+	/* Initialize DDRAM Controller */
+	ddramc_init();
+	
+	/*
+	 * Configure the FPGA pins
+	 */
+	const struct pio_desc fpga_pio[] = {
+		{"INIT_B",  AT91C_PIN_PD(29), 1, PIO_OPENDRAIN, PIO_OUTPUT},
+		{"PROGRAM_B",  AT91C_PIN_PD(28), 1, PIO_DEFAULT, PIO_OUTPUT},
+		{"DONE",  AT91C_PIN_PD(30), 1, PIO_OPENDRAIN, PIO_OUTPUT}
+	};
+	writel((1 << AT91C_ID_PIOD_E), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(fpga_pio);
+	
+	/*
+	 * Reset the FPGA
+	 */
+	// release INIT_B
+	pio_set_value(AT91C_PIN_PD(29), 1);
+	// release DONE
+	pio_set_value(AT91C_PIN_PD(30), 1);
+	
+	// Clear configuration memory by asserting PROGRAM_B
+	pio_set_value(AT91C_PIN_PD(28), 0);
+	
+	// Wait for INIT_B to be driven low by the FPGA
+	do {
+		for (i = 0; i < 100000; i++) asm("    nop");
+		if (++i > 10)
+			break;
+	} while (pio_get_value(AT91C_PIN_PD(29)));
+
+	// Wait a short time before releasing PROGRAM_B
+	for (i = 0; i < 1000; i++) asm("    nop");
+	pio_set_value(AT91C_PIN_PD(28), 1);
+	
+	/*
+     * Configure the SDCard detect pin
+     */
+	const struct pio_desc cd_pio[] = {
+		{"DETECT",  AT91C_PIN_PA(6), 1, PIO_DEGLITCH, PIO_INPUT}
+	};
+	
+	/* Configure the PIO controller */
+	writel((1 << AT91C_ID_PIOA), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(cd_pio);
+	
+    // Check CD pin (PA6, active low) here first
+    if(!pio_get_value(AT91C_PIN_PA(6)))
+        card_present = 1;
+
+#ifdef CONFIG_USER_HW_INIT
+	hw_init_hook();
+#endif
+}
+#endif /* #ifdef CONFIG_HW_INIT */
+
+void at91_mci0_hw_init(void)
+{
+	const struct pio_desc mci_pins[] = {
+		{"MCCK", 	AT91C_PIN_PA(0), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCCDA",	AT91C_PIN_PA(1), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCDA0",	AT91C_PIN_PA(2), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCDA1",	AT91C_PIN_PA(3), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCDA2",	AT91C_PIN_PA(4), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCDA3",	AT91C_PIN_PA(5), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Configure the PIO controller */
+	writel((1 << AT91C_ID_PIOA), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(mci_pins);
+
+	/* Enable the clock */
+	writel((1 << AT91C_ID_MCI0), (PMC_PCER + AT91C_BASE_PMC));
+}
+
+void nandflash_hw_init(void)
+{
+	unsigned int reg;
+
+	/* Configure PIOs */
+	const struct pio_desc nand_pins[] = {
+		{"NANDCS",	CONFIG_SYS_NAND_ENABLE_PIN,	1, PIO_PULLUP, PIO_OUTPUT},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Setup Smart Media, first enable the address range of CS3
+	 * in HMATRIX user interface
+	* EBI IO in 1.8V mode */
+	reg = readl(AT91C_BASE_CCFG + CCFG_EBICSA);
+	reg |= AT91C_EBI_CS3A_SM;
+	reg &= ~AT91C_VDDIOM_SEL_33V;
+	writel(reg, AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/* Configure SMC CS3 */
+	writel((AT91C_SMC_NWESETUP_(2)
+		| AT91C_SMC_NCS_WRSETUP_(0)
+		| AT91C_SMC_NRDSETUP_(2)
+		| AT91C_SMC_NCS_RDSETUP_(0)),
+		AT91C_BASE_SMC + SMC_SETUP3);
+
+	writel((AT91C_SMC_NWEPULSE_(4)
+		| AT91C_SMC_NCS_WRPULSE_(4)
+		| AT91C_SMC_NRDPULSE_(4)
+		| AT91C_SMC_NCS_RDPULSE_(4)),
+		AT91C_BASE_SMC + SMC_PULSE3);
+
+	writel((AT91C_SMC_NWECYCLE_(7)
+		|  AT91C_SMC_NRDCYCLE_(7)),
+		AT91C_BASE_SMC + SMC_CYCLE3);
+
+	writel((AT91C_SMC_READMODE
+		| AT91C_SMC_WRITEMODE
+		| AT91C_SMC_NWAITM_NWAIT_DISABLE
+		| AT91C_SMC_DBW_WIDTH_BITS_16
+		| AT91_SMC_TDF_(3)),
+		AT91C_BASE_SMC + SMC_CTRL3);
+
+	/* Configure the PIO controll */
+	writel((1 << AT91C_ID_PIOC), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(nand_pins);
+
+}
+
+void nandflash_config_buswidth(unsigned char busw)
+{
+	unsigned long csa;
+
+	csa = readl(AT91C_BASE_SMC + SMC_CTRL3);
+
+	if (busw == 0)
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_8;
+	else
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_16;
+
+	writel(csa, AT91C_BASE_SMC + SMC_CTRL3);
+}
diff --git a/board/ag11005/ag11005.h b/board/ag11005/ag11005.h
new file mode 100755
index 0000000..51324a3
--- /dev/null
+++ b/board/ag11005/ag11005.h
@@ -0,0 +1,91 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __AG11005_H__
+#define __AG11005_H__
+
+/*
+ * PMC Settings
+ *
+ * The main oscillator is enabled as soon as possible in the c_startup
+ * and MCK is switched on the main oscillator.
+ * PLL initialization is done later in the hw_init() function
+ */
+#define MASTER_CLOCK		(132096000)
+#define PLL_LOCK_TIMEOUT	1000000
+
+#define BOARD_MAINOSC           12000000
+#define BOARD_MCK               ((unsigned long)((BOARD_MAINOSC / 3 / 2 / 3) * 200 ))   // 133MHz
+#define BOARD_OSCOUNT           (AT91C_CKGR_OSCOUNT & (64 << 8))
+#define BOARD_CKGR_PLLA         (AT91C_CKGR_SRCA | AT91C_CKGR_OUTA_0)
+#define BOARD_PLLACOUNT         (0x3F << 8)
+#define BOARD_MULA              (AT91C_CKGR_MULA & (199 << 16))
+#define BOARD_DIVA              (AT91C_CKGR_DIVA & 3)
+#define BOARD_PRESCALER         (0x00001301)
+
+#define PLLA_SETTINGS           ( BOARD_CKGR_PLLA \
+                                | BOARD_PLLACOUNT \
+                                | BOARD_MULA \
+                                | BOARD_DIVA)
+
+//#define PLLA_SETTINGS 0x202A3F01
+#define PLLUTMI
+#define PLLUTMI_SETTINGS	0x10193F05
+
+/* Switch MCK on PLLA output PCK = PLLA/2 = 3 * MCK */
+#define MCKR_CSS_SETTINGS	0x1302
+
+/* DDRAM Controller */
+#define AT91C_BASE_DDRSDRC	AT91C_BASE_DDRSDRC0
+#define AT91C_DDRAM_BASE_ADDR	AT91C_BASE_CS6
+
+/* NAND Flash Settings */
+#define CONFIG_SYS_NAND_BASE		AT91C_BASE_CS3
+#define CONFIG_SYS_NAND_MASK_ALE	(1 << 21)
+#define CONFIG_SYS_NAND_MASK_CLE	(1 << 22)
+
+#define CONFIG_SYS_NAND_ENABLE_PIN	AT91C_PIN_PC(14)
+
+#define NAND_JUMP_ADDR		0x73f00000
+#define NAND_IMG_SIZE		0x80000
+#define NAND_IMG_ADDRESS	0x20000
+
+/*
+ * MCI Settings
+ */
+#define CONFIG_SYS_BASE_MCI     AT91C_BASE_MCI0
+
+/* function */
+extern void hw_init(void);
+
+extern void nandflash_hw_init(void);
+extern void nandflash_config_buswidth(unsigned char busw);
+extern unsigned int nandflash_get_ready_pin(void);
+
+extern void at91_mci0_hw_init(void);
+
+#endif /* __AG11005__ */
diff --git a/board/ag11005/ag11005_defconfig b/board/ag11005/ag11005_defconfig
new file mode 100755
index 0000000..3a36df0
--- /dev/null
+++ b/board/ag11005/ag11005_defconfig
@@ -0,0 +1,115 @@
+#
+# Automatically generated make config: don't edit
+# Fri Jun 29 11:13:35 2012
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="ag11005"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+CONFIG_AG11005=y
+CONFIG_CHIP="AT91SAM9G45"
+CONFIG_BOARD="ag11005"
+CONFIG_MACH_TYPE="3428"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x30A000"
+CONFIG_CRYSTAL_12_000MHZ=y
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+# CONFIG_CRYSTAL_18_432MHZ is not set
+ALLOW_CRYSTAL_12_000MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+# CONFIG_SDRAM is not set
+# CONFIG_SDDRC is not set
+CONFIG_DDR2=y
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+ALLOW_SDCARD=y
+ALLOW_HSMCI=y
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_MEMORY="nandflash"
+CONFIG_SDCARD=y
+CONFIG_SDCARD_HS=y
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=4
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="multi"
+# CONFIG_LOAD_UBOOT is not set
+# CONFIG_LOAD_EBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_NK is not set
+# CONFIG_LOAD_64KB is not set
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x70000000"
+CONFIG_OS_MEM_SIZE="0x8000000"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 console=tty0 root=/dev/mmcblk0p2 ro rootwait"
+CONFIG_OS_IMAGE_NAME="uImage"
+CONFIG_OS_IMG_SIZE="0x280000"
+CONFIG_LINUX_IMG_NAND_OFFSET="0x200000"
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_SETTING_ADDRESS="0x01FE0000"
+CONFIG_SETTING_SIZE="0x00001000"
+CONFIG_IMG_SIZE="0x00280000"
+CONFIG_JUMP_ADDR="0x72000000"
+CONFIG_GLBDRV_ADDR="0x7006b000"
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+# CONFIG_THUMB is not set
+CONFIG_SCLK=y
diff --git a/board/ag11005/board.mk b/board/ag11005/board.mk
new file mode 100755
index 0000000..c77b3d4
--- /dev/null
+++ b/board/ag11005/board.mk
@@ -0,0 +1,7 @@
+CPPFLAGS += \
+	-DCONFIG_AG11005 \
+	-mcpu=arm926ej-s
+
+ASFLAGS += \
+	-DCONFIG_AG11005 \
+	-mcpu=arm926ej-s
diff --git a/board/at91sam9260ek/at91sam9260ek.c b/board/at91sam9260ek/at91sam9260ek.c
old mode 100644
new mode 100755
index 8e0ebee..a8dab13
--- a/board/at91sam9260ek/at91sam9260ek.c
+++ b/board/at91sam9260ek/at91sam9260ek.c
@@ -30,6 +30,7 @@
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
 #include "arch/at91_matrix.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -41,14 +42,13 @@
 #include "dbgu.h"
 #include "debug.h"
 #include "sdramc.h"
-#include "timer.h"
-#include "watchdog.h"
 #include "at91sam9260ek.h"
 
 #ifdef CONFIG_USER_HW_INIT
 extern void hw_init_hook(void);
 #endif
 
+#ifdef CONFIG_DEBUG
 static void initialize_dbgu(void)
 {
 	/* Configure DBGU pin */
@@ -61,6 +61,7 @@ static void initialize_dbgu(void)
 
 	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_SDRAM
 static void sdramc_init(void)
@@ -109,7 +110,7 @@ static void recovery_buttons_hw_init(void)
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/*
 	 * At this stage the main oscillator is supposed to be enabled
@@ -135,11 +136,10 @@ void hw_init(void)
 			| AT91C_MATRIX_SLOT_CYCLE_(0x40),
 			AT91C_BASE_MATRIX + MATRIX_SCFG3);
 
-	/* Init timer */
-	timer_init();
-
+#ifdef CONFIG_DEBUG
 	/* Initialize dbgu */
 	initialize_dbgu();
+#endif
 
 #ifdef CONFIG_SDRAM
 	/* Initlialize sdram controller */
diff --git a/board/at91sam9260ek/at91sam9260ek.h b/board/at91sam9260ek/at91sam9260ek.h
old mode 100644
new mode 100755
index ef5b5f0..5940cd9
--- a/board/at91sam9260ek/at91sam9260ek.h
+++ b/board/at91sam9260ek/at91sam9260ek.h
@@ -60,8 +60,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(3)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PC(11)
 #endif
 
diff --git a/board/at91sam9260ek/at91sam9260ekdf_uboot_defconfig b/board/at91sam9260ek/at91sam9260ekdf_uboot_defconfig
old mode 100644
new mode 100755
index 60876dd..6ca2c61
--- a/board/at91sam9260ek/at91sam9260ekdf_uboot_defconfig
+++ b/board/at91sam9260ek/at91sam9260ekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:41:08 2012
+# Wed Jun 27 14:37:29 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9260ek"
@@ -32,7 +32,6 @@ CONFIG_CPU_CLK_200MHZ=y
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -41,7 +40,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -99,8 +97,8 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_SIZE="0x00040000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -111,4 +109,3 @@ CONFIG_IMAGE_NAME="uboot"
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9260ek/at91sam9260eknf_uboot_defconfig b/board/at91sam9260ek/at91sam9260eknf_uboot_defconfig
old mode 100644
new mode 100755
index 9a07c22..fc0ff6f
--- a/board/at91sam9260ek/at91sam9260eknf_uboot_defconfig
+++ b/board/at91sam9260ek/at91sam9260eknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Jan 17 16:26:54 2013
+# Wed Jun 27 14:35:28 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9260ek"
@@ -32,7 +32,6 @@ CONFIG_CPU_CLK_200MHZ=y
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -41,8 +40,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -78,7 +75,7 @@ DATAFLASHCARD_ON_CS0=y
 #
 CONFIG_ENABLE_SW_ECC=y
 # CONFIG_NANDFLASH_SMALL_BLOCKS is not set
-# CONFIG_NANDFLASH_RECOVERY is not set
+CONFIG_NANDFLASH_RECOVERY=y
 ALLOW_NANDFLASH_RECOVERY=y
 CONFIG_BOOTSTRAP_MAXSIZE="4096"
 CONFIG_PROJECT="nandflash"
@@ -87,9 +84,9 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_1MB is not set
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
-CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00040000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -100,4 +97,3 @@ CONFIG_IMAGE_NAME="uboot"
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9260ek/board.mk b/board/at91sam9260ek/board.mk
old mode 100644
new mode 100755
index 6ad7f4b..c7c75fc
--- a/board/at91sam9260ek/board.mk
+++ b/board/at91sam9260ek/board.mk
@@ -5,4 +5,3 @@ CPPFLAGS += \
 ASFLAGS += \
 	-DCONFIG_AT91SAM9260EK \
 	-mcpu=arm926ej-s
-
diff --git a/board/at91sam9261ek/at91sam9261ek.c b/board/at91sam9261ek/at91sam9261ek.c
old mode 100644
new mode 100755
index d4b33b5..7f6acd5
--- a/board/at91sam9261ek/at91sam9261ek.c
+++ b/board/at91sam9261ek/at91sam9261ek.c
@@ -29,6 +29,7 @@
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
 #include "arch/at91sam9g10_matrix.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -40,8 +41,6 @@
 #include "debug.h"
 #include "dbgu.h"
 #include "sdramc.h"
-#include "timer.h"
-#include "watchdog.h"
 #include "at91sam9261ek.h"
 
 #ifdef CONFIG_USER_HW_INIT
@@ -78,6 +77,7 @@ static void at91_matrix_hw_init(void)
 	matrix_writel(reg, MATRIX_SCFG3);
 }
 
+#ifdef CONFIG_DEBUG
 static void at91_dbgu_hw_init(void)
 {
 	/* Configure DBGU pin */
@@ -98,6 +98,7 @@ static void initialize_dbgu(void)
 	at91_dbgu_hw_init();
 	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_SDRAM
 void sdramc_hw_init(void)
@@ -185,7 +186,7 @@ static void recovery_buttons_hw_init(void)
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/*
 	 * At this stage the main oscillator is supposed to be enabled
@@ -209,11 +210,10 @@ void hw_init(void)
 	/* Initialize matrix */
 	at91_matrix_hw_init();
 
-	/* Init timer */
-	timer_init();
-
+#ifdef CONFIG_DEBUG
 	/* Initialize dbgu */
 	initialize_dbgu();
+#endif
 
 #ifdef CONFIG_SDRAM
 	/* Initlialize sdram controller */
diff --git a/board/at91sam9261ek/at91sam9261ek.h b/board/at91sam9261ek/at91sam9261ek.h
old mode 100644
new mode 100755
index fb18917..4330720
--- a/board/at91sam9261ek/at91sam9261ek.h
+++ b/board/at91sam9261ek/at91sam9261ek.h
@@ -74,8 +74,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(3)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS3_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(6)
 #endif
 
diff --git a/board/at91sam9261ek/at91sam9261ekdf_linux_defconfig b/board/at91sam9261ek/at91sam9261ekdf_linux_defconfig
old mode 100644
new mode 100755
index f9695db..c2cfb4d
--- a/board/at91sam9261ek/at91sam9261ekdf_linux_defconfig
+++ b/board/at91sam9261ek/at91sam9261ekdf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:52:03 2012
+# Thu Jun 28 16:00:31 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9261ek"
@@ -42,8 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -106,11 +104,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00042000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -120,4 +117,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9261ek/at91sam9261ekdf_uboot_defconfig b/board/at91sam9261ek/at91sam9261ekdf_uboot_defconfig
old mode 100644
new mode 100755
index 70a41e1..188aeb9
--- a/board/at91sam9261ek/at91sam9261ekdf_uboot_defconfig
+++ b/board/at91sam9261ek/at91sam9261ekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:38:17 2012
+# Thu Jun 28 15:59:13 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9261ek"
@@ -42,7 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -100,8 +99,8 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_SIZE="0x00040000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -115,4 +114,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9261ek/at91sam9261eknf_linux_defconfig b/board/at91sam9261ek/at91sam9261eknf_linux_defconfig
old mode 100644
new mode 100755
index 39ef1b0..60847ab
--- a/board/at91sam9261ek/at91sam9261eknf_linux_defconfig
+++ b/board/at91sam9261ek/at91sam9261eknf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:51:14 2012
+# Thu Jun 28 16:04:44 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9261ek"
@@ -42,8 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -93,11 +91,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00200000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -107,4 +104,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9261ek/at91sam9261eknf_uboot_defconfig b/board/at91sam9261ek/at91sam9261eknf_uboot_defconfig
old mode 100644
new mode 100755
index 3f46a1e..7d4153b
--- a/board/at91sam9261ek/at91sam9261eknf_uboot_defconfig
+++ b/board/at91sam9261ek/at91sam9261eknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:38:43 2012
+# Thu Jun 28 16:03:45 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9261ek"
@@ -42,7 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -86,9 +85,9 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_1MB is not set
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
-CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00040000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -102,4 +101,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9261ek/board.mk b/board/at91sam9261ek/board.mk
old mode 100644
new mode 100755
diff --git a/board/at91sam9263ek/at91sam9263ek.c b/board/at91sam9263ek/at91sam9263ek.c
old mode 100644
new mode 100755
index 7b07bf1..23cb76a
--- a/board/at91sam9263ek/at91sam9263ek.c
+++ b/board/at91sam9263ek/at91sam9263ek.c
@@ -28,6 +28,7 @@
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
 #include "arch/at91_matrix.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -40,8 +41,6 @@
 #include "debug.h"
 #include "sdramc.h"
 #include "psram.h"
-#include "timer.h"
-#include "watchdog.h"
 #include "at91sam9263ek.h"
 
 #ifdef CONFIG_USER_HW_INIT
@@ -228,6 +227,7 @@ static void at91_matrix_hw_init(void)
 			MATRIX_PRBS4);
 }
 
+#ifdef CONFIG_DEBUG
 static void at91_dbgu_hw_init(void)
 {
 	/* Configure DBGU pin */
@@ -249,6 +249,7 @@ static void initialize_dbgu(void)
 
 	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_SDRAM
 static void sdramc_hw_init(void)
@@ -322,6 +323,7 @@ static void data_access_enable(void)
 
 static void psram_hw_init(void)
 {
+	volatile unsigned short tmp;
 	unsigned short *addressMax = (unsigned short *)MICRON_8MB_ADDRESS_MAX;
 
 	const struct pio_desc psram_pins[] = {
@@ -360,8 +362,8 @@ static void psram_hw_init(void)
 	data_access_enable();
 
 	/* Enable page mode */
-	readl(addressMax);
-	readl(addressMax);
+	tmp = readl(addressMax);
+	tmp = readl(addressMax);
 	writel(MICRON_RCR, addressMax);
 	writel(MICRON_PAGE_MODE_ENABLE, addressMax);
 }
@@ -385,7 +387,7 @@ static void recovery_buttons_hw_init(void)
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/*
 	 * At this stage the main oscillator is supposed to be enabled
@@ -408,11 +410,10 @@ void hw_init(void)
 
 	at91_matrix_hw_init();
 
-	/* Init timer */
-	timer_init();
-
+#ifdef CONFIG_DEBUG
 	/* Initialize dbgu */
 	initialize_dbgu();
+#endif
 
 #ifdef CONFIG_SDRAM
 	/* Initialize SDRAMC0 */
diff --git a/board/at91sam9263ek/at91sam9263ek.h b/board/at91sam9263ek/at91sam9263ek.h
old mode 100644
new mode 100755
index 771ad8e..0b90b5d
--- a/board/at91sam9263ek/at91sam9263ek.h
+++ b/board/at91sam9263ek/at91sam9263ek.h
@@ -87,8 +87,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(5)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(3)
 #endif
 
diff --git a/board/at91sam9263ek/at91sam9263ekdf_linux_defconfig b/board/at91sam9263ek/at91sam9263ekdf_linux_defconfig
old mode 100644
new mode 100755
index b402dc3..e9567f1
--- a/board/at91sam9263ek/at91sam9263ekdf_linux_defconfig
+++ b/board/at91sam9263ek/at91sam9263ekdf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:49:12 2012
+# Thu Jun 28 15:51:32 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9263ek"
@@ -43,8 +43,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -109,11 +107,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00042000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -123,4 +120,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9263ek/at91sam9263ekdf_linux_dt_defconfig b/board/at91sam9263ek/at91sam9263ekdf_linux_dt_defconfig
deleted file mode 100644
index 9d39baa..0000000
--- a/board/at91sam9263ek/at91sam9263ekdf_linux_dt_defconfig
+++ /dev/null
@@ -1,129 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:49:58 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9263ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-CONFIG_AT91SAM9263EK=y
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9263"
-CONFIG_BOARD="at91sam9263ek"
-CONFIG_MACH_TYPE="0x4B2"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x314000"
-# CONFIG_CRYSTAL_12_000MHZ is not set
-# CONFIG_CRYSTAL_16_000MHZ is not set
-CONFIG_CRYSTAL_16_36766MHZ=y
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_16_36766MHZ=y
-ALLOW_CRYSTAL_18_432MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_16_36766MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-CONFIG_CPU_CLK_200MHZ=y
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-# CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_200MHZ=y
-ALLOW_CPU_CLK_240MHZ=y
-DISABLE_CPU_CLK_240MHZ=y
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-CONFIG_BUS_SPEED_100MHZ=y
-# CONFIG_BUS_SPEED_133MHZ is not set
-# ALLOW_PIO3 is not set
-# CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-CONFIG_SDRAM=y
-# CONFIG_SDDRC is not set
-# CONFIG_DDR2 is not set
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-# ALLOW_HSMCI is not set
-ALLOW_PSRAM=y
-ALLOW_SDRAM_16BIT=y
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_SDRAM_16BIT is not set
-CONFIG_PSRAM=y
-CONFIG_DATAFLASH=y
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="dataflash"
-# CONFIG_SDCARD_HS is not set
-
-#
-# SPI configuration
-#
-CONFIG_SPI_CLK=33000000
-CONFIG_SMALL_DATAFLASH=y
-CONFIG_DATAFLASH_RECOVERY=y
-ALLOW_DATAFLASH_RECOVERY=y
-CONFIG_SPI_BOOT_CS0=y
-# CONFIG_SPI_BOOT_CS1 is not set
-# CONFIG_SPI_BOOT_CS2 is not set
-# CONFIG_SPI_BOOT_CS3 is not set
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-# ALLOW_BOOT_FROM_DATAFLASH_CS1 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS2 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS3 is not set
-DATAFLASHCARD_ON_CS0=y
-# DATAFLASHCARD_ON_CS1 is not set
-# DATAFLASHCARD_ON_CS2 is not set
-# DATAFLASHCARD_ON_CS3 is not set
-CONFIG_DATAFLASHCARD=y
-CONFIG_CARD_SUFFIX="card"
-CONFIG_SPI_BOOT="AT91C_SPI_PCS0_DATAFLASH"
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="dataflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
-CONFIG_IMG_ADDRESS="0x00042000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00008400"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9263ek/at91sam9263ekdf_uboot_defconfig b/board/at91sam9263ek/at91sam9263ekdf_uboot_defconfig
old mode 100644
new mode 100755
index cd0f67a..c923f3d
--- a/board/at91sam9263ek/at91sam9263ekdf_uboot_defconfig
+++ b/board/at91sam9263ek/at91sam9263ekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:10:11 2012
+# Wed Jun 27 14:25:44 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9263ek"
@@ -33,7 +33,6 @@ CONFIG_CPU_CLK_200MHZ=y
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 ALLOW_CPU_CLK_240MHZ=y
 DISABLE_CPU_CLK_240MHZ=y
@@ -43,7 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -103,8 +101,8 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_SIZE="0x00050000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -118,4 +116,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9263ek/at91sam9263eknf_linux_defconfig b/board/at91sam9263ek/at91sam9263eknf_linux_defconfig
old mode 100644
new mode 100755
index 0146cb4..91036c4
--- a/board/at91sam9263ek/at91sam9263eknf_linux_defconfig
+++ b/board/at91sam9263ek/at91sam9263eknf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:47:23 2012
+# Thu Jun 28 15:48:18 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9263ek"
@@ -43,8 +43,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -96,11 +94,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00200000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -110,4 +107,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9263ek/at91sam9263eknf_linux_dt_defconfig b/board/at91sam9263ek/at91sam9263eknf_linux_dt_defconfig
deleted file mode 100644
index 0b64a85..0000000
--- a/board/at91sam9263ek/at91sam9263eknf_linux_dt_defconfig
+++ /dev/null
@@ -1,116 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:48:11 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9263ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-CONFIG_AT91SAM9263EK=y
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9263"
-CONFIG_BOARD="at91sam9263ek"
-CONFIG_MACH_TYPE="0x4B2"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x314000"
-# CONFIG_CRYSTAL_12_000MHZ is not set
-# CONFIG_CRYSTAL_16_000MHZ is not set
-CONFIG_CRYSTAL_16_36766MHZ=y
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_16_36766MHZ=y
-ALLOW_CRYSTAL_18_432MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_16_36766MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-CONFIG_CPU_CLK_200MHZ=y
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-# CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_200MHZ=y
-ALLOW_CPU_CLK_240MHZ=y
-DISABLE_CPU_CLK_240MHZ=y
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-CONFIG_BUS_SPEED_100MHZ=y
-# CONFIG_BUS_SPEED_133MHZ is not set
-# ALLOW_PIO3 is not set
-# CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-CONFIG_SDRAM=y
-# CONFIG_SDDRC is not set
-# CONFIG_DDR2 is not set
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-# ALLOW_HSMCI is not set
-ALLOW_PSRAM=y
-ALLOW_SDRAM_16BIT=y
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_SDRAM_16BIT is not set
-CONFIG_PSRAM=y
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-CONFIG_NANDFLASH=y
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="nandflash"
-# CONFIG_SDCARD_HS is not set
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-DATAFLASHCARD_ON_CS0=y
-
-#
-# NAND Flash configuration
-#
-CONFIG_ENABLE_SW_ECC=y
-# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
-CONFIG_NANDFLASH_RECOVERY=y
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="nandflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
-CONFIG_IMG_ADDRESS="0x00200000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00180000"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9263ek/at91sam9263eknf_uboot_defconfig b/board/at91sam9263ek/at91sam9263eknf_uboot_defconfig
old mode 100644
new mode 100755
index 35bbe4a..90f052d
--- a/board/at91sam9263ek/at91sam9263eknf_uboot_defconfig
+++ b/board/at91sam9263ek/at91sam9263eknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:08:20 2012
+# Wed Jun 27 14:24:48 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9263ek"
@@ -33,7 +33,6 @@ CONFIG_CPU_CLK_200MHZ=y
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 ALLOW_CPU_CLK_240MHZ=y
 DISABLE_CPU_CLK_240MHZ=y
@@ -43,7 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -89,9 +87,9 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_1MB is not set
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
-CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00050000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -105,4 +103,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9263ek/at91sam9263eksd_linux_defconfig b/board/at91sam9263ek/at91sam9263eksd_linux_defconfig
old mode 100644
new mode 100755
index e1507cb..ffc0810
--- a/board/at91sam9263ek/at91sam9263eksd_linux_defconfig
+++ b/board/at91sam9263ek/at91sam9263eksd_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:02:39 2012
+# Thu Jun 28 15:52:34 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9263ek"
@@ -43,7 +43,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -91,7 +90,6 @@ CONFIG_OS_MEM_SIZE="0x4000000"
 CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
 CONFIG_OS_IMAGE_NAME="image.bin"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -101,4 +99,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9263ek/at91sam9263eksd_linux_dt_defconfig b/board/at91sam9263ek/at91sam9263eksd_linux_dt_defconfig
deleted file mode 100644
index ca4e36e..0000000
--- a/board/at91sam9263ek/at91sam9263eksd_linux_dt_defconfig
+++ /dev/null
@@ -1,106 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Fri Dec 21 09:01:58 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9263ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-CONFIG_AT91SAM9263EK=y
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9263"
-CONFIG_BOARD="at91sam9263ek"
-CONFIG_MACH_TYPE="0x4B2"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x314000"
-# CONFIG_CRYSTAL_12_000MHZ is not set
-# CONFIG_CRYSTAL_16_000MHZ is not set
-CONFIG_CRYSTAL_16_36766MHZ=y
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_16_36766MHZ=y
-ALLOW_CRYSTAL_18_432MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_16_36766MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-CONFIG_CPU_CLK_200MHZ=y
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-# CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_200MHZ=y
-ALLOW_CPU_CLK_240MHZ=y
-DISABLE_CPU_CLK_240MHZ=y
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-CONFIG_BUS_SPEED_100MHZ=y
-# CONFIG_BUS_SPEED_133MHZ is not set
-# ALLOW_PIO3 is not set
-# CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-
-#
-# Memory selection
-#
-CONFIG_SDRAM=y
-# CONFIG_SDDRC is not set
-# CONFIG_DDR2 is not set
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-# ALLOW_HSMCI is not set
-ALLOW_PSRAM=y
-ALLOW_SDRAM_16BIT=y
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_SDRAM_16BIT is not set
-CONFIG_PSRAM=y
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-CONFIG_SDCARD=y
-CONFIG_MEMORY="sdcard"
-# CONFIG_SDCARD_HS is not set
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-DATAFLASHCARD_ON_CS0=y
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="sdcard"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
-CONFIG_OS_IMAGE_NAME="image.bin"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_FILENAME="ek.dtb"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9263ek/at91sam9263eksd_uboot_defconfig b/board/at91sam9263ek/at91sam9263eksd_uboot_defconfig
old mode 100644
new mode 100755
index ffb2d48..374f7e6
--- a/board/at91sam9263ek/at91sam9263eksd_uboot_defconfig
+++ b/board/at91sam9263ek/at91sam9263eksd_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:09:22 2012
+# Wed Jun 27 14:26:19 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9263ek"
@@ -33,7 +33,6 @@ CONFIG_CPU_CLK_200MHZ=y
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 ALLOW_CPU_CLK_240MHZ=y
 DISABLE_CPU_CLK_240MHZ=y
@@ -43,7 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -83,7 +81,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_OS_IMAGE_NAME="u-boot.bin"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -97,4 +95,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9263ek/board.mk b/board/at91sam9263ek/board.mk
old mode 100644
new mode 100755
diff --git a/board/at91sam9g10ek/at91sam9g10ek.c b/board/at91sam9g10ek/at91sam9g10ek.c
old mode 100644
new mode 100755
index f428218..b82435c
--- a/board/at91sam9g10ek/at91sam9g10ek.c
+++ b/board/at91sam9g10ek/at91sam9g10ek.c
@@ -29,6 +29,7 @@
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
 #include "arch/at91sam9g10_matrix.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -40,8 +41,6 @@
 #include "dbgu.h"
 #include "debug.h"
 #include "sdramc.h"
-#include "timer.h"
-#include "watchdog.h"
 #include "at91sam9g10ek.h"
 
 #ifdef CONFIG_USER_HW_INIT
@@ -78,6 +77,8 @@ static void at91_matrix_hw_init(void)
 	matrix_writel(reg, MATRIX_SCFG3);
 }
 
+#ifdef CONFIG_DEBUG
+
 static void initialize_dbgu(void)
 {
 	/* const struct pio_desc dbgu_pins[] = {
@@ -93,6 +94,7 @@ static void initialize_dbgu(void)
 
 	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_SDRAM
 static void sdramc_init(void)
@@ -155,7 +157,7 @@ static void recovery_buttons_hw_init(void)
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/*
 	 * At this stage the main oscillator is supposed to be enabled
@@ -180,11 +182,10 @@ void hw_init(void)
 	/* Initialize matrix */
 	at91_matrix_hw_init();
 
-	/* Init timer */
-	timer_init();
-
+#ifdef CONFIG_DEBUG
 	/* Initialize dbgu */
 	initialize_dbgu();
+#endif
 
 #ifdef CONFIG_SDRAM
 	/* Initlialize sdram controller */
diff --git a/board/at91sam9g10ek/at91sam9g10ek.h b/board/at91sam9g10ek/at91sam9g10ek.h
old mode 100644
new mode 100755
index 340ba47..e698eb6
--- a/board/at91sam9g10ek/at91sam9g10ek.h
+++ b/board/at91sam9g10ek/at91sam9g10ek.h
@@ -85,8 +85,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(3)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS3_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(6)
 #endif
 
diff --git a/board/at91sam9g10ek/at91sam9g10ekdf_linux_defconfig b/board/at91sam9g10ek/at91sam9g10ekdf_linux_defconfig
old mode 100644
new mode 100755
index 74706ad..8a02f2a
--- a/board/at91sam9g10ek/at91sam9g10ekdf_linux_defconfig
+++ b/board/at91sam9g10ek/at91sam9g10ekdf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:54:33 2012
+# Thu Jun 28 15:30:43 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g10ek"
@@ -42,8 +42,6 @@ ALLOW_CPU_CLK_266MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -106,11 +104,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00042000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -120,4 +117,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g10ek/at91sam9g10ekdf_uboot_defconfig b/board/at91sam9g10ek/at91sam9g10ekdf_uboot_defconfig
old mode 100644
new mode 100755
index 5d2aa8f..1a51e0c
--- a/board/at91sam9g10ek/at91sam9g10ekdf_uboot_defconfig
+++ b/board/at91sam9g10ek/at91sam9g10ekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:33:45 2012
+# Wed Jun 27 14:14:45 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g10ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 CONFIG_CPU_CLK_266MHZ=y
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 ALLOW_CPU_CLK_266MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
@@ -42,7 +41,6 @@ ALLOW_CPU_CLK_266MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -100,8 +98,8 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_SIZE="0x00040000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -115,4 +113,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g10ek/at91sam9g10eknf_linux_defconfig b/board/at91sam9g10ek/at91sam9g10eknf_linux_defconfig
old mode 100644
new mode 100755
index 3f1d6d2..819c49e
--- a/board/at91sam9g10ek/at91sam9g10eknf_linux_defconfig
+++ b/board/at91sam9g10ek/at91sam9g10eknf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:45:36 2012
+# Thu Jun 28 15:25:20 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g10ek"
@@ -42,8 +42,6 @@ ALLOW_CPU_CLK_266MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -93,11 +91,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00200000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -107,4 +104,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g10ek/at91sam9g10eknf_uboot_defconfig b/board/at91sam9g10ek/at91sam9g10eknf_uboot_defconfig
old mode 100644
new mode 100755
index 2984a19..611f674
--- a/board/at91sam9g10ek/at91sam9g10eknf_uboot_defconfig
+++ b/board/at91sam9g10ek/at91sam9g10eknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:33:19 2012
+# Wed Jun 27 14:14:21 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g10ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 CONFIG_CPU_CLK_266MHZ=y
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 ALLOW_CPU_CLK_266MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
@@ -42,7 +41,6 @@ ALLOW_CPU_CLK_266MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -86,9 +84,9 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_1MB is not set
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
-CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00040000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -102,4 +100,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g10ek/at91sam9g10eksd_linux_defconfig b/board/at91sam9g10ek/at91sam9g10eksd_linux_defconfig
old mode 100644
new mode 100755
index 11d0e60..c876671
--- a/board/at91sam9g10ek/at91sam9g10eksd_linux_defconfig
+++ b/board/at91sam9g10ek/at91sam9g10eksd_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:32:19 2012
+# Thu Jun 28 18:49:07 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g10ek"
@@ -42,7 +42,6 @@ ALLOW_CPU_CLK_266MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -88,11 +87,9 @@ CONFIG_OS_MEM_SIZE="0x4000000"
 CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
 CONFIG_OS_IMAGE_NAME="image.bin"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 # CONFIG_DEBUG is not set
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g10ek/at91sam9g10eksd_uboot_defconfig b/board/at91sam9g10ek/at91sam9g10eksd_uboot_defconfig
old mode 100644
new mode 100755
index 7115b56..5550373
--- a/board/at91sam9g10ek/at91sam9g10eksd_uboot_defconfig
+++ b/board/at91sam9g10ek/at91sam9g10eksd_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:32:46 2012
+# Thu Jun 28 18:51:07 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g10ek"
@@ -42,7 +42,6 @@ ALLOW_CPU_CLK_266MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -80,7 +79,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_OS_IMAGE_NAME="u-boot.bin"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -88,7 +87,9 @@ CONFIG_JUMP_ADDR="0x21F00000"
 CONFIG_IMAGE_NAME="uboot"
 # CONFIG_LONG_TEST is not set
 # CONFIG_DEBUG is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g10ek/board.mk b/board/at91sam9g10ek/board.mk
old mode 100644
new mode 100755
diff --git a/board/at91sam9g20ek/at91sam9g20ek.c b/board/at91sam9g20ek/at91sam9g20ek.c
old mode 100644
new mode 100755
index fc2401d..21f2c06
--- a/board/at91sam9g20ek/at91sam9g20ek.c
+++ b/board/at91sam9g20ek/at91sam9g20ek.c
@@ -29,6 +29,7 @@
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
 #include "arch/at91_matrix.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -40,14 +41,13 @@
 #include "dbgu.h"
 #include "debug.h"
 #include "sdramc.h"
-#include "timer.h"
-#include "watchdog.h"
 #include "at91sam9g20ek.h"
 
 #ifdef CONFIG_USER_HW_INIT
 extern void hw_init_hook(void);
 #endif
 
+#ifdef CONFIG_DEBUG
 static void at91_dbgu_hw_init(void)
 {
 	/* Configure DBGU pin */
@@ -69,6 +69,7 @@ static void initialize_dbgu(void)
 
 	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_SDRAM
 static void sdramc_hw_init(void)
@@ -116,8 +117,7 @@ static void sdramc_init(void)
 
 	/* Initialize the matrix (memory voltage = 3.3) */
 	writel((readl(AT91C_BASE_CCFG + CCFG_EBICSA))
-		| AT91C_EBI_CS1A_SDRAMC | AT91C_VDDIOM_SEL_33V
-		| (0x01 << 17), /*  set I/O slew selection */
+		| AT91C_EBI_CS1A_SDRAMC | AT91C_VDDIOM_SEL_33V,
 		AT91C_BASE_CCFG + CCFG_EBICSA);
 
 	sdramc_initialize(&sdramc_config, AT91C_BASE_CS1);
@@ -142,7 +142,7 @@ static void recovery_buttons_hw_init(void)
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/*
 	 * At this stage the main oscillator is supposed to be enabled
@@ -169,11 +169,10 @@ void hw_init(void)
 	writel((readl((AT91C_BASE_MATRIX + MATRIX_SCFG3)) & ~0xFF) | 0x40,
 		(AT91C_BASE_MATRIX + MATRIX_SCFG3));
 
-	/* Init timer */
-	timer_init();
-
+#ifdef CONFIG_DEBUG
 	/* Initialize dbgu */
 	initialize_dbgu();
+#endif
 
 #ifdef CONFIG_SDRAM
 	/* Initlialize sdram controller */
diff --git a/board/at91sam9g20ek/at91sam9g20ek.h b/board/at91sam9g20ek/at91sam9g20ek.h
old mode 100644
new mode 100755
index bb37694..b633808
--- a/board/at91sam9g20ek/at91sam9g20ek.h
+++ b/board/at91sam9g20ek/at91sam9g20ek.h
@@ -59,8 +59,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(3)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PC(11)
 #endif
 
diff --git a/board/at91sam9g20ek/at91sam9g20ekdf_linux_defconfig b/board/at91sam9g20ek/at91sam9g20ekdf_linux_defconfig
old mode 100644
new mode 100755
index b532ff8..95dfd70
--- a/board/at91sam9g20ek/at91sam9g20ekdf_linux_defconfig
+++ b/board/at91sam9g20ek/at91sam9g20ekdf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:40:49 2012
+# Thu Jun 28 18:13:53 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g20ek"
@@ -41,8 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -105,11 +103,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00042000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -119,4 +116,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g20ek/at91sam9g20ekdf_linux_dt_defconfig b/board/at91sam9g20ek/at91sam9g20ekdf_linux_dt_defconfig
deleted file mode 100644
index 3820b22..0000000
--- a/board/at91sam9g20ek/at91sam9g20ekdf_linux_dt_defconfig
+++ /dev/null
@@ -1,125 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Tue Jan  8 09:10:10 2013
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9g20ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-CONFIG_AT91SAM9G20EK=y
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9G20"
-CONFIG_BOARD="at91sam9g20ek"
-CONFIG_MACH_TYPE="0x658"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x304000"
-# CONFIG_CRYSTAL_12_000MHZ is not set
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-CONFIG_CRYSTAL_18_432MHZ=y
-ALLOW_CRYSTAL_18_432MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-# ALLOW_PIO3 is not set
-# CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-CONFIG_SDRAM=y
-# CONFIG_SDDRC is not set
-# CONFIG_DDR2 is not set
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-# ALLOW_HSMCI is not set
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-CONFIG_DATAFLASH=y
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="dataflash"
-# CONFIG_SDCARD_HS is not set
-
-#
-# SPI configuration
-#
-CONFIG_SPI_CLK=33000000
-CONFIG_SMALL_DATAFLASH=y
-CONFIG_DATAFLASH_RECOVERY=y
-ALLOW_DATAFLASH_RECOVERY=y
-# CONFIG_SPI_BOOT_CS0 is not set
-CONFIG_SPI_BOOT_CS1=y
-# CONFIG_SPI_BOOT_CS2 is not set
-# CONFIG_SPI_BOOT_CS3 is not set
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-ALLOW_BOOT_FROM_DATAFLASH_CS1=y
-# ALLOW_BOOT_FROM_DATAFLASH_CS2 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS3 is not set
-# DATAFLASHCARD_ON_CS0 is not set
-# DATAFLASHCARD_ON_CS1 is not set
-# DATAFLASHCARD_ON_CS2 is not set
-# DATAFLASHCARD_ON_CS3 is not set
-# CONFIG_DATAFLASHCARD is not set
-CONFIG_CARD_SUFFIX=""
-CONFIG_SPI_BOOT="AT91C_SPI_PCS1_DATAFLASH"
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="dataflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
-CONFIG_IMG_ADDRESS="0x00042000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00008400"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g20ek/at91sam9g20ekdf_uboot_defconfig b/board/at91sam9g20ek/at91sam9g20ekdf_uboot_defconfig
old mode 100644
new mode 100755
index 4fa1924..d913316
--- a/board/at91sam9g20ek/at91sam9g20ekdf_uboot_defconfig
+++ b/board/at91sam9g20ek/at91sam9g20ekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 16:36:02 2012
+# Wed Jun 27 14:04:05 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g20ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -41,7 +40,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -99,8 +97,8 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_SIZE="0x00050000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -114,4 +112,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g20ek/at91sam9g20eknf_linux_defconfig b/board/at91sam9g20ek/at91sam9g20eknf_linux_defconfig
old mode 100644
new mode 100755
index 9e95d1e..2389236
--- a/board/at91sam9g20ek/at91sam9g20eknf_linux_defconfig
+++ b/board/at91sam9g20ek/at91sam9g20eknf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:38:49 2012
+# Thu Jun 28 18:12:43 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g20ek"
@@ -41,8 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -92,11 +90,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00200000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -106,4 +103,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g20ek/at91sam9g20eknf_linux_dt_defconfig b/board/at91sam9g20ek/at91sam9g20eknf_linux_dt_defconfig
deleted file mode 100644
index 4e7f64d..0000000
--- a/board/at91sam9g20ek/at91sam9g20eknf_linux_dt_defconfig
+++ /dev/null
@@ -1,112 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:39:47 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9g20ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-CONFIG_AT91SAM9G20EK=y
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9G20"
-CONFIG_BOARD="at91sam9g20ek"
-CONFIG_MACH_TYPE="0x658"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x304000"
-# CONFIG_CRYSTAL_12_000MHZ is not set
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-CONFIG_CRYSTAL_18_432MHZ=y
-ALLOW_CRYSTAL_18_432MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-# ALLOW_PIO3 is not set
-# CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-CONFIG_SDRAM=y
-# CONFIG_SDDRC is not set
-# CONFIG_DDR2 is not set
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-# ALLOW_HSMCI is not set
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-CONFIG_NANDFLASH=y
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="nandflash"
-# CONFIG_SDCARD_HS is not set
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-ALLOW_BOOT_FROM_DATAFLASH_CS1=y
-
-#
-# NAND Flash configuration
-#
-CONFIG_ENABLE_SW_ECC=y
-# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
-CONFIG_NANDFLASH_RECOVERY=y
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="nandflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
-CONFIG_IMG_ADDRESS="0x00200000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00180000"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g20ek/at91sam9g20eknf_uboot_defconfig b/board/at91sam9g20ek/at91sam9g20eknf_uboot_defconfig
old mode 100644
new mode 100755
index 715e475..5259b0c
--- a/board/at91sam9g20ek/at91sam9g20eknf_uboot_defconfig
+++ b/board/at91sam9g20ek/at91sam9g20eknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 16:31:40 2012
+# Wed Jun 27 14:03:23 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g20ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -41,7 +40,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -85,9 +83,9 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_1MB is not set
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
-CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00050000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -101,4 +99,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g20ek/at91sam9g20eksd_linux_defconfig b/board/at91sam9g20ek/at91sam9g20eksd_linux_defconfig
old mode 100644
new mode 100755
index 2a2526a..6aad5c4
--- a/board/at91sam9g20ek/at91sam9g20eksd_linux_defconfig
+++ b/board/at91sam9g20ek/at91sam9g20eksd_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 16:30:41 2012
+# Thu Jun 28 18:15:15 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g20ek"
@@ -41,7 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -87,7 +86,6 @@ CONFIG_OS_MEM_SIZE="0x4000000"
 CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
 CONFIG_OS_IMAGE_NAME="image.bin"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -97,4 +95,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g20ek/at91sam9g20eksd_linux_dt_defconfig b/board/at91sam9g20ek/at91sam9g20eksd_linux_dt_defconfig
deleted file mode 100644
index d517e84..0000000
--- a/board/at91sam9g20ek/at91sam9g20eksd_linux_dt_defconfig
+++ /dev/null
@@ -1,102 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 20 16:28:23 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9g20ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-CONFIG_AT91SAM9G20EK=y
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9G20"
-CONFIG_BOARD="at91sam9g20ek"
-CONFIG_MACH_TYPE="0x658"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x304000"
-# CONFIG_CRYSTAL_12_000MHZ is not set
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-CONFIG_CRYSTAL_18_432MHZ=y
-ALLOW_CRYSTAL_18_432MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-# ALLOW_PIO3 is not set
-# CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-
-#
-# Memory selection
-#
-CONFIG_SDRAM=y
-# CONFIG_SDDRC is not set
-# CONFIG_DDR2 is not set
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-# ALLOW_HSMCI is not set
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-CONFIG_SDCARD=y
-CONFIG_MEMORY="sdcard"
-# CONFIG_SDCARD_HS is not set
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-ALLOW_BOOT_FROM_DATAFLASH_CS1=y
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="sdcard"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
-CONFIG_OS_IMAGE_NAME="image.bin"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_FILENAME="ek.dtb"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g20ek/at91sam9g20eksd_uboot_defconfig b/board/at91sam9g20ek/at91sam9g20eksd_uboot_defconfig
old mode 100644
new mode 100755
index 1100e60..6e3dae4
--- a/board/at91sam9g20ek/at91sam9g20eksd_uboot_defconfig
+++ b/board/at91sam9g20ek/at91sam9g20eksd_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 16:28:57 2012
+# Thu Jun 28 15:17:19 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9g20ek"
@@ -41,7 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -79,7 +78,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_OS_IMAGE_NAME="u-boot.bin"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -93,4 +92,3 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9g20ek/board.mk b/board/at91sam9g20ek/board.mk
old mode 100644
new mode 100755
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45ek.c b/board/at91sam9m10g45ek/at91sam9m10g45ek.c
old mode 100644
new mode 100755
index 6fad25d..cb9df3f
--- a/board/at91sam9m10g45ek/at91sam9m10g45ek.c
+++ b/board/at91sam9m10g45ek/at91sam9m10g45ek.c
@@ -28,6 +28,7 @@
 #include "common.h"
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -39,14 +40,13 @@
 #include "debug.h"
 #include "ddramc.h"
 #include "slowclk.h"
-#include "timer.h"
-#include "watchdog.h"
 #include "at91sam9m10g45ek.h"
 
 #ifdef CONFIG_USER_HW_INIT
 extern void hw_init_hook(void);
 #endif
 
+#ifdef CONFIG_DEBUG
 static void at91_dbgu_hw_init(void)
 {
 	/* Configure DBGU pin */
@@ -66,6 +66,7 @@ static void initialize_dbgu(void)
 	at91_dbgu_hw_init();
 	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_DDR2
 static void ddramc_reg_config(struct ddramc_register *ddramc_config)
@@ -119,6 +120,16 @@ static void ddramc_init(void)
 
 	/* DDRAM2 Controller initialize */
 	ddram_initialize(AT91C_BASE_DDRSDRC, AT91C_DDRAM_BASE_ADDR, &ddramc_reg);
+	/*
+	* EBI IO in 1.8V mode 
+	*/
+	writel(readl(AT91C_BASE_CCFG + CCFG_EBICSA) & ~(1 << 16),
+		AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/*
+	* EBI DDRAM controller 
+	*/
+	ddram_initialize(AT91C_BASE_DDRSDRC1, AT91C_BASE_CS1, &ddramc_reg);	
 }
 #endif /* #ifdef CONFIG_DDR2 */
 
@@ -136,8 +147,26 @@ static void recovery_buttons_hw_init(void)
 }
 #endif /* #if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY) */
 
+static unsigned int at91_sys_read(unsigned int reg_offset)
+{
+	void *addr = (void *)reg_offset;
+
+	return readl(addr);
+}
+
+static void at91_sys_write(unsigned int reg_offset, unsigned long value)
+{
+	void *addr = (void *)reg_offset;
+
+	writel(value, addr);
+}
+
+
 static int ek_special_hw_init(void)
 {
+	unsigned long rstc;
+	unsigned long rst_key = (0xA5 << 24);
+
 	/*
 	 * For on the sam9m10g45ek board, the chip wm9711 stay in the test mode,
 	 * so it need do some action to exit mode.
@@ -160,6 +189,23 @@ static int ek_special_hw_init(void)
 	 * PHY has internal pull-down
 	 */
 	 writel((0x01 << 12) | (0x01 << 13) | (0x01 << 15),  AT91C_BASE_PIOA + PIO_PPUDR(0));
+    
+	rstc = at91_sys_read(AT91C_BASE_RSTC + RSTC_RMR);
+
+	/* Need to reset PHY -> 500ms reset */
+	at91_sys_write(AT91C_BASE_RSTC + RSTC_RMR, rst_key |
+				     (AT91C_RSTC_ERSTL & (0x0D << 8)) |
+				     AT91C_RSTC_URSTEN);
+
+	at91_sys_write(AT91C_BASE_RSTC + RSTC_RCR, rst_key | AT91C_RSTC_EXTRST);
+
+	/* Wait for end hardware reset */
+	while (!(at91_sys_read(AT91C_BASE_RSTC + RSTC_RSR) & AT91C_RSTC_NRSTL));
+
+	/* Restore NRST value */
+	at91_sys_write(AT91C_BASE_RSTC + RSTC_RMR, rst_key |
+				     (rstc) |
+				     AT91C_RSTC_URSTEN);    
 
 	 return 0;
 }
@@ -168,7 +214,7 @@ static int ek_special_hw_init(void)
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDTC + WDTC_MR);
 
 	/* At this stage the main oscillator
 	 * is supposed to be enabled PCK = MCK = MOSC */
@@ -186,15 +232,14 @@ void hw_init(void)
 	/* Enable External Reset */
 	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
 
-	/* Init timer */
-	timer_init();
-
 #ifdef CONFIG_SCLK
 	slowclk_enable_osc32();
 #endif
 
+#ifdef CONFIG_DEBUG
 	/* Initialize dbgu */
 	initialize_dbgu();
+#endif
 
 #ifdef CONFIG_DDR2
 	/* Initialize DDRAM Controller */
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45ek.h b/board/at91sam9m10g45ek/at91sam9m10g45ek.h
old mode 100644
new mode 100755
index 1b197ca..b517210
--- a/board/at91sam9m10g45ek/at91sam9m10g45ek.h
+++ b/board/at91sam9m10g45ek/at91sam9m10g45ek.h
@@ -76,8 +76,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PB(3)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PB(18)
 #endif
 
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45ekdf_linux_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45ekdf_linux_defconfig
old mode 100644
new mode 100755
index e930754..f88a45c
--- a/board/at91sam9m10g45ek/at91sam9m10g45ekdf_linux_defconfig
+++ b/board/at91sam9m10g45ek/at91sam9m10g45ekdf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:35:59 2012
+# Fri Jun 29 11:23:05 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9m10g45ek"
@@ -41,8 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -58,8 +56,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 CONFIG_DATAFLASH=y
@@ -105,11 +103,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x70000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00042000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x72000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -120,4 +117,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45ekdf_linux_dt_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45ekdf_linux_dt_defconfig
deleted file mode 100644
index 5278bde..0000000
--- a/board/at91sam9m10g45ek/at91sam9m10g45ekdf_linux_dt_defconfig
+++ /dev/null
@@ -1,126 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:36:48 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9m10g45ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-CONFIG_AT91SAM9M10G45EK=y
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9G45"
-CONFIG_BOARD="at91sam9m10g45ek"
-CONFIG_MACH_TYPE="1830"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x30A000"
-# CONFIG_CRYSTAL_12_000MHZ is not set
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-CONFIG_CRYSTAL_18_432MHZ=y
-ALLOW_CRYSTAL_18_432MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-# ALLOW_PIO3 is not set
-# CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-CONFIG_DATAFLASH=y
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="dataflash"
-CONFIG_SDCARD_HS=y
-
-#
-# SPI configuration
-#
-CONFIG_SPI_CLK=33000000
-CONFIG_SMALL_DATAFLASH=y
-CONFIG_DATAFLASH_RECOVERY=y
-ALLOW_DATAFLASH_RECOVERY=y
-CONFIG_SPI_BOOT_CS0=y
-# CONFIG_SPI_BOOT_CS1 is not set
-# CONFIG_SPI_BOOT_CS2 is not set
-# CONFIG_SPI_BOOT_CS3 is not set
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-# ALLOW_BOOT_FROM_DATAFLASH_CS1 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS2 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS3 is not set
-# DATAFLASHCARD_ON_CS0 is not set
-# DATAFLASHCARD_ON_CS1 is not set
-# DATAFLASHCARD_ON_CS2 is not set
-# DATAFLASHCARD_ON_CS3 is not set
-# CONFIG_DATAFLASHCARD is not set
-CONFIG_CARD_SUFFIX=""
-CONFIG_SPI_BOOT="AT91C_SPI_PCS0_DATAFLASH"
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="dataflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x70000000"
-CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
-CONFIG_IMG_ADDRESS="0x00042000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x72000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00008400"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x71000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45ekdf_uboot_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45ekdf_uboot_defconfig
old mode 100644
new mode 100755
index f98a4ba..5d0c42f
--- a/board/at91sam9m10g45ek/at91sam9m10g45ekdf_uboot_defconfig
+++ b/board/at91sam9m10g45ek/at91sam9m10g45ekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 16:16:58 2012
+# Fri Jun 29 11:16:39 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9m10g45ek"
@@ -41,7 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -57,8 +56,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 CONFIG_DATAFLASH=y
@@ -99,7 +98,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
+CONFIG_IMG_SIZE="0x00050000"
 CONFIG_JUMP_ADDR="0x73F00000"
 
 #
@@ -115,4 +114,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45eknf_android_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45eknf_android_defconfig
new file mode 100755
index 0000000..c5f527c
--- /dev/null
+++ b/board/at91sam9m10g45ek/at91sam9m10g45eknf_android_defconfig
@@ -0,0 +1,105 @@
+#
+# Automatically generated make config: don't edit
+# Fri Jun 29 10:56:42 2012
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="at91sam9m10g45ek"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+CONFIG_AT91SAM9M10G45EK=y
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+CONFIG_CHIP="AT91SAM9G45"
+CONFIG_BOARD="at91sam9m10g45ek"
+CONFIG_MACH_TYPE="1830"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x30A000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+# CONFIG_SDRAM is not set
+# CONFIG_SDDRC is not set
+CONFIG_DDR2=y
+ALLOW_DATAFLASH=y
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+ALLOW_SDCARD=y
+ALLOW_HSMCI=y
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+CONFIG_SDCARD_HS=y
+ALLOW_DATAFLASH_RECOVERY=y
+ALLOW_BOOT_FROM_DATAFLASH_CS0=y
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+CONFIG_NANDFLASH_RECOVERY=y
+ALLOW_NANDFLASH_RECOVERY=y
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x70000000"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_IMG_ADDRESS="0x00200000"
+CONFIG_IMG_SIZE="0x300000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_JUMP_ADDR="0x72000000"
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
+CONFIG_SCLK=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45eknf_linux_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45eknf_linux_defconfig
old mode 100644
new mode 100755
index 84fb5d8..52d8aaf
--- a/board/at91sam9m10g45ek/at91sam9m10g45eknf_linux_defconfig
+++ b/board/at91sam9m10g45ek/at91sam9m10g45eknf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:33:36 2012
+# Fri Jun 29 10:56:42 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9m10g45ek"
@@ -41,8 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -58,8 +56,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 # CONFIG_DATAFLASH is not set
@@ -91,11 +89,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x70000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00200000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x72000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -106,4 +103,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45eknf_linux_dt_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45eknf_linux_dt_defconfig
deleted file mode 100644
index 45b02bb..0000000
--- a/board/at91sam9m10g45ek/at91sam9m10g45eknf_linux_dt_defconfig
+++ /dev/null
@@ -1,112 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:34:35 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9m10g45ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-CONFIG_AT91SAM9M10G45EK=y
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9G45"
-CONFIG_BOARD="at91sam9m10g45ek"
-CONFIG_MACH_TYPE="1830"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x30A000"
-# CONFIG_CRYSTAL_12_000MHZ is not set
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-CONFIG_CRYSTAL_18_432MHZ=y
-ALLOW_CRYSTAL_18_432MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-# ALLOW_PIO3 is not set
-# CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-CONFIG_NANDFLASH=y
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="nandflash"
-CONFIG_SDCARD_HS=y
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-
-#
-# NAND Flash configuration
-#
-CONFIG_ENABLE_SW_ECC=y
-# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
-CONFIG_NANDFLASH_RECOVERY=y
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="nandflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x70000000"
-CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
-CONFIG_IMG_ADDRESS="0x00200000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x72000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00180000"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x71000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45eknf_uboot_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45eknf_uboot_defconfig
old mode 100644
new mode 100755
index f6501df..92acd07
--- a/board/at91sam9m10g45ek/at91sam9m10g45eknf_uboot_defconfig
+++ b/board/at91sam9m10g45ek/at91sam9m10g45eknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 16:14:22 2012
+# Fri Jun 29 11:13:35 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9m10g45ek"
@@ -41,7 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -57,8 +56,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 # CONFIG_DATAFLASH is not set
@@ -84,8 +83,8 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_1MB is not set
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
-CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00050000"
 CONFIG_JUMP_ADDR="0x73F00000"
 
 #
@@ -101,4 +100,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45eksd_android_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45eksd_android_defconfig
new file mode 100755
index 0000000..d147557
--- /dev/null
+++ b/board/at91sam9m10g45ek/at91sam9m10g45eksd_android_defconfig
@@ -0,0 +1,97 @@
+#
+# Automatically generated make config: don't edit
+# Fri Jun 29 11:26:56 2012
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="at91sam9m10g45ek"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+CONFIG_AT91SAM9M10G45EK=y
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+CONFIG_CHIP="AT91SAM9G45"
+CONFIG_BOARD="at91sam9m10g45ek"
+CONFIG_MACH_TYPE="1830"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x30A000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+# CONFIG_SDRAM is not set
+# CONFIG_SDDRC is not set
+CONFIG_DDR2=y
+ALLOW_DATAFLASH=y
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+ALLOW_SDCARD=y
+ALLOW_HSMCI=y
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+# CONFIG_NANDFLASH is not set
+CONFIG_SDCARD=y
+CONFIG_MEMORY="sdcard"
+CONFIG_SDCARD_HS=y
+ALLOW_DATAFLASH_RECOVERY=y
+ALLOW_BOOT_FROM_DATAFLASH_CS0=y
+ALLOW_NANDFLASH_RECOVERY=y
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="sdcard"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x70000000"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_OS_IMAGE_NAME="uImage"
+CONFIG_JUMP_ADDR="0x72000000"
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
+CONFIG_SCLK=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45eksd_linux_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45eksd_linux_defconfig
old mode 100644
new mode 100755
index 97f3a45..e59aa2a
--- a/board/at91sam9m10g45ek/at91sam9m10g45eksd_linux_defconfig
+++ b/board/at91sam9m10g45ek/at91sam9m10g45eksd_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 16:13:31 2012
+# Fri Jun 29 11:26:56 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9m10g45ek"
@@ -41,7 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -57,8 +56,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 # CONFIG_DATAFLASH is not set
@@ -86,7 +85,6 @@ CONFIG_OS_MEM_SIZE="0x4000000"
 CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
 CONFIG_OS_IMAGE_NAME="image.bin"
 CONFIG_JUMP_ADDR="0x72000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -97,4 +95,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45eksd_linux_dt_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45eksd_linux_dt_defconfig
deleted file mode 100644
index 3fd97a4..0000000
--- a/board/at91sam9m10g45ek/at91sam9m10g45eksd_linux_dt_defconfig
+++ /dev/null
@@ -1,102 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 20 16:10:26 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9m10g45ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-CONFIG_AT91SAM9M10G45EK=y
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9G45"
-CONFIG_BOARD="at91sam9m10g45ek"
-CONFIG_MACH_TYPE="1830"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x30A000"
-# CONFIG_CRYSTAL_12_000MHZ is not set
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-CONFIG_CRYSTAL_18_432MHZ=y
-ALLOW_CRYSTAL_18_432MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-# ALLOW_PIO3 is not set
-# CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-CONFIG_SDCARD=y
-CONFIG_MEMORY="sdcard"
-CONFIG_SDCARD_HS=y
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="sdcard"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x70000000"
-CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
-CONFIG_OS_IMAGE_NAME="image.bin"
-CONFIG_JUMP_ADDR="0x72000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_FILENAME="ek.dtb"
-CONFIG_OF_ADDRESS="0x71000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9m10g45ek/at91sam9m10g45eksd_uboot_defconfig b/board/at91sam9m10g45ek/at91sam9m10g45eksd_uboot_defconfig
old mode 100644
new mode 100755
index e4268c9..2142594
--- a/board/at91sam9m10g45ek/at91sam9m10g45eksd_uboot_defconfig
+++ b/board/at91sam9m10g45ek/at91sam9m10g45eksd_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 16:12:23 2012
+# Fri Jun 29 11:10:33 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9m10g45ek"
@@ -41,7 +41,6 @@ ALLOW_CPU_CLK_400MHZ=y
 CONFIG_BUS_SPEED_133MHZ=y
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -57,8 +56,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 # CONFIG_DATAFLASH is not set
@@ -93,4 +92,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9m10g45ek/board.mk b/board/at91sam9m10g45ek/board.mk
old mode 100644
new mode 100755
diff --git a/board/at91sam9n12ek/at91sam9n12ek.c b/board/at91sam9n12ek/at91sam9n12ek.c
old mode 100644
new mode 100755
index 99d7d6c..f51a095
--- a/board/at91sam9n12ek/at91sam9n12ek.c
+++ b/board/at91sam9n12ek/at91sam9n12ek.c
@@ -28,6 +28,7 @@
 #include "common.h"
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -40,14 +41,13 @@
 #include "ddramc.h"
 #include "spi.h"
 #include "slowclk.h"
-#include "timer.h"
-#include "watchdog.h"
 #include "at91sam9n12ek.h"
 
 #ifdef CONFIG_USER_HW_INIT
 extern void hw_init_hook(void);
 #endif
 
+#ifdef CONFIG_DEBUG
 static void at91_dbgu_hw_init(void)
 {
 	/* Configure DBGU pin */
@@ -68,6 +68,7 @@ static void initialize_dbgu(void)
 	at91_dbgu_hw_init();
 	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_DDR2
 /* Using the Micron MT47H64M16HR-3 */
@@ -154,7 +155,7 @@ static void recovery_buttons_hw_init(void)
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/* At this stage the main oscillator is supposed to be enabled PCK = MCK = MOSC */
 	writel(0x00, AT91C_BASE_PMC + PMC_PLLICPR);
@@ -171,15 +172,14 @@ void hw_init(void)
 	/* Enable External Reset */
 	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
 
-	/* Init timer */
-	timer_init();
-
 #ifdef CONFIG_SCLK
 	slowclk_enable_osc32();
 #endif
 
+#ifdef CONFIG_DEBUG
 	/* Initialize dbgu */
 	initialize_dbgu();
+#endif
 
 #ifdef CONFIG_DDR2
 	/* Initialize DDRAM Controller */
diff --git a/board/at91sam9n12ek/at91sam9n12ek.h b/board/at91sam9n12ek/at91sam9n12ek.h
old mode 100644
new mode 100755
index 88176ae..f5898b5
--- a/board/at91sam9n12ek/at91sam9n12ek.h
+++ b/board/at91sam9n12ek/at91sam9n12ek.h
@@ -73,8 +73,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(14)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(7)
 #endif
 
@@ -87,15 +89,6 @@
 
 #define CONFIG_SYS_NAND_ENABLE_PIN	AT91C_PIN_PD(4)
 
-#define	PMECC_ERROR_CORR_BITS		2
-#define	PMECC_SECTOR_SIZE		512
-
-#define CONFIG_LOOKUP_TABLE_ALPHA_OFFSET	0xC000
-#define CONFIG_LOOKUP_TABLE_INDEX_OFFSET	0x8000
-
-#define CONFIG_LOOKUP_TABLE_ALPHA_OFFSET_1024	0x18000
-#define CONFIG_LOOKUP_TABLE_INDEX_OFFSET_1024	0x10000
-
 /*
  * MCI Settings
  */
diff --git a/board/at91sam9n12ek/at91sam9n12ekdf_linux_defconfig b/board/at91sam9n12ek/at91sam9n12ekdf_linux_defconfig
old mode 100644
new mode 100755
index e17e12a..4c3793d
--- a/board/at91sam9n12ek/at91sam9n12ekdf_linux_defconfig
+++ b/board/at91sam9n12ek/at91sam9n12ekdf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 28 17:43:16 2012
+# Thu Jun 28 14:30:20 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9n12ek"
@@ -18,7 +18,7 @@ CONFIG_AT91SAM9N12EK=y
 CONFIG_CHIP="AT91SAM9N12"
 CONFIG_BOARD="at91sam9n12ek"
 CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
+CONFIG_LINK_ADDR="0x300000"
 CONFIG_TOP_OF_MEMORY="0x308000"
 CONFIG_CRYSTAL_12_000MHZ=y
 # CONFIG_CRYSTAL_16_000MHZ is not set
@@ -42,8 +42,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -105,12 +103,11 @@ CONFIG_LOAD_LINUX=y
 # Linux Image Storage Setup
 #
 CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00042000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -121,4 +118,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9n12ek/at91sam9n12ekdf_linux_dt_defconfig b/board/at91sam9n12ek/at91sam9n12ekdf_linux_dt_defconfig
deleted file mode 100644
index 3fb0bd3..0000000
--- a/board/at91sam9n12ek/at91sam9n12ekdf_linux_dt_defconfig
+++ /dev/null
@@ -1,127 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:21:56 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9n12ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-CONFIG_AT91SAM9N12EK=y
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9N12"
-CONFIG_BOARD="at91sam9n12ek"
-CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x308000"
-CONFIG_CRYSTAL_12_000MHZ=y
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_12_000MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-ALLOW_PIO3=y
-CONFIG_HAS_PIO3=y
-CPU_HAS_PMECC=y
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-CONFIG_RAM_64MB=y
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-CONFIG_DATAFLASH=y
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="dataflash"
-CONFIG_SDCARD_HS=y
-
-#
-# SPI configuration
-#
-CONFIG_SPI_CLK=33000000
-CONFIG_SMALL_DATAFLASH=y
-CONFIG_DATAFLASH_RECOVERY=y
-ALLOW_DATAFLASH_RECOVERY=y
-CONFIG_SPI_BOOT_CS0=y
-# CONFIG_SPI_BOOT_CS1 is not set
-# CONFIG_SPI_BOOT_CS2 is not set
-# CONFIG_SPI_BOOT_CS3 is not set
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-# ALLOW_BOOT_FROM_DATAFLASH_CS1 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS2 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS3 is not set
-# DATAFLASHCARD_ON_CS0 is not set
-# DATAFLASHCARD_ON_CS1 is not set
-# DATAFLASHCARD_ON_CS2 is not set
-# DATAFLASHCARD_ON_CS3 is not set
-# CONFIG_DATAFLASHCARD is not set
-CONFIG_CARD_SUFFIX=""
-CONFIG_SPI_BOOT="AT91C_SPI_PCS0_DATAFLASH"
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="dataflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
-CONFIG_IMG_ADDRESS="0x00042000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00008400"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9n12ek/at91sam9n12ekdf_uboot_defconfig b/board/at91sam9n12ek/at91sam9n12ekdf_uboot_defconfig
old mode 100644
new mode 100755
index 9439b5c..aa7aafb
--- a/board/at91sam9n12ek/at91sam9n12ekdf_uboot_defconfig
+++ b/board/at91sam9n12ek/at91sam9n12ekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 15:26:27 2012
+# Wed Jun 27 14:09:16 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9n12ek"
@@ -18,7 +18,7 @@ CONFIG_AT91SAM9N12EK=y
 CONFIG_CHIP="AT91SAM9N12"
 CONFIG_BOARD="at91sam9n12ek"
 CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
+CONFIG_LINK_ADDR="0x300000"
 CONFIG_TOP_OF_MEMORY="0x308000"
 CONFIG_CRYSTAL_12_000MHZ=y
 # CONFIG_CRYSTAL_16_000MHZ is not set
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -42,7 +41,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -100,7 +98,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
+CONFIG_IMG_SIZE="0x00050000"
 CONFIG_JUMP_ADDR="0x26F00000"
 
 #
@@ -116,4 +114,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9n12ek/at91sam9n12eknf_linux_defconfig b/board/at91sam9n12ek/at91sam9n12eknf_linux_defconfig
old mode 100644
new mode 100755
index b525669..5e07b1e
--- a/board/at91sam9n12ek/at91sam9n12eknf_linux_defconfig
+++ b/board/at91sam9n12ek/at91sam9n12eknf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 28 17:42:26 2012
+# Thu Jun 28 14:07:53 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9n12ek"
@@ -18,7 +18,7 @@ CONFIG_AT91SAM9N12EK=y
 CONFIG_CHIP="AT91SAM9N12"
 CONFIG_BOARD="at91sam9n12ek"
 CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
+CONFIG_LINK_ADDR="0x300000"
 CONFIG_TOP_OF_MEMORY="0x308000"
 CONFIG_CRYSTAL_12_000MHZ=y
 # CONFIG_CRYSTAL_16_000MHZ is not set
@@ -42,8 +42,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -59,8 +57,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-CONFIG_RAM_128MB=y
+CONFIG_RAM_64MB=y
+# CONFIG_RAM_128MB is not set
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 # CONFIG_DATAFLASH is not set
@@ -91,12 +89,11 @@ CONFIG_LOAD_LINUX=y
 # Linux Image Storage Setup
 #
 CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00200000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -107,4 +104,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9n12ek/at91sam9n12eknf_linux_dt_defconfig b/board/at91sam9n12ek/at91sam9n12eknf_linux_dt_defconfig
deleted file mode 100644
index a9106cc..0000000
--- a/board/at91sam9n12ek/at91sam9n12eknf_linux_dt_defconfig
+++ /dev/null
@@ -1,113 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:16:04 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9n12ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-CONFIG_AT91SAM9N12EK=y
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9N12"
-CONFIG_BOARD="at91sam9n12ek"
-CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x308000"
-CONFIG_CRYSTAL_12_000MHZ=y
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_12_000MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-ALLOW_PIO3=y
-CONFIG_HAS_PIO3=y
-CPU_HAS_PMECC=y
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-CONFIG_RAM_128MB=y
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-CONFIG_NANDFLASH=y
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="nandflash"
-CONFIG_SDCARD_HS=y
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-
-#
-# NAND Flash configuration
-#
-# CONFIG_ENABLE_SW_ECC is not set
-# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
-CONFIG_NANDFLASH_RECOVERY=y
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="nandflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
-CONFIG_IMG_ADDRESS="0x00200000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00180000"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9n12ek/at91sam9n12eknf_uboot_defconfig b/board/at91sam9n12ek/at91sam9n12eknf_uboot_defconfig
old mode 100644
new mode 100755
index a026fc4..866dabf
--- a/board/at91sam9n12ek/at91sam9n12eknf_uboot_defconfig
+++ b/board/at91sam9n12ek/at91sam9n12eknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 15:24:48 2012
+# Wed Jun 27 14:08:18 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9n12ek"
@@ -18,7 +18,7 @@ CONFIG_AT91SAM9N12EK=y
 CONFIG_CHIP="AT91SAM9N12"
 CONFIG_BOARD="at91sam9n12ek"
 CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
+CONFIG_LINK_ADDR="0x300000"
 CONFIG_TOP_OF_MEMORY="0x308000"
 CONFIG_CRYSTAL_12_000MHZ=y
 # CONFIG_CRYSTAL_16_000MHZ is not set
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -42,7 +41,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -85,8 +83,8 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_1MB is not set
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
-CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00050000"
 CONFIG_JUMP_ADDR="0x26F00000"
 
 #
@@ -102,4 +100,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9n12ek/at91sam9n12eksd_linux_defconfig b/board/at91sam9n12ek/at91sam9n12eksd_linux_defconfig
old mode 100644
new mode 100755
index c8e4cf6..923b6ab
--- a/board/at91sam9n12ek/at91sam9n12eksd_linux_defconfig
+++ b/board/at91sam9n12ek/at91sam9n12eksd_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 28 17:48:57 2012
+# Thu Jun 28 14:30:58 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9n12ek"
@@ -18,7 +18,7 @@ CONFIG_AT91SAM9N12EK=y
 CONFIG_CHIP="AT91SAM9N12"
 CONFIG_BOARD="at91sam9n12ek"
 CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
+CONFIG_LINK_ADDR="0x300000"
 CONFIG_TOP_OF_MEMORY="0x308000"
 CONFIG_CRYSTAL_12_000MHZ=y
 # CONFIG_CRYSTAL_16_000MHZ is not set
@@ -42,8 +42,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -84,11 +82,10 @@ CONFIG_LOAD_LINUX=y
 # Linux Image Storage Setup
 #
 CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
+CONFIG_OS_MEM_SIZE="0x4000000"
 CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
 CONFIG_OS_IMAGE_NAME="image.bin"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -99,4 +96,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9n12ek/at91sam9n12eksd_linux_dt_defconfig b/board/at91sam9n12ek/at91sam9n12eksd_linux_dt_defconfig
deleted file mode 100644
index fdb1389..0000000
--- a/board/at91sam9n12ek/at91sam9n12eksd_linux_dt_defconfig
+++ /dev/null
@@ -1,103 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 20 15:05:59 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9n12ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-CONFIG_AT91SAM9N12EK=y
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9N12"
-CONFIG_BOARD="at91sam9n12ek"
-CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x308000"
-CONFIG_CRYSTAL_12_000MHZ=y
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_12_000MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-ALLOW_PIO3=y
-CONFIG_HAS_PIO3=y
-CPU_HAS_PMECC=y
-# CONFIG_LOAD_ONE_WIRE is not set
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-CONFIG_RAM_128MB=y
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-CONFIG_SDCARD=y
-CONFIG_MEMORY="sdcard"
-CONFIG_SDCARD_HS=y
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="sdcard"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
-CONFIG_OS_IMAGE_NAME="image.bin"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_FILENAME="ek.dtb"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9n12ek/at91sam9n12eksd_uboot_defconfig b/board/at91sam9n12ek/at91sam9n12eksd_uboot_defconfig
old mode 100644
new mode 100755
index a256b36..bcbfd52
--- a/board/at91sam9n12ek/at91sam9n12eksd_uboot_defconfig
+++ b/board/at91sam9n12ek/at91sam9n12eksd_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 15:23:17 2012
+# Wed Jun 27 14:09:35 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9n12ek"
@@ -18,7 +18,7 @@ CONFIG_AT91SAM9N12EK=y
 CONFIG_CHIP="AT91SAM9N12"
 CONFIG_BOARD="at91sam9n12ek"
 CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
+CONFIG_LINK_ADDR="0x300000"
 CONFIG_TOP_OF_MEMORY="0x308000"
 CONFIG_CRYSTAL_12_000MHZ=y
 # CONFIG_CRYSTAL_16_000MHZ is not set
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -42,7 +41,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -94,4 +92,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9n12ek/board.mk b/board/at91sam9n12ek/board.mk
old mode 100644
new mode 100755
diff --git a/board/at91sam9rlek/at91sam9rlek.c b/board/at91sam9rlek/at91sam9rlek.c
old mode 100644
new mode 100755
index fdb0a83..985ae89
--- a/board/at91sam9rlek/at91sam9rlek.c
+++ b/board/at91sam9rlek/at91sam9rlek.c
@@ -29,6 +29,7 @@
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
 #include "arch/at91_matrix.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -41,14 +42,13 @@
 #include "debug.h"
 #include "sdramc.h"
 #include "slowclk.h"
-#include "timer.h"
-#include "watchdog.h"
 #include "at91sam9rlek.h"
 
 #ifdef CONFIG_USER_HW_INIT
 extern void hw_init_hook(void);
 #endif
 
+#ifdef CONFIG_DEBUG
 static void at91_dbgu_hw_init(void)
 {
 	/* Configure DBGU pin */
@@ -70,6 +70,7 @@ static void initialize_dbgu(void)
 
 	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_SDRAM
 static void sdramc_hw_init(void)
@@ -192,7 +193,7 @@ static void recovery_buttons_hw_init(void)
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/*
 	 * At this stage the main oscillator is supposed to be enabled
@@ -210,16 +211,14 @@ void hw_init(void)
 	/* Enable External Reset */
 	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
 
-	/* Init timer */
-	timer_init();
-
 #ifdef CONFIG_SCLK
 	slowclk_enable_osc32();
 #endif
 
+#ifdef CONFIG_DEBUG
 	/* Initialize dbgu */
 	initialize_dbgu();
-
+#endif
 	/* Initialize matrix configuration */
 	at91_matrix_hw_init();
 
diff --git a/board/at91sam9rlek/at91sam9rlek.h b/board/at91sam9rlek/at91sam9rlek.h
old mode 100644
new mode 100755
index a8a186e..4321ff9
--- a/board/at91sam9rlek/at91sam9rlek.h
+++ b/board/at91sam9rlek/at91sam9rlek.h
@@ -72,6 +72,7 @@
 #define CONFIG_SYS_SPI_MODE	SPI_MODE0
 #define CONFIG_SYS_BASE_SPI	AT91C_BASE_SPI
 
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(28)
 
 /*
diff --git a/board/at91sam9rlek/at91sam9rlekdf_linux_defconfig b/board/at91sam9rlek/at91sam9rlekdf_linux_defconfig
old mode 100644
new mode 100755
index dff59cd..d82348f
--- a/board/at91sam9rlek/at91sam9rlekdf_linux_defconfig
+++ b/board/at91sam9rlek/at91sam9rlekdf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:44:09 2012
+# Thu Jun 28 15:40:44 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9rlek"
@@ -42,8 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -106,11 +104,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00042000"
 CONFIG_IMG_SIZE="0x00280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -121,4 +118,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9rlek/at91sam9rlekdf_uboot_defconfig b/board/at91sam9rlek/at91sam9rlekdf_uboot_defconfig
old mode 100644
new mode 100755
index 8f9af25..7c2b9dc
--- a/board/at91sam9rlek/at91sam9rlekdf_uboot_defconfig
+++ b/board/at91sam9rlek/at91sam9rlekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:25:53 2012
+# Wed Jun 27 14:20:13 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9rlek"
@@ -32,7 +32,6 @@ CONFIG_CPU_CLK_200MHZ=y
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 ALLOW_CPU_CLK_266MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
@@ -42,7 +41,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -100,8 +98,8 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_SIZE="0x00050000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -116,4 +114,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9rlek/at91sam9rleknf_linux_defconfig b/board/at91sam9rlek/at91sam9rleknf_linux_defconfig
old mode 100644
new mode 100755
index 10f4471..b7eb661
--- a/board/at91sam9rlek/at91sam9rleknf_linux_defconfig
+++ b/board/at91sam9rlek/at91sam9rleknf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 27 17:43:09 2012
+# Thu Jun 28 15:35:10 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9rlek"
@@ -42,8 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -92,11 +90,10 @@ CONFIG_LOAD_LINUX=y
 #
 CONFIG_OS_MEM_BANK="0x20000000"
 CONFIG_OS_MEM_SIZE="0x4000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00200000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -107,4 +104,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9rlek/at91sam9rleknf_uboot_defconfig b/board/at91sam9rlek/at91sam9rleknf_uboot_defconfig
old mode 100644
new mode 100755
index 5569f5a..c90020e
--- a/board/at91sam9rlek/at91sam9rleknf_uboot_defconfig
+++ b/board/at91sam9rlek/at91sam9rleknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:25:21 2012
+# Wed Jun 27 14:19:56 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9rlek"
@@ -32,7 +32,6 @@ CONFIG_CPU_CLK_200MHZ=y
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 ALLOW_CPU_CLK_266MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
@@ -42,7 +41,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -85,9 +83,9 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_1MB is not set
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
-CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00050000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -102,4 +100,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9rlek/at91sam9rleksd_linux_defconfig b/board/at91sam9rlek/at91sam9rleksd_linux_defconfig
old mode 100644
new mode 100755
index 0a505f3..a46cb19
--- a/board/at91sam9rlek/at91sam9rleksd_linux_defconfig
+++ b/board/at91sam9rlek/at91sam9rleksd_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:23:09 2012
+# Thu Jun 28 15:43:01 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9rlek"
@@ -42,7 +42,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -87,7 +86,6 @@ CONFIG_OS_MEM_SIZE="0x4000000"
 CONFIG_LINUX_KERNEL_ARG_STRING="mem=64M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
 CONFIG_OS_IMAGE_NAME="image.bin"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -98,4 +96,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9rlek/at91sam9rleksd_uboot_defconfig b/board/at91sam9rlek/at91sam9rleksd_uboot_defconfig
old mode 100644
new mode 100755
index 9896e23..65d961a
--- a/board/at91sam9rlek/at91sam9rleksd_uboot_defconfig
+++ b/board/at91sam9rlek/at91sam9rleksd_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:24:50 2012
+# Wed Jun 27 14:20:33 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9rlek"
@@ -32,7 +32,6 @@ CONFIG_CPU_CLK_200MHZ=y
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 # CONFIG_CPU_CLK_400MHZ is not set
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_200MHZ=y
 ALLOW_CPU_CLK_266MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
@@ -42,7 +41,6 @@ CONFIG_BUS_SPEED_100MHZ=y
 # CONFIG_BUS_SPEED_133MHZ is not set
 # ALLOW_PIO3 is not set
 # CPU_HAS_PMECC is not set
-# CONFIG_LOAD_ONE_WIRE is not set
 
 #
 # Memory selection
@@ -79,7 +77,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_OS_IMAGE_NAME="u-boot.bin"
-CONFIG_JUMP_ADDR="0x21F00000"
+CONFIG_JUMP_ADDR="0x23F00000"
 
 #
 # U-Boot Image Storage Setup
@@ -94,4 +92,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9rlek/board.mk b/board/at91sam9rlek/board.mk
old mode 100644
new mode 100755
diff --git a/board/at91sam9x5ek/at91sam9x5ek.c b/board/at91sam9x5ek/at91sam9x5ek.c
old mode 100644
new mode 100755
index 1231f74..64bd13a
--- a/board/at91sam9x5ek/at91sam9x5ek.c
+++ b/board/at91sam9x5ek/at91sam9x5ek.c
@@ -28,6 +28,7 @@
 #include "common.h"
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -39,8 +40,6 @@
 #include "debug.h"
 #include "ddramc.h"
 #include "slowclk.h"
-#include "timer.h"
-#include "watchdog.h"
 #include "at91sam9x5ek.h"
 
 #include "onewire_info.h"
@@ -49,6 +48,7 @@
 extern void hw_init_hook(void);
 #endif
 
+#ifdef CONFIG_DEBUG
 static void at91_dbgu_hw_init(void)
 {
 	/* Configure DBGU pins */
@@ -67,6 +67,7 @@ static void initialize_dbgu(void)
 	at91_dbgu_hw_init();
 	dbgu_init(BAUDRATE(MASTER_CLOCK, BAUD_RATE));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_DDR2
 /* Using the Micron MT47H64M16HR-3 */
@@ -101,8 +102,8 @@ static void ddramc_reg_config(struct ddramc_register *ddramc_config)
 			| AT91C_DDRC2_TMRD_2);          /* 2 clock cycles */
 
 	ddramc_config->t1pr = (AT91C_DDRC2_TXP_2        /*  2 clock cycles */
-			| AT91C_DDRC2_TXSRD_200         /* 200 clock cycles */
-			| AT91C_DDRC2_TXSNR_19          /* 19 * 7.5 = 142.5 ns*/
+			| 200 << 16                     /* 200 clock cycles */
+			| 19 << 8                       /* 19 * 7.5 = 142.5 ns*/
 			| AT91C_DDRC2_TRFC_18);         /* 18 * 7.5 = 135 ns */
 
 	ddramc_config->t2pr = (AT91C_DDRC2_TFAW_7       /* 7 * 7.5 = 52.5 ns */
@@ -136,22 +137,11 @@ static void ddramc_init(void)
 }
 #endif	/* #ifdef CONFIG_DDR2 */
 
-static void one_wire_hw_init(void)
-{
-	const struct pio_desc wire_pio[] = {
-		{"1-Wire", AT91C_PIN_PB(18), 1, PIO_DEFAULT, PIO_OUTPUT},
-		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
-	};
-
-	writel((1 << AT91C_ID_PIOA_B), (PMC_PCER + AT91C_BASE_PMC));
-	pio_configure(wire_pio);
-}
-
 #ifdef CONFIG_HW_INIT
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/* At this stage the main oscillator is
 	 *supposed to be enabled PCK = MCK = MOSC
@@ -170,22 +160,21 @@ void hw_init(void)
 	/*Enable External Reset */
 	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
 
-	/* Init timer */
-	timer_init();
-
 #ifdef CONFIG_SCLK
 	slowclk_enable_osc32();
 #endif
 
+#ifdef CONFIG_DEBUG
 	/* Initialize dbgu */
 	initialize_dbgu();
+#endif
 
 #ifdef CONFIG_DDR2
 	/* Initialize DDRAM Controller */
 	ddramc_init();
 #endif
-	/* one wire pin init */
-	one_wire_hw_init();
+	/* load one wire information */
+	load_1wire_info();
 
 #ifdef CONFIG_USER_HW_INIT
 	hw_init_hook();
@@ -323,3 +312,14 @@ void nandflash_config_buswidth(unsigned char busw)
 	writel(csa, AT91C_BASE_SMC + SMC_CTRL3);
 }
 #endif /* #ifdef CONFIG_NANDFLASH */
+
+void one_wire_hw_init(void)
+{
+	const struct pio_desc wire_pio[] = {
+		{"1-Wire", AT91C_PIN_PB(18), 1, PIO_DEFAULT, PIO_OUTPUT},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	writel((1 << AT91C_ID_PIOA_B), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(wire_pio);
+}
diff --git a/board/at91sam9x5ek/at91sam9x5ek.h b/board/at91sam9x5ek/at91sam9x5ek.h
old mode 100644
new mode 100755
index 5ae4f75..8c3ac88
--- a/board/at91sam9x5ek/at91sam9x5ek.h
+++ b/board/at91sam9x5ek/at91sam9x5ek.h
@@ -77,8 +77,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(14)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(7)
 #endif
 
@@ -95,25 +97,11 @@
 #define CONFIG_SYS_NAND_CLE_PIN		AT91C_PIN_PD(3)
 #define CONFIG_SYS_NAND_ENABLE_PIN      AT91C_PIN_PD(4)
 
-#define	PMECC_ERROR_CORR_BITS		2
-#define	PMECC_SECTOR_SIZE		512
-
-#define CONFIG_LOOKUP_TABLE_ALPHA_OFFSET	0xC000
-#define CONFIG_LOOKUP_TABLE_INDEX_OFFSET	0x8000
-
-#define CONFIG_LOOKUP_TABLE_ALPHA_OFFSET_1024	0x18000
-#define CONFIG_LOOKUP_TABLE_INDEX_OFFSET_1024	0x10000
-
 /*
  * MCI Settings
  */
 #define CONFIG_SYS_BASE_MCI	AT91C_BASE_HSMCI0
 
-/*
- * One wire pin
- */
-#define CONFIG_SYS_ONE_WIRE_PIN		AT91C_PIN_PB(18)
-
 /* function */
 extern void hw_init(void);
 
diff --git a/board/at91sam9x5ek/at91sam9x5ekdf_linux_defconfig b/board/at91sam9x5ek/at91sam9x5ekdf_linux_defconfig
old mode 100644
new mode 100755
index dbff2a4..b2f83ab
--- a/board/at91sam9x5ek/at91sam9x5ekdf_linux_defconfig
+++ b/board/at91sam9x5ek/at91sam9x5ekdf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 28 17:44:57 2012
+# Wed Jun 27 13:59:33 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9x5ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -42,8 +41,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -59,8 +56,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-CONFIG_RAM_128MB=y
+CONFIG_RAM_64MB=y
+# CONFIG_RAM_128MB is not set
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 CONFIG_DATAFLASH=y
@@ -105,12 +102,11 @@ CONFIG_LOAD_LINUX=y
 # Linux Image Storage Setup
 #
 CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00042000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -120,5 +116,4 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
+# CONFIG_SCLK is not set
diff --git a/board/at91sam9x5ek/at91sam9x5ekdf_linux_dt_defconfig b/board/at91sam9x5ek/at91sam9x5ekdf_linux_dt_defconfig
deleted file mode 100644
index 5c43be3..0000000
--- a/board/at91sam9x5ek/at91sam9x5ekdf_linux_dt_defconfig
+++ /dev/null
@@ -1,127 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:25:09 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9x5ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-CONFIG_AT91SAM9X5EK=y
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9X5"
-CONFIG_BOARD="at91sam9x5ek"
-CONFIG_MACH_TYPE="3373"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x308000"
-CONFIG_CRYSTAL_12_000MHZ=y
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_12_000MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-ALLOW_PIO3=y
-CONFIG_HAS_PIO3=y
-CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-CONFIG_RAM_128MB=y
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-CONFIG_DATAFLASH=y
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="dataflash"
-CONFIG_SDCARD_HS=y
-
-#
-# SPI configuration
-#
-CONFIG_SPI_CLK=33000000
-CONFIG_SMALL_DATAFLASH=y
-# CONFIG_DATAFLASH_RECOVERY is not set
-ALLOW_DATAFLASH_RECOVERY=y
-CONFIG_SPI_BOOT_CS0=y
-# CONFIG_SPI_BOOT_CS1 is not set
-# CONFIG_SPI_BOOT_CS2 is not set
-# CONFIG_SPI_BOOT_CS3 is not set
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-# ALLOW_BOOT_FROM_DATAFLASH_CS1 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS2 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS3 is not set
-# DATAFLASHCARD_ON_CS0 is not set
-# DATAFLASHCARD_ON_CS1 is not set
-# DATAFLASHCARD_ON_CS2 is not set
-# DATAFLASHCARD_ON_CS3 is not set
-# CONFIG_DATAFLASHCARD is not set
-CONFIG_CARD_SUFFIX=""
-CONFIG_SPI_BOOT="AT91C_SPI_PCS0_DATAFLASH"
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="dataflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
-CONFIG_IMG_ADDRESS="0x00042000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00008400"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9x5ek/at91sam9x5ekdf_uboot_defconfig b/board/at91sam9x5ek/at91sam9x5ekdf_uboot_defconfig
old mode 100644
new mode 100755
index f597b11..02016a9
--- a/board/at91sam9x5ek/at91sam9x5ekdf_uboot_defconfig
+++ b/board/at91sam9x5ek/at91sam9x5ekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 13:20:43 2012
+# Wed Jun 27 13:54:01 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9x5ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -42,7 +41,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
 
 #
 # Memory selection
@@ -100,7 +98,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
+CONFIG_IMG_SIZE="0x00050000"
 CONFIG_JUMP_ADDR="0x26F00000"
 
 #
@@ -116,4 +114,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9x5ek/at91sam9x5eknf_android_defconfig b/board/at91sam9x5ek/at91sam9x5eknf_android_defconfig
new file mode 100755
index 0000000..0d29890
--- /dev/null
+++ b/board/at91sam9x5ek/at91sam9x5eknf_android_defconfig
@@ -0,0 +1,105 @@
+#
+# Automatically generated make config: don't edit
+# Wed Jun 27 13:57:42 2012
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="at91sam9x5ek"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+CONFIG_AT91SAM9X5EK=y
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+CONFIG_CHIP="AT91SAM9X5"
+CONFIG_BOARD="at91sam9x5ek"
+CONFIG_MACH_TYPE="3373"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x308000"
+CONFIG_CRYSTAL_12_000MHZ=y
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+# CONFIG_CRYSTAL_18_432MHZ is not set
+ALLOW_CRYSTAL_12_000MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+ALLOW_PIO3=y
+CONFIG_HAS_PIO3=y
+CPU_HAS_PMECC=y
+
+#
+# Memory selection
+#
+# CONFIG_SDRAM is not set
+# CONFIG_SDDRC is not set
+CONFIG_DDR2=y
+ALLOW_DATAFLASH=y
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+ALLOW_SDCARD=y
+ALLOW_HSMCI=y
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+CONFIG_SDCARD_HS=y
+ALLOW_DATAFLASH_RECOVERY=y
+ALLOW_BOOT_FROM_DATAFLASH_CS0=y
+
+#
+# NAND Flash configuration
+#
+# CONFIG_ENABLE_SW_ECC is not set
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+# CONFIG_NANDFLASH_RECOVERY is not set
+ALLOW_NANDFLASH_RECOVERY=y
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x20000000"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_IMG_ADDRESS="0x00200000"
+CONFIG_IMG_SIZE="0x00300000"
+CONFIG_JUMP_ADDR="0x22000000"
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
+CONFIG_SCLK=y
diff --git a/board/at91sam9x5ek/at91sam9x5eknf_linux_defconfig b/board/at91sam9x5ek/at91sam9x5eknf_linux_defconfig
old mode 100644
new mode 100755
index 1b93b9f..1baa715
--- a/board/at91sam9x5ek/at91sam9x5eknf_linux_defconfig
+++ b/board/at91sam9x5ek/at91sam9x5eknf_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 28 17:51:30 2012
+# Wed Jun 27 13:57:42 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9x5ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -42,8 +41,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -59,8 +56,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-CONFIG_RAM_128MB=y
+CONFIG_RAM_64MB=y
+# CONFIG_RAM_128MB is not set
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 # CONFIG_DATAFLASH is not set
@@ -91,12 +88,11 @@ CONFIG_LOAD_LINUX=y
 # Linux Image Storage Setup
 #
 CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:4M(bootstrap),60M(rootfs),-(spare) root=/dev/mtdblock1 rw rootfstype=jffs2"
 CONFIG_IMG_ADDRESS="0x00200000"
 CONFIG_IMG_SIZE="0x280000"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -107,4 +103,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 # CONFIG_SCLK is not set
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9x5ek/at91sam9x5eknf_linux_dt_defconfig b/board/at91sam9x5ek/at91sam9x5eknf_linux_dt_defconfig
deleted file mode 100644
index 97474b1..0000000
--- a/board/at91sam9x5ek/at91sam9x5eknf_linux_dt_defconfig
+++ /dev/null
@@ -1,113 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 16:29:04 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9x5ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-CONFIG_AT91SAM9X5EK=y
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9X5"
-CONFIG_BOARD="at91sam9x5ek"
-CONFIG_MACH_TYPE="3373"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x308000"
-CONFIG_CRYSTAL_12_000MHZ=y
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_12_000MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-ALLOW_PIO3=y
-CONFIG_HAS_PIO3=y
-CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
-# CONFIG_MMC_SUPPORT is not set
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-CONFIG_RAM_128MB=y
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-CONFIG_NANDFLASH=y
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="nandflash"
-CONFIG_SDCARD_HS=y
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-
-#
-# NAND Flash configuration
-#
-# CONFIG_ENABLE_SW_ECC is not set
-# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
-# CONFIG_NANDFLASH_RECOVERY is not set
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="nandflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
-CONFIG_IMG_ADDRESS="0x00200000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00180000"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9x5ek/at91sam9x5eknf_uboot_defconfig b/board/at91sam9x5ek/at91sam9x5eknf_uboot_defconfig
old mode 100644
new mode 100755
index 6895bc2..009127b
--- a/board/at91sam9x5ek/at91sam9x5eknf_uboot_defconfig
+++ b/board/at91sam9x5ek/at91sam9x5eknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 13:35:25 2012
+# Wed Jun 27 13:51:21 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9x5ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -42,7 +41,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
 
 #
 # Memory selection
@@ -86,7 +84,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
+CONFIG_IMG_SIZE="0x00050000"
 CONFIG_JUMP_ADDR="0x26F00000"
 
 #
@@ -102,4 +100,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9x5ek/at91sam9x5eksd_android_defconfig b/board/at91sam9x5ek/at91sam9x5eksd_android_defconfig
new file mode 100755
index 0000000..d9e0be6
--- /dev/null
+++ b/board/at91sam9x5ek/at91sam9x5eksd_android_defconfig
@@ -0,0 +1,97 @@
+#
+# Automatically generated make config: don't edit
+# Wed Jun 27 14:00:38 2012
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="at91sam9x5ek"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+CONFIG_AT91SAM9X5EK=y
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+CONFIG_CHIP="AT91SAM9X5"
+CONFIG_BOARD="at91sam9x5ek"
+CONFIG_MACH_TYPE="3373"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x308000"
+CONFIG_CRYSTAL_12_000MHZ=y
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+# CONFIG_CRYSTAL_18_432MHZ is not set
+ALLOW_CRYSTAL_12_000MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+ALLOW_PIO3=y
+CONFIG_HAS_PIO3=y
+CPU_HAS_PMECC=y
+
+#
+# Memory selection
+#
+# CONFIG_SDRAM is not set
+# CONFIG_SDDRC is not set
+CONFIG_DDR2=y
+ALLOW_DATAFLASH=y
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+ALLOW_SDCARD=y
+ALLOW_HSMCI=y
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+# CONFIG_NANDFLASH is not set
+CONFIG_SDCARD=y
+CONFIG_MEMORY="sdcard"
+CONFIG_SDCARD_HS=y
+ALLOW_DATAFLASH_RECOVERY=y
+ALLOW_BOOT_FROM_DATAFLASH_CS0=y
+ALLOW_NANDFLASH_RECOVERY=y
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="sdcard"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x20000000"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_OS_IMAGE_NAME="uImage"
+CONFIG_JUMP_ADDR="0x22000000"
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
+CONFIG_SCLK=y
diff --git a/board/at91sam9x5ek/at91sam9x5eksd_linux_defconfig b/board/at91sam9x5ek/at91sam9x5eksd_linux_defconfig
old mode 100644
new mode 100755
index 48312e3..bf79635
--- a/board/at91sam9x5ek/at91sam9x5eksd_linux_defconfig
+++ b/board/at91sam9x5ek/at91sam9x5eksd_linux_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 28 17:48:04 2012
+# Wed Jun 27 14:00:38 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9x5ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -42,8 +41,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
-# CONFIG_MMC_SUPPORT is not set
 
 #
 # Memory selection
@@ -59,8 +56,8 @@ ALLOW_HSMCI=y
 # ALLOW_PSRAM is not set
 # ALLOW_SDRAM_16BIT is not set
 # CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-CONFIG_RAM_128MB=y
+CONFIG_RAM_64MB=y
+# CONFIG_RAM_128MB is not set
 # CONFIG_RAM_256MB is not set
 # CONFIG_RAM_512MB is not set
 # CONFIG_DATAFLASH is not set
@@ -84,11 +81,10 @@ CONFIG_LOAD_LINUX=y
 # Linux Image Storage Setup
 #
 CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
+CONFIG_OS_MEM_SIZE="0x4000000"
 CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
 CONFIG_OS_IMAGE_NAME="image.bin"
 CONFIG_JUMP_ADDR="0x22000000"
-# CONFIG_OF_LIBFDT is not set
 CONFIG_IMAGE_NAME="linux"
 # CONFIG_LONG_TEST is not set
 CONFIG_DEBUG=y
@@ -98,5 +94,4 @@ CONFIG_DEBUG_INFO=y
 CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
+# CONFIG_SCLK is not set
diff --git a/board/at91sam9x5ek/at91sam9x5eksd_linux_dt_defconfig b/board/at91sam9x5ek/at91sam9x5eksd_linux_dt_defconfig
deleted file mode 100644
index 6220f95..0000000
--- a/board/at91sam9x5ek/at91sam9x5eksd_linux_dt_defconfig
+++ /dev/null
@@ -1,103 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 20 12:42:35 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sam9x5ek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-CONFIG_AT91SAM9X5EK=y
-# CONFIG_AT91SAM9N12EK is not set
-# CONFIG_AT91SAMA5D3XEK is not set
-CONFIG_CHIP="AT91SAM9X5"
-CONFIG_BOARD="at91sam9x5ek"
-CONFIG_MACH_TYPE="3373"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x308000"
-CONFIG_CRYSTAL_12_000MHZ=y
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_12_000MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
-ALLOW_CPU_CLK_400MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-ALLOW_PIO3=y
-CONFIG_HAS_PIO3=y
-CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-CONFIG_RAM_128MB=y
-# CONFIG_RAM_256MB is not set
-# CONFIG_RAM_512MB is not set
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-CONFIG_SDCARD=y
-CONFIG_MEMORY="sdcard"
-CONFIG_SDCARD_HS=y
-ALLOW_DATAFLASH_RECOVERY=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-ALLOW_NANDFLASH_RECOVERY=y
-CONFIG_BOOTSTRAP_MAXSIZE="23000"
-CONFIG_PROJECT="sdcard"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x8000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=128M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
-CONFIG_OS_IMAGE_NAME="image.bin"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_FILENAME="ek.dtb"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9x5ek/at91sam9x5eksd_uboot_defconfig b/board/at91sam9x5ek/at91sam9x5eksd_uboot_defconfig
old mode 100644
new mode 100755
index 0b18e9a..13b409f
--- a/board/at91sam9x5ek/at91sam9x5eksd_uboot_defconfig
+++ b/board/at91sam9x5ek/at91sam9x5eksd_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Thu Dec 20 13:28:17 2012
+# Wed Jun 27 13:55:19 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sam9x5ek"
@@ -32,7 +32,6 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
 CONFIG_CPU_CLK_400MHZ=y
-# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
 # CONFIG_BUS_SPEED_83MHZ is not set
@@ -42,7 +41,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
 
 #
 # Memory selection
@@ -94,4 +92,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sam9x5ek/board.mk b/board/at91sam9x5ek/board.mk
old mode 100644
new mode 100755
diff --git a/board/at91sam9xeek/at91sam9xeek.c b/board/at91sam9xeek/at91sam9xeek.c
old mode 100644
new mode 100755
index fd0fe8b..f30ecae
--- a/board/at91sam9xeek/at91sam9xeek.c
+++ b/board/at91sam9xeek/at91sam9xeek.c
@@ -29,6 +29,7 @@
 #include "hardware.h"
 #include "arch/at91_ccfg.h"
 #include "arch/at91_matrix.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91_pmc.h"
 #include "arch/at91_smc.h"
@@ -41,7 +42,6 @@
 #include "dbgu.h"
 #include "debug.h"
 #include "sdramc.h"
-#include "watchdog.h"
 #include "at91sam9xeek.h"
 
 #ifdef CONFIG_USER_HW_INIT
@@ -135,7 +135,7 @@ static void sdramc_init(void)
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/* Adjust waitstates to access internal flash */
 	writel(AT91C_EEFC_FWS_6WS, AT91C_BASE_EEFC + EEFC_FMR);
diff --git a/board/at91sam9xeek/at91sam9xeek.h b/board/at91sam9xeek/at91sam9xeek.h
old mode 100644
new mode 100755
index 42772dd..d3ad4fd
--- a/board/at91sam9xeek/at91sam9xeek.h
+++ b/board/at91sam9xeek/at91sam9xeek.h
@@ -60,8 +60,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(3)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PC(11)
 #endif
 
diff --git a/board/at91sam9xeek/board.mk b/board/at91sam9xeek/board.mk
old mode 100644
new mode 100755
diff --git a/board/at91sama5d3xek/at91sama5d3xek.c b/board/at91sama5d3xek/at91sama5d3xek.c
old mode 100644
new mode 100755
index 517a22f..78f7618
--- a/board/at91sama5d3xek/at91sama5d3xek.c
+++ b/board/at91sama5d3xek/at91sama5d3xek.c
@@ -34,10 +34,9 @@
 #include "spi.h"
 #include "gpio.h"
 #include "slowclk.h"
-#include "timer.h"
-#include "watchdog.h"
 
 #include "arch/at91_pmc.h"
+#include "arch/at91_wdt.h"
 #include "arch/at91_rstc.h"
 #include "arch/at91sama5_smc.h"
 #include "arch/at91_pio.h"
@@ -48,6 +47,7 @@
 extern void hw_init_hook(void);
 #endif
 
+#ifdef CONFIG_DEBUG
 static void at91_dbgu_hw_init(void)
 {
 	/* Configure DBGU pin */
@@ -70,6 +70,7 @@ static void initialize_dbgu(void)
 	at91_dbgu_hw_init();
 	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
 }
+#endif /* #ifdef CONFIG_DEBUG */
 
 #ifdef CONFIG_DDR2
 static void ddramc_reg_config(struct ddramc_register *ddramc_config)
@@ -78,50 +79,36 @@ static void ddramc_reg_config(struct ddramc_register *ddramc_config)
 				| AT91C_DDRC2_MD_DDR2_SDRAM);
 
 	ddramc_config->cr = (AT91C_DDRC2_NC_DDR10_SDR9
-				| AT91C_DDRC2_NR_14
+				| AT91C_DDRC2_NR_13
 				| AT91C_DDRC2_CAS_3
-				| AT91C_DDRC2_DLL_RESET_DISABLED /* DLL not reset */
-				| AT91C_DDRC2_DIS_DLL_DISABLED   /* DLL not disabled */
-				| AT91C_DDRC2_ENRDM_ENABLE       /* Phase error correction is enabled */
 				| AT91C_DDRC2_NB_BANKS_8
-				| AT91C_DDRC2_NDQS_DISABLED      /* NDQS disabled (check on schematics) */
-				| AT91C_DDRC2_DECOD_INTERLEAVED  /* Interleaved decoding */
-				| AT91C_DDRC2_UNAL_SUPPORTED);   /* Unaligned access is supported */
-
-	/*
-	 * The DDR2-SDRAM device requires a refresh every 15.625 us or 7.81 us.
-	 * With a 133 MHz frequency, the refresh timer count register must to be
-	 * set with (15.625 x 133 MHz) ~ 2084 i.e. 0x824
-	 * or (7.81 x 133 MHz) ~ 1040 i.e. 0x410.
-	 */
-	ddramc_config->rtr = 0x411;     /* Refresh timer: 7.8125us */
+				| AT91C_DDRC2_NDQS_DISABLED
+				| AT91C_DDRC2_SUPPORTED);
+
+	ddramc_config->rtr = 0x00300208;	/* Refresh Timer register : 520 for 133 MHz */
 
 	/* One clock cycle @ 133 MHz = 7.5 ns */
-	ddramc_config->t0pr = (AT91C_DDRC2_TRAS_6       /* 6 * 7.5 = 45 ns */
-			| AT91C_DDRC2_TRCD_2            /* 2 * 7.5 = 22.5 ns */
-			| AT91C_DDRC2_TWR_2             /* 2 * 7.5 = 15   ns */
-			| AT91C_DDRC2_TRC_8             /* 8 * 7.5 = 75   ns */
-			| AT91C_DDRC2_TRP_2             /* 2 * 7.5 = 15   ns */
-			| AT91C_DDRC2_TRRD_2            /* 2 * 7.5 = 15   ns */
-			| AT91C_DDRC2_TWTR_2            /* 2 clock cycles min */
-			| AT91C_DDRC2_TMRD_2);          /* 2 clock cycles */
-
-	ddramc_config->t1pr = (AT91C_DDRC2_TXP_2        /*  2 clock cycles */
-			| AT91C_DDRC2_TXSRD_200         /* 200 clock cycles */
-			| AT91C_DDRC2_TXSNR_28          /* 195 + 10 = 205ns ==> 28 * 7.5 = 210 ns*/
-			| AT91C_DDRC2_TRFC_26);         /* 26 * 7.5 = 195 ns */
-
-	ddramc_config->t2pr = (AT91C_DDRC2_TFAW_7       /* 7 * 7.5 = 52.5 ns */
-			| AT91C_DDRC2_TRTP_2            /* 2 clock cycles min */
-			| AT91C_DDRC2_TRPA_2            /* 2 * 7.5 = 15 ns */
-			| AT91C_DDRC2_TXARDS_7          /* 7 clock cycles */
-			| AT91C_DDRC2_TXARD_8);         /* MR12 = 1 : slow exit power down */
+	ddramc_config->t0pr = (AT91C_DDRC2_TRAS_6
+				| AT91C_DDRC2_TRCD_2
+				| AT91C_DDRC2_TWR_2
+				| AT91C_DDRC2_TRC_8
+				| AT91C_DDRC2_TRP_2
+				| AT91C_DDRC2_TRRD_2
+				| AT91C_DDRC2_TWTR_2
+				| AT91C_DDRC2_TMRD_2);
+
+	ddramc_config->t1pr = 0x02C81311;
+
+	ddramc_config->t2pr = (AT91C_DDRC2_TXARD_2
+				| AT91C_DDRC2_TXARDS_7
+				| AT91C_DDRC2_TRPA_3
+				| AT91C_DDRC2_TRTP_2
+				| AT91C_DDRC2_TFAW_7);
 }
 
 static void ddramc_init(void)
 {
 	struct ddramc_register ddramc_reg;
-	unsigned int reg;
 
 	ddramc_reg_config(&ddramc_reg);
 
@@ -130,42 +117,18 @@ static void ddramc_init(void)
 	writel(AT91C_PMC_DDR, (PMC_SCER + AT91C_BASE_PMC));
 
 	/* Init the special register for sama5d3x */
-	/* MPDDRC DLL Slave Offset Register: DDR2 configuration */
-	reg = AT91C_MPDDRC_S0OFF_1
-		| AT91C_MPDDRC_S2OFF_1
-		| AT91C_MPDDRC_S3OFF_1;
-	writel(reg, (AT91C_BASE_MPDDRC + MPDDRC_DLL_SOR));
-
+	/* MPDDRC DLL Slave Offset Register */
+	writel((0x01 | (0x01 << 16) | (0x01 << 24)), (AT91C_BASE_MPDDRC + MPDDRC_DLL_SOR));
 	/* MPDDRC DLL Master Offset Register */
-	/* write master + clk90 offset */
-	reg = AT91C_MPDDRC_MOFF_7
-		| AT91C_MPDDRC_CLK90OFF_31
-		| AT91C_MPDDRC_SELOFF_ENABLED | AT91C_MPDDRC_KEY;
-	writel(reg, (AT91C_BASE_MPDDRC + MPDDRC_DLL_MOR));
-
+	writel(0xC5011f07, (AT91C_BASE_MPDDRC + MPDDRC_DLL_MOR));
 	/* MPDDRC I/O Calibration Register */
-	/* DDR2 RZQ = 50 Ohm */
-	/* TZQIO = 4 */
-	reg = AT91C_MPDDRC_RDIV_DDR2_RZQ_50
-		| AT91C_MPDDRC_TZQIO_4;
-	writel(reg, (AT91C_BASE_MPDDRC + MPDDRC_IO_CALIBR));
+	writel(0x00850404, (AT91C_BASE_MPDDRC + MPDDRC_IO_CALIBR));
 
 	/* DDRAM2 Controller initialize */
 	ddram_initialize(AT91C_BASE_MPDDRC, AT91C_BASE_DDRCS, &ddramc_reg);
 }
 #endif /* #ifdef CONFIG_DDR2 */
 
-static void one_wire_hw_init(void)
-{
-	const struct pio_desc one_wire_pio[] = {
-		{"1-Wire", AT91C_PIN_PE(25), 1, PIO_DEFAULT, PIO_OUTPUT},
-		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
-	};
-
-	writel((1 << AT91C_ID_PIOE), (PMC_PCER + AT91C_BASE_PMC));
-	pio_configure(one_wire_pio);
-}
-
 #if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY)
 static void recovery_buttons_hw_init(void)
 {
@@ -180,24 +143,11 @@ static void recovery_buttons_hw_init(void)
 }
 #endif /* #if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY) */
 
-static void HDMI_Qt1070_workaround(void)
-{
-	/* For the HDMI and QT1070 shar the irq line
-	 * if the HDMI does not initialize, the irq line is pulled down by HDMI,
-	 * so, the irq line can not used by QT1070
-	 */
-	pio_set_gpio_output(AT91C_PIN_PC(31), 1);
-	udelay(500000);
-	pio_set_gpio_output(AT91C_PIN_PC(31), 0);
-	udelay(500000);
-	pio_set_gpio_output(AT91C_PIN_PC(31), 1);
-}
-
 #ifdef CONFIG_HW_INIT
 void hw_init(void)
 {
 	/* Disable watchdog */
-	at91_disable_wdt();
+	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
 
 	/* At this stage the main oscillator is supposed to be enabled PCK = MCK = MOSC */
 	writel(0x00, AT91C_BASE_PMC + PMC_PLLICPR);
@@ -214,27 +164,23 @@ void hw_init(void)
 	/* Enable External Reset */
 	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
 
-	/* Init timer */
-	timer_init();
-
 #ifdef CONFIG_SCLK
 	slowclk_enable_osc32();
 #endif
 
+#ifdef CONFIG_DEBUG
 	/* initialize the dbgu */
 	initialize_dbgu();
+#endif
 
 #ifdef CONFIG_DDR2
 	/* Initialize MPDDR Controller */
 	ddramc_init();
 #endif
-	/* load one wire information */
-	one_wire_hw_init();
 
 #ifdef CONFIG_USER_HW_INIT
 	hw_init_hook();
 #endif
-	HDMI_Qt1070_workaround();
 
 #if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY)
 	/* Init the recovery buttons pins */
@@ -268,17 +214,13 @@ void at91_spi0_hw_init(void)
 void at91_mci0_hw_init(void)
 {
 	const struct pio_desc mci_pins[] = {
-		{"MCCK", AT91C_PIN_PD(9), 0, PIO_DEFAULT, PIO_PERIPH_A},
-		{"MCCDA", AT91C_PIN_PD(0), 0, PIO_DEFAULT, PIO_PERIPH_A},
-
-		{"MCDA0", AT91C_PIN_PD(1), 0, PIO_DEFAULT, PIO_PERIPH_A},
-		{"MCDA1", AT91C_PIN_PD(2), 0, PIO_DEFAULT, PIO_PERIPH_A},
-		{"MCDA2", AT91C_PIN_PD(3), 0, PIO_DEFAULT, PIO_PERIPH_A},
-		{"MCDA3", AT91C_PIN_PD(4), 0, PIO_DEFAULT, PIO_PERIPH_A},
-		{"MCDA4", AT91C_PIN_PD(5), 0, PIO_DEFAULT, PIO_PERIPH_A},
-		{"MCDA5", AT91C_PIN_PD(6), 0, PIO_DEFAULT, PIO_PERIPH_A},
-		{"MCDA6", AT91C_PIN_PD(7), 0, PIO_DEFAULT, PIO_PERIPH_A},
-		{"MCDA7", AT91C_PIN_PD(8), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"MCCK", AT91C_PIN_PD(9), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCCDA", AT91C_PIN_PD(0), 0, PIO_PULLUP, PIO_PERIPH_A},
+
+		{"MCDA0", AT91C_PIN_PD(1), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCDA1", AT91C_PIN_PD(2), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCDA2", AT91C_PIN_PD(3), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCDA3", AT91C_PIN_PD(4), 0, PIO_PULLUP, PIO_PERIPH_A},
 		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
 	};
 
diff --git a/board/at91sama5d3xek/at91sama5d3xek.h b/board/at91sama5d3xek/at91sama5d3xek.h
old mode 100644
new mode 100755
index 7ff87a7..6d16827
--- a/board/at91sama5d3xek/at91sama5d3xek.h
+++ b/board/at91sama5d3xek/at91sama5d3xek.h
@@ -98,8 +98,10 @@
 #endif
 
 #if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PD(13)
 #elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
 #define CONFIG_SYS_SPI_PCS	AT91C_PIN_PD(14)
 #endif
 
@@ -112,15 +114,6 @@
 
 #undef CONFIG_SYS_NAND_ENABLE_PIN
 
-#define	PMECC_ERROR_CORR_BITS		4
-#define	PMECC_SECTOR_SIZE		512
-
-#define CONFIG_LOOKUP_TABLE_ALPHA_OFFSET	0x14000
-#define CONFIG_LOOKUP_TABLE_INDEX_OFFSET	0x10000
-
-#define CONFIG_LOOKUP_TABLE_ALPHA_OFFSET_1024	0x20000
-#define CONFIG_LOOKUP_TABLE_INDEX_OFFSET_1024	0x18000
-
 /*
  * MCI Settings
  */
@@ -132,11 +125,6 @@
 #define CONFIG_SYS_RECOVERY_BUTTON_PIN	AT91C_PIN_PE(27)
 #define RECOVERY_BUTTON_NAME	"BP3/PB_USER1"
 
-/*
- * One wire pin
- */
-#define CONFIG_SYS_ONE_WIRE_PIN		AT91C_PIN_PE(25)
-
 /* function */
 extern void hw_init(void);
 
diff --git a/board/at91sama5d3xek/at91sama5d3xekdf_linux_dt_defconfig b/board/at91sama5d3xek/at91sama5d3xekdf_linux_dt_defconfig
deleted file mode 100644
index 7a2a769..0000000
--- a/board/at91sama5d3xek/at91sama5d3xekdf_linux_dt_defconfig
+++ /dev/null
@@ -1,126 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:19:12 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sama5d3xek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-CONFIG_AT91SAMA5D3XEK=y
-CONFIG_CHIP="AT91SAMA5D3X"
-CONFIG_BOARD="at91sama5d3xek"
-CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x310000"
-CONFIG_CRYSTAL_12_000MHZ=y
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_12_000MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-# CONFIG_CPU_CLK_400MHZ is not set
-CONFIG_CPU_CLK_533MHZ=y
-ALLOW_CPU_CLK_400MHZ=y
-ALLOW_CPU_CLK_533MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-ALLOW_PIO3=y
-CONFIG_HAS_PIO3=y
-CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
-CONFIG_MMC_SUPPORT=y
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-CONFIG_RAM_512MB=y
-CONFIG_DATAFLASH=y
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="dataflash"
-CONFIG_SDCARD_HS=y
-
-#
-# SPI configuration
-#
-CONFIG_SPI_CLK=33000000
-CONFIG_SMALL_DATAFLASH=y
-# ALLOW_DATAFLASH_RECOVERY is not set
-CONFIG_SPI_BOOT_CS0=y
-# CONFIG_SPI_BOOT_CS1 is not set
-# CONFIG_SPI_BOOT_CS2 is not set
-# CONFIG_SPI_BOOT_CS3 is not set
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-# ALLOW_BOOT_FROM_DATAFLASH_CS1 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS2 is not set
-# ALLOW_BOOT_FROM_DATAFLASH_CS3 is not set
-# DATAFLASHCARD_ON_CS0 is not set
-# DATAFLASHCARD_ON_CS1 is not set
-# DATAFLASHCARD_ON_CS2 is not set
-# DATAFLASHCARD_ON_CS3 is not set
-# CONFIG_DATAFLASHCARD is not set
-CONFIG_CARD_SUFFIX=""
-CONFIG_SPI_BOOT="AT91C_SPI_PCS0_DATAFLASH"
-CONFIG_BOOTSTRAP_MAXSIZE="65536"
-CONFIG_PROJECT="dataflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x20000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=512M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
-CONFIG_IMG_ADDRESS="0x00042000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00008400"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sama5d3xek/at91sama5d3xekdf_uboot_defconfig b/board/at91sama5d3xek/at91sama5d3xekdf_uboot_defconfig
old mode 100644
new mode 100755
index 96f8ea6..842de31
--- a/board/at91sama5d3xek/at91sama5d3xekdf_uboot_defconfig
+++ b/board/at91sama5d3xek/at91sama5d3xekdf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:55:07 2012
+# Thu Jun 28 12:57:27 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sama5d3xek"
@@ -18,7 +18,7 @@ CONFIG_AT91SAMA5D3XEK=y
 CONFIG_CHIP="AT91SAMA5D3X"
 CONFIG_BOARD="at91sama5d3xek"
 CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
+CONFIG_LINK_ADDR="0x300000"
 CONFIG_TOP_OF_MEMORY="0x310000"
 CONFIG_CRYSTAL_12_000MHZ=y
 # CONFIG_CRYSTAL_16_000MHZ is not set
@@ -31,8 +31,8 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_200MHZ is not set
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
-# CONFIG_CPU_CLK_400MHZ is not set
-CONFIG_CPU_CLK_533MHZ=y
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 ALLOW_CPU_CLK_533MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
@@ -43,7 +43,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
 
 #
 # Memory selection
@@ -75,7 +74,8 @@ CONFIG_SDCARD_HS=y
 #
 CONFIG_SPI_CLK=33000000
 CONFIG_SMALL_DATAFLASH=y
-# ALLOW_DATAFLASH_RECOVERY is not set
+CONFIG_DATAFLASH_RECOVERY=y
+ALLOW_DATAFLASH_RECOVERY=y
 CONFIG_SPI_BOOT_CS0=y
 # CONFIG_SPI_BOOT_CS1 is not set
 # CONFIG_SPI_BOOT_CS2 is not set
@@ -91,7 +91,8 @@ ALLOW_BOOT_FROM_DATAFLASH_CS0=y
 # CONFIG_DATAFLASHCARD is not set
 CONFIG_CARD_SUFFIX=""
 CONFIG_SPI_BOOT="AT91C_SPI_PCS0_DATAFLASH"
-CONFIG_BOOTSTRAP_MAXSIZE="65536"
+ALLOW_NANDFLASH_RECOVERY=y
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
 CONFIG_PROJECT="dataflash"
 CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_LINUX is not set
@@ -99,7 +100,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00008400"
-CONFIG_IMG_SIZE="0x00080000"
+CONFIG_IMG_SIZE="0x00050000"
 CONFIG_JUMP_ADDR="0x26F00000"
 
 #
@@ -115,4 +116,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sama5d3xek/at91sama5d3xeknf_linux_dt_defconfig b/board/at91sama5d3xek/at91sama5d3xeknf_linux_dt_defconfig
deleted file mode 100644
index 2ee2493..0000000
--- a/board/at91sama5d3xek/at91sama5d3xeknf_linux_dt_defconfig
+++ /dev/null
@@ -1,112 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Thu Dec 27 17:17:59 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sama5d3xek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-CONFIG_AT91SAMA5D3XEK=y
-CONFIG_CHIP="AT91SAMA5D3X"
-CONFIG_BOARD="at91sama5d3xek"
-CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x310000"
-CONFIG_CRYSTAL_12_000MHZ=y
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_12_000MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-# CONFIG_CPU_CLK_400MHZ is not set
-CONFIG_CPU_CLK_533MHZ=y
-ALLOW_CPU_CLK_400MHZ=y
-ALLOW_CPU_CLK_533MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-ALLOW_PIO3=y
-CONFIG_HAS_PIO3=y
-CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
-CONFIG_MMC_SUPPORT=y
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-CONFIG_RAM_512MB=y
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-CONFIG_NANDFLASH=y
-# CONFIG_SDCARD is not set
-CONFIG_MEMORY="nandflash"
-CONFIG_SDCARD_HS=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-
-#
-# NAND Flash configuration
-#
-# CONFIG_ENABLE_SW_ECC is not set
-# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
-# ALLOW_NANDFLASH_RECOVERY is not set
-CONFIG_BOOTSTRAP_MAXSIZE="65536"
-CONFIG_PROJECT="nandflash"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x20000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=512M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs"
-CONFIG_IMG_ADDRESS="0x00200000"
-CONFIG_IMG_SIZE="0x300000"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_OFFSET="0x00180000"
-CONFIG_OF_LENGTH="0x2FFFF"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sama5d3xek/at91sama5d3xeknf_uboot_defconfig b/board/at91sama5d3xek/at91sama5d3xeknf_uboot_defconfig
old mode 100644
new mode 100755
index c5056a0..a6b2fcd
--- a/board/at91sama5d3xek/at91sama5d3xeknf_uboot_defconfig
+++ b/board/at91sama5d3xek/at91sama5d3xeknf_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:55:39 2012
+# Fri Jun 29 12:39:41 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sama5d3xek"
@@ -18,7 +18,7 @@ CONFIG_AT91SAMA5D3XEK=y
 CONFIG_CHIP="AT91SAMA5D3X"
 CONFIG_BOARD="at91sama5d3xek"
 CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
+CONFIG_LINK_ADDR="0x300000"
 CONFIG_TOP_OF_MEMORY="0x310000"
 CONFIG_CRYSTAL_12_000MHZ=y
 # CONFIG_CRYSTAL_16_000MHZ is not set
@@ -31,8 +31,8 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_200MHZ is not set
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
-# CONFIG_CPU_CLK_400MHZ is not set
-CONFIG_CPU_CLK_533MHZ=y
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 ALLOW_CPU_CLK_533MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
@@ -43,7 +43,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
 
 #
 # Memory selection
@@ -69,6 +68,7 @@ CONFIG_NANDFLASH=y
 # CONFIG_SDCARD is not set
 CONFIG_MEMORY="nandflash"
 CONFIG_SDCARD_HS=y
+ALLOW_DATAFLASH_RECOVERY=y
 ALLOW_BOOT_FROM_DATAFLASH_CS0=y
 
 #
@@ -76,8 +76,9 @@ ALLOW_BOOT_FROM_DATAFLASH_CS0=y
 #
 # CONFIG_ENABLE_SW_ECC is not set
 # CONFIG_NANDFLASH_SMALL_BLOCKS is not set
-# ALLOW_NANDFLASH_RECOVERY is not set
-CONFIG_BOOTSTRAP_MAXSIZE="65536"
+CONFIG_NANDFLASH_RECOVERY=y
+ALLOW_NANDFLASH_RECOVERY=y
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
 CONFIG_PROJECT="nandflash"
 CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_LINUX is not set
@@ -85,7 +86,7 @@ CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_4MB is not set
 # CONFIG_LOAD_64KB is not set
 CONFIG_IMG_ADDRESS="0x00040000"
-CONFIG_IMG_SIZE="0x00080000"
+CONFIG_IMG_SIZE="0x00050000"
 CONFIG_JUMP_ADDR="0x26F00000"
 
 #
@@ -101,4 +102,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sama5d3xek/at91sama5d3xeksd_linux_dt_defconfig b/board/at91sama5d3xek/at91sama5d3xeksd_linux_dt_defconfig
deleted file mode 100644
index 63258ae..0000000
--- a/board/at91sama5d3xek/at91sama5d3xeksd_linux_dt_defconfig
+++ /dev/null
@@ -1,102 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Fri Dec 21 09:54:18 2012
-#
-HAVE_DOT_CONFIG=y
-CONFIG_BOARDNAME="at91sama5d3xek"
-# CONFIG_AT91SAM9260EK is not set
-# CONFIG_AT91SAM9261EK is not set
-# CONFIG_AT91SAM9263EK is not set
-# CONFIG_AT91SAM9RLEK is not set
-# CONFIG_AT91SAM9XEEK is not set
-# CONFIG_AT91SAM9G10EK is not set
-# CONFIG_AT91SAM9G20EK is not set
-# CONFIG_AT91SAM9M10G45EK is not set
-# CONFIG_AT91SAM9X5EK is not set
-# CONFIG_AT91SAM9N12EK is not set
-CONFIG_AT91SAMA5D3XEK=y
-CONFIG_CHIP="AT91SAMA5D3X"
-CONFIG_BOARD="at91sama5d3xek"
-CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
-CONFIG_TOP_OF_MEMORY="0x310000"
-CONFIG_CRYSTAL_12_000MHZ=y
-# CONFIG_CRYSTAL_16_000MHZ is not set
-# CONFIG_CRYSTAL_16_36766MHZ is not set
-# CONFIG_CRYSTAL_18_432MHZ is not set
-ALLOW_CRYSTAL_12_000MHZ=y
-CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
-# CONFIG_CPU_CLK_166MHZ is not set
-# CONFIG_CPU_CLK_180MHZ is not set
-# CONFIG_CPU_CLK_200MHZ is not set
-# CONFIG_CPU_CLK_240MHZ is not set
-# CONFIG_CPU_CLK_266MHZ is not set
-# CONFIG_CPU_CLK_400MHZ is not set
-CONFIG_CPU_CLK_533MHZ=y
-ALLOW_CPU_CLK_400MHZ=y
-ALLOW_CPU_CLK_533MHZ=y
-# DISABLE_CPU_CLK_240MHZ is not set
-# CONFIG_BUS_SPEED_83MHZ is not set
-# CONFIG_BUS_SPEED_90MHZ is not set
-# CONFIG_BUS_SPEED_100MHZ is not set
-CONFIG_BUS_SPEED_133MHZ=y
-ALLOW_PIO3=y
-CONFIG_HAS_PIO3=y
-CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
-
-#
-# Memory selection
-#
-# CONFIG_SDRAM is not set
-# CONFIG_SDDRC is not set
-CONFIG_DDR2=y
-ALLOW_DATAFLASH=y
-# ALLOW_FLASH is not set
-ALLOW_NANDFLASH=y
-ALLOW_SDCARD=y
-ALLOW_HSMCI=y
-# ALLOW_PSRAM is not set
-# ALLOW_SDRAM_16BIT is not set
-# CONFIG_RAM_32MB is not set
-# CONFIG_RAM_64MB is not set
-# CONFIG_RAM_128MB is not set
-# CONFIG_RAM_256MB is not set
-CONFIG_RAM_512MB=y
-# CONFIG_DATAFLASH is not set
-# CONFIG_FLASH is not set
-# CONFIG_NANDFLASH is not set
-CONFIG_SDCARD=y
-CONFIG_MEMORY="sdcard"
-CONFIG_SDCARD_HS=y
-ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-CONFIG_BOOTSTRAP_MAXSIZE="65536"
-CONFIG_PROJECT="sdcard"
-# CONFIG_LOAD_UBOOT is not set
-CONFIG_LOAD_LINUX=y
-# CONFIG_LOAD_1MB is not set
-# CONFIG_LOAD_4MB is not set
-# CONFIG_LOAD_64KB is not set
-
-#
-# Linux Image Storage Setup
-#
-CONFIG_OS_MEM_BANK="0x20000000"
-CONFIG_OS_MEM_SIZE="0x20000000"
-CONFIG_LINUX_KERNEL_ARG_STRING="mem=512M console=ttyS0,115200 root=/dev/mmcblk0p2 rootdelay=2"
-CONFIG_OS_IMAGE_NAME="image.bin"
-CONFIG_JUMP_ADDR="0x22000000"
-CONFIG_OF_LIBFDT=y
-CONFIG_OF_FILENAME="ek.dtb"
-CONFIG_OF_ADDRESS="0x21000000"
-CONFIG_IMAGE_NAME="linux"
-# CONFIG_LONG_TEST is not set
-CONFIG_DEBUG=y
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_LOUD is not set
-# CONFIG_DEBUG_VERY_LOUD is not set
-CONFIG_HW_INIT=y
-# CONFIG_USER_HW_INIT is not set
-CONFIG_THUMB=y
-CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sama5d3xek/at91sama5d3xeksd_uboot_defconfig b/board/at91sama5d3xek/at91sama5d3xeksd_uboot_defconfig
old mode 100644
new mode 100755
index 5d2df02..c8a78d3
--- a/board/at91sama5d3xek/at91sama5d3xeksd_uboot_defconfig
+++ b/board/at91sama5d3xek/at91sama5d3xeksd_uboot_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Fri Dec 21 09:56:10 2012
+# Thu Jun 28 12:59:00 2012
 #
 HAVE_DOT_CONFIG=y
 CONFIG_BOARDNAME="at91sama5d3xek"
@@ -18,7 +18,7 @@ CONFIG_AT91SAMA5D3XEK=y
 CONFIG_CHIP="AT91SAMA5D3X"
 CONFIG_BOARD="at91sama5d3xek"
 CONFIG_MACH_TYPE="9999"
-CONFIG_LINK_ADDR="0x000000"
+CONFIG_LINK_ADDR="0x300000"
 CONFIG_TOP_OF_MEMORY="0x310000"
 CONFIG_CRYSTAL_12_000MHZ=y
 # CONFIG_CRYSTAL_16_000MHZ is not set
@@ -31,8 +31,8 @@ CONFIG_CRYSTAL="CRYSTAL_12_000MHZ"
 # CONFIG_CPU_CLK_200MHZ is not set
 # CONFIG_CPU_CLK_240MHZ is not set
 # CONFIG_CPU_CLK_266MHZ is not set
-# CONFIG_CPU_CLK_400MHZ is not set
-CONFIG_CPU_CLK_533MHZ=y
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
 ALLOW_CPU_CLK_400MHZ=y
 ALLOW_CPU_CLK_533MHZ=y
 # DISABLE_CPU_CLK_240MHZ is not set
@@ -43,7 +43,6 @@ CONFIG_BUS_SPEED_133MHZ=y
 ALLOW_PIO3=y
 CONFIG_HAS_PIO3=y
 CPU_HAS_PMECC=y
-CONFIG_LOAD_ONE_WIRE=y
 
 #
 # Memory selection
@@ -69,8 +68,10 @@ CONFIG_RAM_512MB=y
 CONFIG_SDCARD=y
 CONFIG_MEMORY="sdcard"
 CONFIG_SDCARD_HS=y
+ALLOW_DATAFLASH_RECOVERY=y
 ALLOW_BOOT_FROM_DATAFLASH_CS0=y
-CONFIG_BOOTSTRAP_MAXSIZE="65536"
+ALLOW_NANDFLASH_RECOVERY=y
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
 CONFIG_PROJECT="sdcard"
 CONFIG_LOAD_UBOOT=y
 # CONFIG_LOAD_LINUX is not set
@@ -93,4 +94,3 @@ CONFIG_HW_INIT=y
 # CONFIG_USER_HW_INIT is not set
 CONFIG_THUMB=y
 CONFIG_SCLK=y
-CONFIG_DISABLE_WATCHDOG=y
diff --git a/board/at91sama5d3xek/board.mk b/board/at91sama5d3xek/board.mk
old mode 100644
new mode 100755
index 604a024..2dcf40e
--- a/board/at91sama5d3xek/board.mk
+++ b/board/at91sama5d3xek/board.mk
@@ -1,19 +1,18 @@
-$(shell $(CC) --target-help > tmp.file)
-gcc_cortexa5=$(shell grep cortex-a5 tmp.file)
 
-ifeq (, $(findstring cortex-a5,$(gcc_cortexa5)))
-CPPFLAGS += -DCONFIG_AT91SAMA5D3XEK
-
-ASFLAGS += \
-	-DCONFIG_AT91SAMA5D3XEK
-else
+ifeq "$(CCVERSIONGE441)" "1"
 CPPFLAGS += \
 	-DCONFIG_AT91SAMA5D3XEK \
-	-mtune=cortex-a5
+	-mcpu=cortex-a5
+else
+CPPFLAGS += \
+	-DCONFIG_AT91SAMA5D3XEK
+endif
 
+ifeq "$(CCVERSIONGE441)" "1"
 ASFLAGS += \
-	-DCONFIG_AT91SAMA5D3XEK
+	-DCONFIG_AT91SAMA5D3XEK \
 	-mcpu=cortex-a5
+else
+ASFLAGS += \
+	-DCONFIG_AT91SAMA5D3XEK
 endif
-
-$(shell rm tmp.file)
diff --git a/board/board_cpp.mk b/board/board_cpp.mk
old mode 100644
new mode 100755
index d424367..7e5c474
--- a/board/board_cpp.mk
+++ b/board/board_cpp.mk
@@ -98,11 +98,3 @@ endif
 ifeq ($(CPU_HAS_PMECC),y)
 CPPFLAGS += -DCPU_HAS_PMECC
 endif
-
-ifeq ($(CONFIG_LOAD_ONE_WIRE), y)
-CPPFLAGS += -DCONFIG_LOAD_ONE_WIRE
-endif
-
-ifeq ($(CONFIG_MMC_SUPPORT), y)
-CPPFLAGS += -DCONFIG_MMC_SUPPORT
-endif
diff --git a/board/nanosg20/board.mk b/board/nanosg20/board.mk
new file mode 100755
index 0000000..a95b2b4
--- /dev/null
+++ b/board/nanosg20/board.mk
@@ -0,0 +1,7 @@
+CPPFLAGS += \
+	-DCONFIG_NANOSG20 \
+	-mcpu=arm926ej-s
+
+ASFLAGS += \
+	-DCONFIG_NANOSG20 \
+	-mcpu=arm926ej-s
diff --git a/board/nanosg20/nanosg20.c b/board/nanosg20/nanosg20.c
new file mode 100755
index 0000000..4f28b62
--- /dev/null
+++ b/board/nanosg20/nanosg20.c
@@ -0,0 +1,252 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "common.h"
+#include "hardware.h"
+#include "arch/at91_ccfg.h"
+#include "arch/at91_matrix.h"
+#include "arch/at91_wdt.h"
+#include "arch/at91_rstc.h"
+#include "arch/at91_pmc.h"
+#include "arch/at91_smc.h"
+#include "arch/at91_pio.h"
+#include "arch/at91_sdramc.h"
+#include "gpio.h"
+#include "pmc.h"
+#include "dbgu.h"
+#include "debug.h"
+#include "sdramc.h"
+#include "nanosg20.h"
+
+unsigned int get_cp15();
+void set_cp15(unsigned int);
+#define I_CACHE (1<<12)
+
+#ifdef CONFIG_USER_HW_INIT
+extern void hw_init_hook(void);
+#endif
+
+#ifdef CONFIG_DEBUG
+static void at91_dbgu_hw_init(void)
+{
+	/* Configure DBGU pin */
+	const struct pio_desc dbgu_pins[] = {
+		{"RXD", AT91C_PIN_PB(14), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"TXD", AT91C_PIN_PB(15), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	pio_configure(dbgu_pins);
+
+	/*  Configure the dbgu pins */
+	writel((1 << AT91C_ID_PIOB), (PMC_PCER + AT91C_BASE_PMC));
+}
+
+static void initialize_dbgu(void)
+{
+	at91_dbgu_hw_init();
+
+	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
+}
+#endif /* #ifdef CONFIG_DEBUG */
+
+#ifdef CONFIG_SDRAM
+static void sdramc_hw_init(void)
+{
+	/* Configure sdramc pins */
+	const struct pio_desc sdramc_pins[] = {
+		{"D16", AT91C_PIN_PC(16), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D17", AT91C_PIN_PC(17), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D18", AT91C_PIN_PC(18), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D19", AT91C_PIN_PC(19), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D20", AT91C_PIN_PC(20), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D21", AT91C_PIN_PC(21), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D22", AT91C_PIN_PC(22), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D23", AT91C_PIN_PC(23), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D24", AT91C_PIN_PC(24), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D25", AT91C_PIN_PC(25), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D26", AT91C_PIN_PC(26), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D27", AT91C_PIN_PC(27), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D28", AT91C_PIN_PC(28), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D29", AT91C_PIN_PC(29), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D30", AT91C_PIN_PC(30), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D31", AT91C_PIN_PC(31), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{(char *) 0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Configure the SDRAMC PINs */
+	writel((1 << AT91C_ID_PIOC), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(sdramc_pins);
+}
+
+static void sdramc_init(void)
+{
+	struct sdramc_register sdramc_config;
+
+#ifdef CONFIG_RAM_128MB
+	sdramc_config.cr = AT91C_SDRAMC_NC_10 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_3
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_32_BITS
+				| AT91C_SDRAMC_TWR_3 | AT91C_SDRAMC_TRC_13
+				| AT91C_SDRAMC_TRP_3 | AT91C_SDRAMC_TRCD_3
+				| AT91C_SDRAMC_TRAS_6 | AT91C_SDRAMC_TXSR_15;
+#else
+	sdramc_config.cr = AT91C_SDRAMC_NC_9 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_3
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_32_BITS
+				| AT91C_SDRAMC_TWR_3 | AT91C_SDRAMC_TRC_8
+				| AT91C_SDRAMC_TRP_3 | AT91C_SDRAMC_TRCD_3
+				| AT91C_SDRAMC_TRAS_6 | AT91C_SDRAMC_TXSR_9;
+#endif
+
+	sdramc_config.tr = (MASTER_CLOCK * 7) / 1000000;
+	sdramc_config.mdr = AT91C_SDRAMC_MD_SDRAM;
+
+	sdramc_hw_init();
+
+	/* Initialize the matrix (memory voltage = 1.8) */
+	writel((readl(AT91C_BASE_CCFG + CCFG_EBICSA))
+		| AT91C_EBI_CS1A_SDRAMC,
+		AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	sdramc_initialize(&sdramc_config, AT91C_BASE_CS1);
+}
+#endif /* #ifdef CONFIG_SDRAM */
+
+#ifdef CONFIG_HW_INIT
+void hw_init(void)
+{
+	unsigned int cp15;
+
+	/* Disable watchdog */
+//	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
+
+	/*
+	 * At this stage the main oscillator is supposed to be enabled
+	 * PCK = MCK = MOSC
+	 */
+	writel(0x00, AT91C_BASE_PMC + PMC_PLLICPR);
+
+	/* Configure PLLA = MOSC * (PLL_MULA + 1) / PLL_DIVA */
+	pmc_cfg_plla(PLLA_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* PCK = PLLA/2 = 3 * MCK */
+	pmc_cfg_mck(MCKR_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Switch MCK on PLLA output */
+	pmc_cfg_mck(MCKR_CSS_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Configure PLLB  */
+	//pmc_cfg_pllb(PLLB_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Enable External Reset */
+	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
+
+	/* Configure the EBI Slave Slot Cycle to 64 */
+	writel((readl((AT91C_BASE_MATRIX + MATRIX_SCFG3)) & ~0xFF) | 0x40,
+		(AT91C_BASE_MATRIX + MATRIX_SCFG3));
+
+	cp15 = get_cp15();
+	cp15 |= I_CACHE;
+	set_cp15(cp15);
+
+#ifdef CONFIG_DEBUG
+	/* Initialize dbgu */
+	initialize_dbgu();
+#endif
+
+#ifdef CONFIG_SDRAM
+	/* Initlialize sdram controller */
+	sdramc_init();
+#endif
+
+#ifdef CONFIG_USER_HW_INIT
+	hw_init_hook();
+#endif
+
+}
+#endif /* #ifdef CONFIG_HW_INIT */
+
+#ifdef CONFIG_NANDFLASH
+void nandflash_hw_init(void)
+{
+	unsigned int reg;
+
+	/* Configure PIOs */
+	const struct pio_desc nand_pins[] = {
+		{"NANDCS",	CONFIG_SYS_NAND_ENABLE_PIN,	1, PIO_PULLUP, PIO_OUTPUT},
+		{(char *)0, 	0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Setup Smart Media, first enable the address range of CS3 in HMATRIX user interface  */
+	reg = readl(AT91C_BASE_CCFG + CCFG_EBICSA);
+	reg |= AT91C_EBI_CS3A_SM;
+
+	writel(reg, AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/* Configure SMC CS3 */
+	writel((AT91C_SMC_NWESETUP_(2)
+		| AT91C_SMC_NCS_WRSETUP_(0)
+		| AT91C_SMC_NRDSETUP_(2)
+		| AT91C_SMC_NCS_RDSETUP_(0)),
+		AT91C_BASE_SMC + SMC_SETUP3);
+
+	writel((AT91C_SMC_NWEPULSE_(4)
+		| AT91C_SMC_NCS_WRPULSE_(4)
+		| AT91C_SMC_NRDPULSE_(4)
+		| AT91C_SMC_NCS_RDPULSE_(4)),
+		AT91C_BASE_SMC + SMC_PULSE3);
+
+	writel((AT91C_SMC_NWECYCLE_(7)
+		|  AT91C_SMC_NRDCYCLE_(7)),
+		AT91C_BASE_SMC + SMC_CYCLE3);
+
+	writel((AT91C_SMC_READMODE
+		| AT91C_SMC_WRITEMODE
+		| AT91C_SMC_NWAITM_NWAIT_DISABLE
+		| AT91C_SMC_DBW_WIDTH_BITS_16
+		| AT91_SMC_TDF_(3)),
+		AT91C_BASE_SMC + SMC_CTRL3);
+
+	/* Configure the PIO controller */
+	pio_configure(nand_pins);
+	writel((1 << AT91C_ID_PIOC), PMC_PCER + AT91C_BASE_PMC);
+}
+
+void nandflash_config_buswidth(unsigned char busw)
+{
+	unsigned long csa;
+
+	csa = readl(AT91C_BASE_SMC + SMC_CTRL3);
+
+	if (busw == 0)
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_8;
+	else
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_16;
+
+	writel(csa, AT91C_BASE_SMC + SMC_CTRL3);
+}
+#endif /* #ifdef CONFIG_NANDFLASH */
+
diff --git a/board/nanosg20/nanosg20.h b/board/nanosg20/nanosg20.h
new file mode 100755
index 0000000..6c326b9
--- /dev/null
+++ b/board/nanosg20/nanosg20.h
@@ -0,0 +1,63 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __NANOSG20_H__
+#define __NANOSG20_H__
+
+/*
+ * PMC Setting
+ *
+ * The main oscillator is enabled as soon as possible in the c_startup
+ * and MCK is switched on the main oscillator.
+ * PLL initialization is done later in the hw_init() function
+ */
+#define MASTER_CLOCK		132096000
+#define PLL_LOCK_TIMEOUT	1000000
+
+#define PLLA_SETTINGS		0x202A3F01
+#define PLLB_SETTINGS		0x10193F05
+
+/* Switch MCK on PLLA output PCK = PLLA/2 = 3 * MCK */
+#define MCKR_SETTINGS		0x1300
+#define MCKR_CSS_SETTINGS	(AT91C_PMC_CSS_PLLA_CLK | MCKR_SETTINGS)
+
+/*
+ * NandFlash Settings
+ */
+#define CONFIG_SYS_NAND_BASE		AT91C_BASE_CS3
+#define CONFIG_SYS_NAND_MASK_ALE	(1 << 21)
+#define CONFIG_SYS_NAND_MASK_CLE	(1 << 22)
+
+#define CONFIG_SYS_NAND_ENABLE_PIN	AT91C_PIN_PC(14)
+
+/* function */
+extern void hw_init(void);
+
+extern void nandflash_hw_init(void);
+extern void nandflash_config_buswidth(unsigned char busw);
+
+#endif	/* #ifndef __NANOSG20_H__ */
diff --git a/board/nanosg20/nanosg20nf_linux_128mb_defconfig b/board/nanosg20/nanosg20nf_linux_128mb_defconfig
new file mode 100644
index 0000000..380ceef
--- /dev/null
+++ b/board/nanosg20/nanosg20nf_linux_128mb_defconfig
@@ -0,0 +1,109 @@
+#
+# Automatically generated make config: don't edit
+# Thu Feb  7 14:55:15 2013
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="nanosg20"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+# CONFIG_STAMP9G20 is not set
+# CONFIG_STAMP9G45 is not set
+CONFIG_NANOSG20=y
+# CONFIG_PICOSG20 is not set
+CONFIG_CHIP="AT91SAM9G20"
+CONFIG_BOARD="nanosg20"
+CONFIG_MACH_TYPE="2759"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x304000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+CONFIG_SDRAM=y
+# CONFIG_SDDRC is not set
+# CONFIG_DDR2 is not set
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+# ALLOW_SDCARD is not set
+# ALLOW_HSMCI is not set
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+# CONFIG_SDCARD_HS is not set
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=4
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+# ALLOW_NANDFLASH_RECOVERY is not set
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x20000000"
+CONFIG_OS_MEM_SIZE="0x08000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x2e0000"
+CONFIG_JUMP_ADDR="0x21000000"
+# CONFIG_LINUX_DT is not set
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
diff --git a/board/nanosg20/nanosg20nf_linux_64mb_defconfig b/board/nanosg20/nanosg20nf_linux_64mb_defconfig
new file mode 100644
index 0000000..ca17b78
--- /dev/null
+++ b/board/nanosg20/nanosg20nf_linux_64mb_defconfig
@@ -0,0 +1,109 @@
+#
+# Automatically generated make config: don't edit
+# Thu Feb  7 14:54:28 2013
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="nanosg20"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+# CONFIG_STAMP9G20 is not set
+# CONFIG_STAMP9G45 is not set
+CONFIG_NANOSG20=y
+# CONFIG_PICOSG20 is not set
+CONFIG_CHIP="AT91SAM9G20"
+CONFIG_BOARD="nanosg20"
+CONFIG_MACH_TYPE="2759"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x304000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+CONFIG_SDRAM=y
+# CONFIG_SDDRC is not set
+# CONFIG_DDR2 is not set
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+# ALLOW_SDCARD is not set
+# ALLOW_HSMCI is not set
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+CONFIG_RAM_64MB=y
+# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+# CONFIG_SDCARD_HS is not set
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=4
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+# ALLOW_NANDFLASH_RECOVERY is not set
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x20000000"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x2e0000"
+CONFIG_JUMP_ADDR="0x21000000"
+# CONFIG_LINUX_DT is not set
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
diff --git a/board/picosg20/board.mk b/board/picosg20/board.mk
new file mode 100755
index 0000000..5cb6b46
--- /dev/null
+++ b/board/picosg20/board.mk
@@ -0,0 +1,7 @@
+CPPFLAGS += \
+	-DCONFIG_PICOSG20 \
+	-mcpu=arm926ej-s
+
+ASFLAGS += \
+	-DCONFIG_PICOSG20 \
+	-mcpu=arm926ej-s
diff --git a/board/picosg20/picosg20.c b/board/picosg20/picosg20.c
new file mode 100755
index 0000000..f9f26d8
--- /dev/null
+++ b/board/picosg20/picosg20.c
@@ -0,0 +1,291 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "common.h"
+#include "hardware.h"
+#include "arch/at91_ccfg.h"
+#include "arch/at91_matrix.h"
+#include "arch/at91_wdt.h"
+#include "arch/at91_rstc.h"
+#include "arch/at91_pmc.h"
+#include "arch/at91_smc.h"
+#include "arch/at91_pio.h"
+#include "arch/at91_sdramc.h"
+#include "spi.h"
+#include "gpio.h"
+#include "pmc.h"
+#include "dbgu.h"
+#include "debug.h"
+#include "sdramc.h"
+#include "picosg20.h"
+
+unsigned int get_cp15();
+void set_cp15(unsigned int);
+#define I_CACHE (1<<12)
+
+#ifdef CONFIG_USER_HW_INIT
+extern void hw_init_hook(void);
+#endif
+
+#ifdef CONFIG_DEBUG
+static void at91_dbgu_hw_init(void)
+{
+	/* Configure DBGU pin */
+	const struct pio_desc dbgu_pins[] = {
+		{"RXD", AT91C_PIN_PB(14), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"TXD", AT91C_PIN_PB(15), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	pio_configure(dbgu_pins);
+
+	/*  Configure the dbgu pins */
+	writel((1 << AT91C_ID_PIOB), (PMC_PCER + AT91C_BASE_PMC));
+}
+
+static void initialize_dbgu(void)
+{
+	at91_dbgu_hw_init();
+
+	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
+}
+#endif /* #ifdef CONFIG_DEBUG */
+
+#ifdef CONFIG_SDRAM
+static void sdramc_hw_init(void)
+{
+	/* Configure sdramc pins */
+	const struct pio_desc sdramc_pins[] = {
+		{"D16", AT91C_PIN_PC(16), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D17", AT91C_PIN_PC(17), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D18", AT91C_PIN_PC(18), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D19", AT91C_PIN_PC(19), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D20", AT91C_PIN_PC(20), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D21", AT91C_PIN_PC(21), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D22", AT91C_PIN_PC(22), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D23", AT91C_PIN_PC(23), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D24", AT91C_PIN_PC(24), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D25", AT91C_PIN_PC(25), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D26", AT91C_PIN_PC(26), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D27", AT91C_PIN_PC(27), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D28", AT91C_PIN_PC(28), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D29", AT91C_PIN_PC(29), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D30", AT91C_PIN_PC(30), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D31", AT91C_PIN_PC(31), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{(char *) 0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Configure the SDRAMC PINs */
+	writel((1 << AT91C_ID_PIOC), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(sdramc_pins);
+}
+
+static void sdramc_init(void)
+{
+	struct sdramc_register sdramc_config;
+
+#ifdef CONFIG_RAM_32MB
+	sdramc_config.cr = AT91C_SDRAMC_NC_9 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_3
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_16_BITS
+				| AT91C_SDRAMC_TWR_3 | AT91C_SDRAMC_TRC_8
+				| AT91C_SDRAMC_TRP_3 | AT91C_SDRAMC_TRCD_3
+				| AT91C_SDRAMC_TRAS_6 | AT91C_SDRAMC_TXSR_9;
+#else
+	sdramc_config.cr = AT91C_SDRAMC_NC_10 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_3
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_16_BITS
+				| AT91C_SDRAMC_TWR_3 | AT91C_SDRAMC_TRC_13
+				| AT91C_SDRAMC_TRP_3 | AT91C_SDRAMC_TRCD_3
+				| AT91C_SDRAMC_TRAS_6 | AT91C_SDRAMC_TXSR_15;
+#endif
+
+	sdramc_config.tr = (MASTER_CLOCK * 7) / 1000000;
+	sdramc_config.mdr = AT91C_SDRAMC_MD_SDRAM;
+
+	sdramc_hw_init();
+
+	/* Initialize the matrix (memory voltage = 3.3) */
+	writel((readl(AT91C_BASE_CCFG + CCFG_EBICSA))
+		| AT91C_EBI_CS1A_SDRAMC | AT91C_VDDIOM_SEL_33V,
+		AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	sdramc_initialize(&sdramc_config, AT91C_BASE_CS1);
+}
+#endif /* #ifdef CONFIG_SDRAM */
+
+#if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY)
+static void recovery_buttons_hw_init(void)
+{
+	writel((1 << AT91C_ID_PIOB), PMC_PCER + AT91C_BASE_PMC);
+}
+#endif /* #if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY) */
+
+#ifdef CONFIG_HW_INIT
+void hw_init(void)
+{
+	unsigned int cp15;
+
+	const struct pio_desc hw_pio[] = {
+		{"MCDA0", AT91C_PIN_PA(6),  0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"MCCDA", AT91C_PIN_PA(7),  0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"MCCK",  AT91C_PIN_PA(8),  0, PIO_DEFAULT, PIO_PERIPH_A},
+//		{"MCDA1", AT91C_PIN_PA(9),  0, PIO_DEFAULT, PIO_PERIPH_A},
+//		{"MCDA2", AT91C_PIN_PA(10), 0, PIO_DEFAULT, PIO_PERIPH_A},
+//		{"MCDA3", AT91C_PIN_PA(11), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"ETX0",  AT91C_PIN_PA(12), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"ETX1",  AT91C_PIN_PA(13), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"ERX0",  AT91C_PIN_PA(14), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"ERX1",  AT91C_PIN_PA(15), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"ETXEN", AT91C_PIN_PA(16), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"ERXDV", AT91C_PIN_PA(17), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"ERXER", AT91C_PIN_PA(18), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"ETXCK", AT91C_PIN_PA(19), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"EMDC",  AT91C_PIN_PA(20), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"EMDIO", AT91C_PIN_PA(21), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"XHDMA",  AT91C_PIN_PA(26), 0, PIO_DEFAULT, PIO_INPUT},
+		{"XHDPA",  AT91C_PIN_PA(27), 0, PIO_DEFAULT, PIO_INPUT},
+		{"XHDPB",  AT91C_PIN_PA(30), 0, PIO_DEFAULT, PIO_INPUT},
+		{"XHDMB",  AT91C_PIN_PA(31), 0, PIO_DEFAULT, PIO_INPUT},
+		{"XDDP",   AT91C_PIN_PB(8),  0, PIO_DEFAULT, PIO_INPUT},
+		{"XDDM",   AT91C_PIN_PB(9),  0, PIO_DEFAULT, PIO_INPUT},
+		{(char *) 0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+	pio_configure(hw_pio);
+
+	/* Disable watchdog */
+//	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
+
+	/*
+	 * At this stage the main oscillator is supposed to be enabled
+	 * PCK = MCK = MOSC
+	 */
+	writel(0x00, AT91C_BASE_PMC + PMC_PLLICPR);
+
+	/* Configure PLLA = MOSC * (PLL_MULA + 1) / PLL_DIVA */
+	pmc_cfg_plla(PLLA_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* PCK = PLLA/2 = 3 * MCK */
+	pmc_cfg_mck(MCKR_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Switch MCK on PLLA output */
+	pmc_cfg_mck(MCKR_CSS_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Configure PLLB  */
+	//pmc_cfg_pllb(PLLB_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Enable External Reset */
+	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
+
+	/* Configure the EBI Slave Slot Cycle to 64 */
+	writel((readl((AT91C_BASE_MATRIX + MATRIX_SCFG3)) & ~0xFF) | 0x40,
+		(AT91C_BASE_MATRIX + MATRIX_SCFG3));
+
+	cp15 = get_cp15();
+	cp15 |= I_CACHE;
+	set_cp15(cp15);
+
+#ifdef CONFIG_DEBUG
+	/* Initialize dbgu */
+	initialize_dbgu();
+#endif
+
+#ifdef CONFIG_SDRAM
+	/* Initlialize sdram controller */
+	sdramc_init();
+#endif
+
+#ifdef CONFIG_USER_HW_INIT
+	hw_init_hook();
+#endif
+
+#if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY)
+	/* Init the recovery buttons pins */
+	recovery_buttons_hw_init();
+#endif
+}
+#endif /* #ifdef CONFIG_HW_INIT */
+
+#ifdef CONFIG_NANDFLASH
+void nandflash_hw_init(void)
+{
+	unsigned int reg;
+
+	/* Configure PIOs */
+	const struct pio_desc nand_pins[] = {
+		{"NANDCS",	CONFIG_SYS_NAND_ENABLE_PIN,	1, PIO_PULLUP, PIO_OUTPUT},
+		{(char *)0, 	0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Setup Smart Media, first enable the address range of CS3 in HMATRIX user interface  */
+	reg = readl(AT91C_BASE_CCFG + CCFG_EBICSA);
+	reg |= AT91C_EBI_CS3A_SM;
+
+	writel(reg, AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/* Configure SMC CS3 */
+	writel((AT91C_SMC_NWESETUP_(2)
+		| AT91C_SMC_NCS_WRSETUP_(0)
+		| AT91C_SMC_NRDSETUP_(2)
+		| AT91C_SMC_NCS_RDSETUP_(0)),
+		AT91C_BASE_SMC + SMC_SETUP3);
+
+	writel((AT91C_SMC_NWEPULSE_(4)
+		| AT91C_SMC_NCS_WRPULSE_(4)
+		| AT91C_SMC_NRDPULSE_(4)
+		| AT91C_SMC_NCS_RDPULSE_(4)),
+		AT91C_BASE_SMC + SMC_PULSE3);
+
+	writel((AT91C_SMC_NWECYCLE_(7)
+		|  AT91C_SMC_NRDCYCLE_(7)),
+		AT91C_BASE_SMC + SMC_CYCLE3);
+
+	writel((AT91C_SMC_READMODE
+		| AT91C_SMC_WRITEMODE
+		| AT91C_SMC_NWAITM_NWAIT_DISABLE
+		| AT91C_SMC_DBW_WIDTH_BITS_16
+		| AT91_SMC_TDF_(3)),
+		AT91C_BASE_SMC + SMC_CTRL3);
+
+	/* Configure the PIO controller */
+	pio_configure(nand_pins);
+	writel((1 << AT91C_ID_PIOC), PMC_PCER + AT91C_BASE_PMC);
+}
+
+void nandflash_config_buswidth(unsigned char busw)
+{
+	unsigned long csa;
+
+	csa = readl(AT91C_BASE_SMC + SMC_CTRL3);
+
+	if (busw == 0)
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_8;
+	else
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_16;
+
+	writel(csa, AT91C_BASE_SMC + SMC_CTRL3);
+}
+#endif /* #ifdef CONFIG_NANDFLASH */
+
diff --git a/board/picosg20/picosg20.h b/board/picosg20/picosg20.h
new file mode 100755
index 0000000..784d155
--- /dev/null
+++ b/board/picosg20/picosg20.h
@@ -0,0 +1,99 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __AT91SAM9G20EK_H__
+#define __AT91SAM9G20EK_H__
+
+/*
+ * PMC Setting
+ *
+ * The main oscillator is enabled as soon as possible in the c_startup
+ * and MCK is switched on the main oscillator.
+ * PLL initialization is done later in the hw_init() function
+ */
+#define MASTER_CLOCK		132096000
+#define PLL_LOCK_TIMEOUT	1000000
+
+#define PLLA_SETTINGS		0x202A3F01
+#define PLLB_SETTINGS		0x10193F05
+
+/* Switch MCK on PLLA output PCK = PLLA/2 = 3 * MCK */
+#define MCKR_SETTINGS		0x1300
+#define MCKR_CSS_SETTINGS	(AT91C_PMC_CSS_PLLA_CLK | MCKR_SETTINGS)
+
+/*
+* DataFlash Settings
+*/
+#define CONFIG_SYS_SPI_CLOCK	AT91C_SPI_CLK
+#define CONFIG_SYS_SPI_BUS	0
+#define CONFIG_SYS_SPI_MODE	SPI_MODE0
+
+#if CONFIG_SYS_SPI_BUS == 0
+#define CONFIG_SYS_BASE_SPI	AT91C_BASE_SPI0
+#elif CONFIG_SYS_SPI_BUS == 1
+#define CONFIG_SYS_BASE_SPI	AT91C_BASE_SPI1
+#endif
+
+#if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
+#define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(3)
+#elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
+#define CONFIG_SYS_SPI_PCS	AT91C_PIN_PC(11)
+#endif
+
+/*
+ * NandFlash Settings
+ */
+#define CONFIG_SYS_NAND_BASE		AT91C_BASE_CS3
+#define CONFIG_SYS_NAND_MASK_ALE	(1 << 21)
+#define CONFIG_SYS_NAND_MASK_CLE	(1 << 22)
+
+#define CONFIG_SYS_NAND_ENABLE_PIN	AT91C_PIN_PC(14)
+
+/*
+ * MCI Settings
+ */
+#define CONFIG_SYS_BASE_MCI	AT91C_BASE_MCI
+
+/*
+ * Recovery
+ */
+#define CONFIG_SYS_RECOVERY_BUTTON_PIN	AT91C_PIN_PB(15)
+#define RECOVERY_BUTTON_NAME	"DTXD"
+
+/* function */
+extern void hw_init(void);
+
+extern void nandflash_hw_init(void);
+extern void nandflash_config_buswidth(unsigned char busw);
+
+extern void at91_spi0_hw_init(void);
+
+extern void at91_mci0_hw_init(void);
+
+#endif	/* #ifndef __AT91SAM9G20EK_H__ */
diff --git a/board/picosg20/picosg20nf_linux_32mb_defconfig b/board/picosg20/picosg20nf_linux_32mb_defconfig
new file mode 100644
index 0000000..f833bc8
--- /dev/null
+++ b/board/picosg20/picosg20nf_linux_32mb_defconfig
@@ -0,0 +1,113 @@
+#
+# Automatically generated make config: don't edit
+# Thu Feb  7 14:55:36 2013
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="picosg20"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+# CONFIG_STAMP9G20 is not set
+# CONFIG_STAMP9G45 is not set
+# CONFIG_NANOSG20 is not set
+CONFIG_PICOSG20=y
+CONFIG_CHIP="AT91SAM9G20"
+CONFIG_BOARD="picosg20"
+CONFIG_MACH_TYPE="0"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x304000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+CONFIG_SDRAM=y
+# CONFIG_SDDRC is not set
+# CONFIG_DDR2 is not set
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+# ALLOW_SDCARD is not set
+# ALLOW_HSMCI is not set
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+CONFIG_RAM_32MB=y
+# CONFIG_RAM_64MB is not set
+# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+# CONFIG_SDCARD_HS is not set
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=4
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+CONFIG_NANDFLASH_RECOVERY=y
+ALLOW_NANDFLASH_RECOVERY=y
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x20000000"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_IMG_ADDRESS="0x000a0000"
+CONFIG_IMG_SIZE="0x360000"
+CONFIG_JUMP_ADDR="0x21000000"
+CONFIG_LINUX_DT=y
+CONFIG_DTIMG_ADDRESS="0x00010000"
+CONFIG_DTIMG_SIZE="0x10000"
+CONFIG_DT_ADDRESS="0x20f00000"
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
diff --git a/board/picosg20/picosg20nf_linux_64mb_defconfig b/board/picosg20/picosg20nf_linux_64mb_defconfig
new file mode 100644
index 0000000..0a0bf2d
--- /dev/null
+++ b/board/picosg20/picosg20nf_linux_64mb_defconfig
@@ -0,0 +1,113 @@
+#
+# Automatically generated make config: don't edit
+# Thu Feb  7 14:56:01 2013
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="picosg20"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+# CONFIG_STAMP9G20 is not set
+# CONFIG_STAMP9G45 is not set
+# CONFIG_NANOSG20 is not set
+CONFIG_PICOSG20=y
+CONFIG_CHIP="AT91SAM9G20"
+CONFIG_BOARD="picosg20"
+CONFIG_MACH_TYPE="0"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x304000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+CONFIG_SDRAM=y
+# CONFIG_SDDRC is not set
+# CONFIG_DDR2 is not set
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+# ALLOW_SDCARD is not set
+# ALLOW_HSMCI is not set
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+CONFIG_RAM_64MB=y
+# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+# CONFIG_SDCARD_HS is not set
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=4
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+CONFIG_NANDFLASH_RECOVERY=y
+ALLOW_NANDFLASH_RECOVERY=y
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x20000000"
+CONFIG_OS_MEM_SIZE="0x4000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_IMG_ADDRESS="0x000a0000"
+CONFIG_IMG_SIZE="0x360000"
+CONFIG_JUMP_ADDR="0x21000000"
+CONFIG_LINUX_DT=y
+CONFIG_DTIMG_ADDRESS="0x00010000"
+CONFIG_DTIMG_SIZE="0x10000"
+CONFIG_DT_ADDRESS="0x20f00000"
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
diff --git a/board/stamp9g20/board.mk b/board/stamp9g20/board.mk
new file mode 100755
index 0000000..17db06f
--- /dev/null
+++ b/board/stamp9g20/board.mk
@@ -0,0 +1,7 @@
+CPPFLAGS += \
+	-DCONFIG_STAMP9G20 \
+	-mcpu=arm926ej-s
+
+ASFLAGS += \
+	-DCONFIG_STAMP9G20 \
+	-mcpu=arm926ej-s
diff --git a/board/stamp9g20/stamp9g20.c b/board/stamp9g20/stamp9g20.c
new file mode 100755
index 0000000..9b34af2
--- /dev/null
+++ b/board/stamp9g20/stamp9g20.c
@@ -0,0 +1,252 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "common.h"
+#include "hardware.h"
+#include "arch/at91_ccfg.h"
+#include "arch/at91_matrix.h"
+#include "arch/at91_wdt.h"
+#include "arch/at91_rstc.h"
+#include "arch/at91_pmc.h"
+#include "arch/at91_smc.h"
+#include "arch/at91_pio.h"
+#include "arch/at91_sdramc.h"
+#include "gpio.h"
+#include "pmc.h"
+#include "dbgu.h"
+#include "debug.h"
+#include "sdramc.h"
+#include "stamp9g20.h"
+
+unsigned int get_cp15();
+void set_cp15(unsigned int);
+#define I_CACHE (1<<12)
+
+#ifdef CONFIG_USER_HW_INIT
+extern void hw_init_hook(void);
+#endif
+
+#ifdef CONFIG_DEBUG
+static void at91_dbgu_hw_init(void)
+{
+	/* Configure DBGU pin */
+	const struct pio_desc dbgu_pins[] = {
+		{"RXD", AT91C_PIN_PB(14), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"TXD", AT91C_PIN_PB(15), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	pio_configure(dbgu_pins);
+
+	/*  Configure the dbgu pins */
+	writel((1 << AT91C_ID_PIOB), (PMC_PCER + AT91C_BASE_PMC));
+}
+
+static void initialize_dbgu(void)
+{
+	at91_dbgu_hw_init();
+
+	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
+}
+#endif /* #ifdef CONFIG_DEBUG */
+
+#ifdef CONFIG_SDRAM
+static void sdramc_hw_init(void)
+{
+	/* Configure sdramc pins */
+	const struct pio_desc sdramc_pins[] = {
+		{"D16", AT91C_PIN_PC(16), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D17", AT91C_PIN_PC(17), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D18", AT91C_PIN_PC(18), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D19", AT91C_PIN_PC(19), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D20", AT91C_PIN_PC(20), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D21", AT91C_PIN_PC(21), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D22", AT91C_PIN_PC(22), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D23", AT91C_PIN_PC(23), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D24", AT91C_PIN_PC(24), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D25", AT91C_PIN_PC(25), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D26", AT91C_PIN_PC(26), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D27", AT91C_PIN_PC(27), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D28", AT91C_PIN_PC(28), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D29", AT91C_PIN_PC(29), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D30", AT91C_PIN_PC(30), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D31", AT91C_PIN_PC(31), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{(char *) 0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Configure the SDRAMC PINs */
+	writel((1 << AT91C_ID_PIOC), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(sdramc_pins);
+}
+
+static void sdramc_init(void)
+{
+	struct sdramc_register sdramc_config;
+
+#ifdef CONFIG_RAM_128MB
+	sdramc_config.cr = AT91C_SDRAMC_NC_10 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_3
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_32_BITS
+				| AT91C_SDRAMC_TWR_3 | AT91C_SDRAMC_TRC_13
+				| AT91C_SDRAMC_TRP_3 | AT91C_SDRAMC_TRCD_3
+				| AT91C_SDRAMC_TRAS_6 | AT91C_SDRAMC_TXSR_15;
+#else
+	sdramc_config.cr = AT91C_SDRAMC_NC_9 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_3
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_32_BITS
+				| AT91C_SDRAMC_TWR_3 | AT91C_SDRAMC_TRC_8
+				| AT91C_SDRAMC_TRP_3 | AT91C_SDRAMC_TRCD_3
+				| AT91C_SDRAMC_TRAS_6 | AT91C_SDRAMC_TXSR_9;
+#endif
+
+	sdramc_config.tr = (MASTER_CLOCK * 7) / 1000000;
+	sdramc_config.mdr = AT91C_SDRAMC_MD_SDRAM;
+
+	sdramc_hw_init();
+
+	/* Initialize the matrix (memory voltage = 1.8) */
+	writel((readl(AT91C_BASE_CCFG + CCFG_EBICSA))
+		| AT91C_EBI_CS1A_SDRAMC,
+		AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	sdramc_initialize(&sdramc_config, AT91C_BASE_CS1);
+}
+#endif /* #ifdef CONFIG_SDRAM */
+
+#ifdef CONFIG_HW_INIT
+void hw_init(void)
+{
+	unsigned int cp15;
+
+	/* Disable watchdog */
+//	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
+
+	/*
+	 * At this stage the main oscillator is supposed to be enabled
+	 * PCK = MCK = MOSC
+	 */
+	writel(0x00, AT91C_BASE_PMC + PMC_PLLICPR);
+
+	/* Configure PLLA = MOSC * (PLL_MULA + 1) / PLL_DIVA */
+	pmc_cfg_plla(PLLA_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* PCK = PLLA/2 = 3 * MCK */
+	pmc_cfg_mck(MCKR_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Switch MCK on PLLA output */
+	pmc_cfg_mck(MCKR_CSS_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Configure PLLB  */
+	//pmc_cfg_pllb(PLLB_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Enable External Reset */
+	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
+
+	/* Configure the EBI Slave Slot Cycle to 64 */
+	writel((readl((AT91C_BASE_MATRIX + MATRIX_SCFG3)) & ~0xFF) | 0x40,
+		(AT91C_BASE_MATRIX + MATRIX_SCFG3));
+
+	cp15 = get_cp15();
+	cp15 |= I_CACHE;
+	set_cp15(cp15);
+
+#ifdef CONFIG_DEBUG
+	/* Initialize dbgu */
+	initialize_dbgu();
+#endif
+
+#ifdef CONFIG_SDRAM
+	/* Initlialize sdram controller */
+	sdramc_init();
+#endif
+
+#ifdef CONFIG_USER_HW_INIT
+	hw_init_hook();
+#endif
+
+}
+#endif /* #ifdef CONFIG_HW_INIT */
+
+#ifdef CONFIG_NANDFLASH
+void nandflash_hw_init(void)
+{
+	unsigned int reg;
+
+	/* Configure PIOs */
+	const struct pio_desc nand_pins[] = {
+		{"NANDCS",	CONFIG_SYS_NAND_ENABLE_PIN,	1, PIO_PULLUP, PIO_OUTPUT},
+		{(char *)0, 	0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Setup Smart Media, first enable the address range of CS3 in HMATRIX user interface  */
+	reg = readl(AT91C_BASE_CCFG + CCFG_EBICSA);
+	reg |= AT91C_EBI_CS3A_SM;
+
+	writel(reg, AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/* Configure SMC CS3 */
+	writel((AT91C_SMC_NWESETUP_(2)
+		| AT91C_SMC_NCS_WRSETUP_(0)
+		| AT91C_SMC_NRDSETUP_(2)
+		| AT91C_SMC_NCS_RDSETUP_(0)),
+		AT91C_BASE_SMC + SMC_SETUP3);
+
+	writel((AT91C_SMC_NWEPULSE_(4)
+		| AT91C_SMC_NCS_WRPULSE_(4)
+		| AT91C_SMC_NRDPULSE_(4)
+		| AT91C_SMC_NCS_RDPULSE_(4)),
+		AT91C_BASE_SMC + SMC_PULSE3);
+
+	writel((AT91C_SMC_NWECYCLE_(7)
+		|  AT91C_SMC_NRDCYCLE_(7)),
+		AT91C_BASE_SMC + SMC_CYCLE3);
+
+	writel((AT91C_SMC_READMODE
+		| AT91C_SMC_WRITEMODE
+		| AT91C_SMC_NWAITM_NWAIT_DISABLE
+		| AT91C_SMC_DBW_WIDTH_BITS_16
+		| AT91_SMC_TDF_(3)),
+		AT91C_BASE_SMC + SMC_CTRL3);
+
+	/* Configure the PIO controller */
+	pio_configure(nand_pins);
+	writel((1 << AT91C_ID_PIOC), PMC_PCER + AT91C_BASE_PMC);
+}
+
+void nandflash_config_buswidth(unsigned char busw)
+{
+	unsigned long csa;
+
+	csa = readl(AT91C_BASE_SMC + SMC_CTRL3);
+
+	if (busw == 0)
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_8;
+	else
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_16;
+
+	writel(csa, AT91C_BASE_SMC + SMC_CTRL3);
+}
+#endif /* #ifdef CONFIG_NANDFLASH */
+
diff --git a/board/stamp9g20/stamp9g20.h b/board/stamp9g20/stamp9g20.h
new file mode 100755
index 0000000..b6dc667
--- /dev/null
+++ b/board/stamp9g20/stamp9g20.h
@@ -0,0 +1,63 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __STAMP9G20_H__
+#define __STAMP9G20_H__
+
+/*
+ * PMC Setting
+ *
+ * The main oscillator is enabled as soon as possible in the c_startup
+ * and MCK is switched on the main oscillator.
+ * PLL initialization is done later in the hw_init() function
+ */
+#define MASTER_CLOCK		132096000
+#define PLL_LOCK_TIMEOUT	1000000
+
+#define PLLA_SETTINGS		0x202A3F01
+#define PLLB_SETTINGS		0x10193F05
+
+/* Switch MCK on PLLA output PCK = PLLA/2 = 3 * MCK */
+#define MCKR_SETTINGS		0x1300
+#define MCKR_CSS_SETTINGS	(AT91C_PMC_CSS_PLLA_CLK | MCKR_SETTINGS)
+
+/*
+ * NandFlash Settings
+ */
+#define CONFIG_SYS_NAND_BASE		AT91C_BASE_CS3
+#define CONFIG_SYS_NAND_MASK_ALE	(1 << 21)
+#define CONFIG_SYS_NAND_MASK_CLE	(1 << 22)
+
+#define CONFIG_SYS_NAND_ENABLE_PIN	AT91C_PIN_PC(14)
+
+/* function */
+extern void hw_init(void);
+
+extern void nandflash_hw_init(void);
+extern void nandflash_config_buswidth(unsigned char busw);
+
+#endif	/* #ifndef __STAMP9G20_H__ */
diff --git a/board/stamp9g20/stamp9g20nf_uboot_128mb_defconfig b/board/stamp9g20/stamp9g20nf_uboot_128mb_defconfig
new file mode 100644
index 0000000..e929d1e
--- /dev/null
+++ b/board/stamp9g20/stamp9g20nf_uboot_128mb_defconfig
@@ -0,0 +1,105 @@
+#
+# Automatically generated make config: don't edit
+# Thu Feb  7 14:52:50 2013
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="stamp9g20"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+CONFIG_STAMP9G20=y
+# CONFIG_STAMP9G45 is not set
+# CONFIG_NANOSG20 is not set
+# CONFIG_PICOSG20 is not set
+CONFIG_CHIP="AT91SAM9G20"
+CONFIG_BOARD="stamp9g20"
+CONFIG_MACH_TYPE="1824"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x304000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+CONFIG_SDRAM=y
+# CONFIG_SDDRC is not set
+# CONFIG_DDR2 is not set
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+# ALLOW_SDCARD is not set
+# ALLOW_HSMCI is not set
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+# CONFIG_SDCARD_HS is not set
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=4
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+# ALLOW_NANDFLASH_RECOVERY is not set
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+CONFIG_LOAD_UBOOT=y
+# CONFIG_LOAD_LINUX is not set
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00040000"
+CONFIG_JUMP_ADDR="0x23F00000"
+
+#
+# U-Boot Image Storage Setup
+#
+CONFIG_IMAGE_NAME="uboot"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
diff --git a/board/stamp9g20/stamp9g20nf_uboot_64mb_defconfig b/board/stamp9g20/stamp9g20nf_uboot_64mb_defconfig
new file mode 100644
index 0000000..10e8bfc
--- /dev/null
+++ b/board/stamp9g20/stamp9g20nf_uboot_64mb_defconfig
@@ -0,0 +1,105 @@
+#
+# Automatically generated make config: don't edit
+# Thu Feb  7 14:50:58 2013
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="stamp9g20"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+CONFIG_STAMP9G20=y
+# CONFIG_STAMP9G45 is not set
+# CONFIG_NANOSG20 is not set
+# CONFIG_PICOSG20 is not set
+CONFIG_CHIP="AT91SAM9G20"
+CONFIG_BOARD="stamp9g20"
+CONFIG_MACH_TYPE="1824"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x304000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+CONFIG_SDRAM=y
+# CONFIG_SDDRC is not set
+# CONFIG_DDR2 is not set
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+# ALLOW_SDCARD is not set
+# ALLOW_HSMCI is not set
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+CONFIG_RAM_64MB=y
+# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+# CONFIG_SDCARD_HS is not set
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=4
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+# ALLOW_NANDFLASH_RECOVERY is not set
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+CONFIG_LOAD_UBOOT=y
+# CONFIG_LOAD_LINUX is not set
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+CONFIG_IMG_ADDRESS="0x00020000"
+CONFIG_IMG_SIZE="0x00040000"
+CONFIG_JUMP_ADDR="0x23F00000"
+
+#
+# U-Boot Image Storage Setup
+#
+CONFIG_IMAGE_NAME="uboot"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
diff --git a/board/stamp9g45/board.mk b/board/stamp9g45/board.mk
new file mode 100755
index 0000000..c0a7fca
--- /dev/null
+++ b/board/stamp9g45/board.mk
@@ -0,0 +1,7 @@
+CPPFLAGS += \
+	-DCONFIG_STAMP9G45 \
+	-mcpu=arm926ej-s
+
+ASFLAGS += \
+	-DCONFIG_STAMP9G45 \
+	-mcpu=arm926ej-s
diff --git a/board/stamp9g45/stamp9g45.c b/board/stamp9g45/stamp9g45.c
new file mode 100755
index 0000000..8d2f1c3
--- /dev/null
+++ b/board/stamp9g45/stamp9g45.c
@@ -0,0 +1,277 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "common.h"
+#include "hardware.h"
+#include "arch/at91_ccfg.h"
+#include "arch/at91_wdt.h"
+#include "arch/at91_rstc.h"
+#include "arch/at91_pmc.h"
+#include "arch/at91_smc.h"
+#include "arch/at91_pio.h"
+#include "arch/at91_ddrsdrc.h"
+#include "gpio.h"
+#include "pmc.h"
+#include "dbgu.h"
+#include "debug.h"
+#include "ddramc.h"
+#include "slowclk.h"
+#include "stamp9g45.h"
+
+unsigned int get_cp15();
+void set_cp15(unsigned int);
+#define I_CACHE (1<<12)
+
+#ifdef CONFIG_USER_HW_INIT
+extern void hw_init_hook(void);
+#endif
+
+#ifdef CONFIG_DEBUG
+static void at91_dbgu_hw_init(void)
+{
+	/* Configure DBGU pin */
+	const struct pio_desc dbgu_pins[] = {
+		{"RXD", AT91C_PIN_PB(12), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"TXD", AT91C_PIN_PB(13), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Configure the dbgu pins */
+	pio_configure(dbgu_pins);
+	writel((1 << AT91C_ID_PIOB), (PMC_PCER + AT91C_BASE_PMC));
+}
+
+static void initialize_dbgu(void)
+{
+	at91_dbgu_hw_init();
+	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
+}
+#endif /* #ifdef CONFIG_DEBUG */
+
+#ifdef CONFIG_DDR2
+#if defined(CONFIG_RAM_256MB) || defined (CONFIG_RAM_512MB)
+static void ddramc_reg_config(struct ddramc_register *ddramc_config)
+{
+	ddramc_config->mdr = (AT91C_DDRC2_DBW_16_BITS
+			| AT91C_DDRC2_MD_LP_DDR_SDRAM);
+
+	ddramc_config->cr = (AT91C_DDRC2_NC_DDR11_SDR10
+			| AT91C_DDRC2_NR_14
+			| AT91C_DDRC2_CAS_3
+			| AT91C_DDRC2_DLL_RESET_DISABLED);
+
+	ddramc_config->rtr = 0x410;
+
+	ddramc_config->t0pr = (AT91C_DDRC2_TRAS_6
+			| AT91C_DDRC2_TRCD_3
+			| AT91C_DDRC2_TWR_2
+			| AT91C_DDRC2_TRC_9
+			| AT91C_DDRC2_TRP_3
+			| AT91C_DDRC2_TRRD_2
+			| AT91C_DDRC2_TWTR_0
+			| AT91C_DDRC2_TMRD_2);
+
+	ddramc_config->t1pr = (AT91C_DDRC2_TXP_2
+			| 16 << 16
+			| 16 << 8
+			| AT91C_DDRC2_TRFC_10 << 0);
+
+	ddramc_config->t2pr = (AT91C_DDRC2_TRTP_6);
+}
+#else
+static void ddramc_reg_config(struct ddramc_register *ddramc_config)
+{
+	ddramc_config->mdr = (AT91C_DDRC2_DBW_16_BITS
+			| AT91C_DDRC2_MD_LP_DDR_SDRAM);
+
+	ddramc_config->cr = (AT91C_DDRC2_NC_DDR10_SDR9
+			| AT91C_DDRC2_NR_14
+			| AT91C_DDRC2_CAS_3
+			| AT91C_DDRC2_DLL_RESET_DISABLED);
+
+	ddramc_config->rtr = 0x3b6;
+
+	ddramc_config->t0pr = (AT91C_DDRC2_TRAS_6
+			| AT91C_DDRC2_TRCD_3
+			| AT91C_DDRC2_TWR_2
+			| AT91C_DDRC2_TRC_10
+			| AT91C_DDRC2_TRP_3
+			| AT91C_DDRC2_TRRD_2
+			| AT91C_DDRC2_TWTR_1
+			| AT91C_DDRC2_TMRD_1);
+
+	ddramc_config->t1pr = (AT91C_DDRC2_TXP_2
+			| 18 << 16
+			| 18 << 8
+			| AT91C_DDRC2_TRFC_15 << 0);
+
+	ddramc_config->t2pr = (AT91C_DDRC2_TRTP_6);
+}
+#endif
+
+static void ddramc_init(void)
+{
+	unsigned long csa;
+	struct ddramc_register ddramc_reg;
+
+	ddramc_reg_config(&ddramc_reg);
+
+	/* ENABLE DDR2 clock */
+	writel(AT91C_PMC_DDR, AT91C_BASE_PMC + PMC_SCER);
+
+	/* Chip select 1 is for DDR2/SDRAM */
+	csa = readl(AT91C_BASE_CCFG + CCFG_EBICSA);
+	csa |= AT91C_EBI_CS1A_SDRAMC;
+	csa &= ~AT91C_VDDIOM_SEL_33V;
+	writel(csa, AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/* DDRAM2 Controller initialize */
+	ddram_initialize(AT91C_BASE_DDRSDRC, AT91C_DDRAM_BASE_ADDR, &ddramc_reg);
+	/*
+	* EBI IO in 1.8V mode
+	*/
+	writel(readl(AT91C_BASE_CCFG + CCFG_EBICSA) & ~(1 << 16),
+		AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/*
+	* EBI DDRAM controller
+	*/
+	ddram_initialize(AT91C_BASE_DDRSDRC1, AT91C_BASE_CS1, &ddramc_reg);
+}
+#endif /* #ifdef CONFIG_DDR2 */
+
+#ifdef CONFIG_HW_INIT
+void hw_init(void)
+{
+	unsigned int cp15;
+
+	/* Disable watchdog */
+	/* writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDTC + WDTC_MR); */
+
+	/* At this stage the main oscillator
+	 * is supposed to be enabled PCK = MCK = MOSC */
+	writel(0x00, AT91C_BASE_PMC + PMC_PLLICPR);
+
+	/* Configure PLLA = MOSC * (PLL_MULA + 1) / PLL_DIVA */
+	pmc_cfg_plla(PLLA_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* PCK = PLLA/2 = 3 * MCK */
+	pmc_cfg_mck(BOARD_PRESCALER, PLL_LOCK_TIMEOUT);
+
+	/* Switch MCK on PLLA output */
+	pmc_cfg_mck(0x1302, PLL_LOCK_TIMEOUT);
+
+	/* Enable External Reset */
+	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
+
+	cp15 = get_cp15();
+	cp15 |= I_CACHE;
+	set_cp15(cp15);
+
+#ifdef CONFIG_SCLK
+	slowclk_enable_osc32();
+#endif
+
+#ifdef CONFIG_DEBUG
+	/* Initialize dbgu */
+	initialize_dbgu();
+#endif
+
+#ifdef CONFIG_DDR2
+	/* Initialize DDRAM Controller */
+	ddramc_init();
+#endif
+
+#ifdef CONFIG_USER_HW_INIT
+	hw_init_hook();
+#endif
+}
+#endif /* #ifdef CONFIG_HW_INIT */
+
+#ifdef CONFIG_NANDFLASH
+void nandflash_hw_init(void)
+{
+	unsigned int reg;
+
+	/* Configure PIOs */
+	const struct pio_desc nand_pins[] = {
+		{"NANDCS",	CONFIG_SYS_NAND_ENABLE_PIN,	1, PIO_PULLUP, PIO_OUTPUT},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Setup Smart Media, first enable the address range of CS3
+	 * in HMATRIX user interface
+	* EBI IO in 1.8V mode */
+	reg = readl(AT91C_BASE_CCFG + CCFG_EBICSA);
+	reg |= AT91C_EBI_CS3A_SM;
+	reg &= ~AT91C_VDDIOM_SEL_33V;
+	writel(reg, AT91C_BASE_CCFG + CCFG_EBICSA);
+
+	/* Configure SMC CS3 */
+	writel((AT91C_SMC_NWESETUP_(2)
+		| AT91C_SMC_NCS_WRSETUP_(0)
+		| AT91C_SMC_NRDSETUP_(2)
+		| AT91C_SMC_NCS_RDSETUP_(0)),
+		AT91C_BASE_SMC + SMC_SETUP3);
+
+	writel((AT91C_SMC_NWEPULSE_(4)
+		| AT91C_SMC_NCS_WRPULSE_(4)
+		| AT91C_SMC_NRDPULSE_(4)
+		| AT91C_SMC_NCS_RDPULSE_(4)),
+		AT91C_BASE_SMC + SMC_PULSE3);
+
+	writel((AT91C_SMC_NWECYCLE_(7)
+		|  AT91C_SMC_NRDCYCLE_(7)),
+		AT91C_BASE_SMC + SMC_CYCLE3);
+
+	writel((AT91C_SMC_READMODE
+		| AT91C_SMC_WRITEMODE
+		| AT91C_SMC_NWAITM_NWAIT_DISABLE
+		| AT91C_SMC_DBW_WIDTH_BITS_8
+		| AT91_SMC_TDF_(3)),
+		AT91C_BASE_SMC + SMC_CTRL3);
+
+	/* Configure the PIO controll */
+	writel((1 << AT91C_ID_PIOC), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(nand_pins);
+
+}
+
+void nandflash_config_buswidth(unsigned char busw)
+{
+	unsigned long csa;
+
+	csa = readl(AT91C_BASE_SMC + SMC_CTRL3);
+
+	if (busw == 0)
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_8;
+	else
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_16;
+
+	writel(csa, AT91C_BASE_SMC + SMC_CTRL3);
+}
+#endif /* #ifdef CONFIG_NANDFLASH */
diff --git a/board/stamp9g45/stamp9g45.h b/board/stamp9g45/stamp9g45.h
new file mode 100755
index 0000000..e1e49d3
--- /dev/null
+++ b/board/stamp9g45/stamp9g45.h
@@ -0,0 +1,79 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __STAMP9G45_H__
+#define __STAMP9G45_H__
+
+/*
+ * PMC Settings
+ *
+ * The main oscillator is enabled as soon as possible in the c_startup
+ * and MCK is switched on the main oscillator.
+ * PLL initialization is done later in the hw_init() function
+ */
+#define MASTER_CLOCK		(132096000)
+#define PLL_LOCK_TIMEOUT	1000000
+
+#define BOARD_MAINOSC		12000000
+#define BOARD_MCK		((unsigned long)((BOARD_MAINOSC / 3 / 2 / 3) * 200))
+#define BOARD_OSCOUNT		(AT91C_CKGR_OSCOUNT & (64 << 8))
+#define BOARD_CKGR_PLLA		(AT91C_CKGR_SRCA | AT91C_CKGR_OUTA_0)
+#define BOARD_PLLACOUNT		(0x3F << 8)
+#define BOARD_MULA		(AT91C_CKGR_MULA & (199 << 16))
+#define BOARD_DIVA		(AT91C_CKGR_DIVA & 3)
+#define BOARD_PRESCALER		(0x00001301)
+
+#define PLLA_SETTINGS		(BOARD_CKGR_PLLA \
+				| BOARD_PLLACOUNT \
+				| BOARD_MULA \
+				| BOARD_DIVA)
+
+/* #define PLLA_SETTINGS 0x202A3F01 */
+#define PLLUTMI
+#define PLLUTMI_SETTINGS	0x10193F05
+
+/* Switch MCK on PLLA output PCK = PLLA/2 = 3 * MCK */
+#define MCKR_CSS_SETTINGS	0x1302
+
+/* DDRAM Controller */
+#define AT91C_BASE_DDRSDRC	AT91C_BASE_DDRSDRC0
+#define AT91C_DDRAM_BASE_ADDR	AT91C_BASE_CS6
+
+#define CONFIG_SYS_NAND_BASE		AT91C_BASE_CS3
+#define CONFIG_SYS_NAND_MASK_ALE	(1 << 21)
+#define CONFIG_SYS_NAND_MASK_CLE	(1 << 22)
+
+#define CONFIG_SYS_NAND_ENABLE_PIN	AT91C_PIN_PC(14)
+
+/* function */
+extern void hw_init(void);
+
+extern void nandflash_hw_init(void);
+extern void nandflash_config_buswidth(unsigned char busw);
+extern unsigned int nandflash_get_ready_pin(void);
+
+#endif /* __STAMP9G45_H__ */
diff --git a/board/stamp9g45/stamp9g45nf_linux_128mb_defconfig b/board/stamp9g45/stamp9g45nf_linux_128mb_defconfig
new file mode 100644
index 0000000..02e58e8
--- /dev/null
+++ b/board/stamp9g45/stamp9g45nf_linux_128mb_defconfig
@@ -0,0 +1,110 @@
+#
+# Automatically generated make config: don't edit
+# Thu Feb  7 14:53:15 2013
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="stamp9g45"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+# CONFIG_STAMP9G20 is not set
+CONFIG_STAMP9G45=y
+# CONFIG_NANOSG20 is not set
+# CONFIG_PICOSG20 is not set
+CONFIG_CHIP="AT91SAM9G45"
+CONFIG_BOARD="stamp9g45"
+CONFIG_MACH_TYPE="2761"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x30A000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+# CONFIG_SDRAM is not set
+# CONFIG_SDDRC is not set
+CONFIG_DDR2=y
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+# ALLOW_SDCARD is not set
+# ALLOW_HSMCI is not set
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+CONFIG_RAM_128MB=y
+# CONFIG_RAM_256MB is not set
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+# CONFIG_SDCARD_HS is not set
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=4
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+# ALLOW_NANDFLASH_RECOVERY is not set
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x70000000"
+CONFIG_OS_MEM_SIZE="0x08000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_IMG_ADDRESS="0x00060000"
+CONFIG_IMG_SIZE="0x3a0000"
+CONFIG_JUMP_ADDR="0x72000000"
+# CONFIG_LINUX_DT is not set
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
+CONFIG_SCLK=y
diff --git a/board/stamp9g45/stamp9g45nf_linux_256mb_defconfig b/board/stamp9g45/stamp9g45nf_linux_256mb_defconfig
new file mode 100644
index 0000000..6d0a5a7
--- /dev/null
+++ b/board/stamp9g45/stamp9g45nf_linux_256mb_defconfig
@@ -0,0 +1,110 @@
+#
+# Automatically generated make config: don't edit
+# Thu Feb  7 14:53:46 2013
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="stamp9g45"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+# CONFIG_STAMP9G20 is not set
+CONFIG_STAMP9G45=y
+# CONFIG_NANOSG20 is not set
+# CONFIG_PICOSG20 is not set
+CONFIG_CHIP="AT91SAM9G45"
+CONFIG_BOARD="stamp9g45"
+CONFIG_MACH_TYPE="2761"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x30A000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+# CONFIG_SDRAM is not set
+# CONFIG_SDDRC is not set
+CONFIG_DDR2=y
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+# ALLOW_SDCARD is not set
+# ALLOW_HSMCI is not set
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+# CONFIG_RAM_128MB is not set
+CONFIG_RAM_256MB=y
+# CONFIG_RAM_512MB is not set
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+# CONFIG_SDCARD_HS is not set
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=4
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+# ALLOW_NANDFLASH_RECOVERY is not set
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x70000000"
+CONFIG_OS_MEM_SIZE="0x10000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_IMG_ADDRESS="0x00060000"
+CONFIG_IMG_SIZE="0x3a0000"
+CONFIG_JUMP_ADDR="0x72000000"
+# CONFIG_LINUX_DT is not set
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
+CONFIG_SCLK=y
diff --git a/board/stamp9g45/stamp9g45nf_linux_512mb_defconfig b/board/stamp9g45/stamp9g45nf_linux_512mb_defconfig
new file mode 100644
index 0000000..edd1f5b
--- /dev/null
+++ b/board/stamp9g45/stamp9g45nf_linux_512mb_defconfig
@@ -0,0 +1,110 @@
+#
+# Automatically generated make config: don't edit
+# Thu Feb  7 14:54:02 2013
+#
+HAVE_DOT_CONFIG=y
+CONFIG_BOARDNAME="stamp9g45"
+# CONFIG_AT91SAM9260EK is not set
+# CONFIG_AT91SAM9261EK is not set
+# CONFIG_AT91SAM9263EK is not set
+# CONFIG_AT91SAM9RLEK is not set
+# CONFIG_AT91SAM9XEEK is not set
+# CONFIG_AT91SAM9G10EK is not set
+# CONFIG_AT91SAM9G20EK is not set
+# CONFIG_AT91SAM9M10G45EK is not set
+# CONFIG_AT91SAM9X5EK is not set
+# CONFIG_AT91SAM9N12EK is not set
+# CONFIG_AT91SAMA5D3XEK is not set
+# CONFIG_STAMP9G20 is not set
+CONFIG_STAMP9G45=y
+# CONFIG_NANOSG20 is not set
+# CONFIG_PICOSG20 is not set
+CONFIG_CHIP="AT91SAM9G45"
+CONFIG_BOARD="stamp9g45"
+CONFIG_MACH_TYPE="2761"
+CONFIG_LINK_ADDR="0x000000"
+CONFIG_TOP_OF_MEMORY="0x30A000"
+# CONFIG_CRYSTAL_12_000MHZ is not set
+# CONFIG_CRYSTAL_16_000MHZ is not set
+# CONFIG_CRYSTAL_16_36766MHZ is not set
+CONFIG_CRYSTAL_18_432MHZ=y
+ALLOW_CRYSTAL_18_432MHZ=y
+CONFIG_CRYSTAL="CRYSTAL_18_432MHZ"
+# CONFIG_CPU_CLK_166MHZ is not set
+# CONFIG_CPU_CLK_180MHZ is not set
+# CONFIG_CPU_CLK_200MHZ is not set
+# CONFIG_CPU_CLK_240MHZ is not set
+# CONFIG_CPU_CLK_266MHZ is not set
+CONFIG_CPU_CLK_400MHZ=y
+# CONFIG_CPU_CLK_533MHZ is not set
+ALLOW_CPU_CLK_400MHZ=y
+# DISABLE_CPU_CLK_240MHZ is not set
+# CONFIG_BUS_SPEED_83MHZ is not set
+# CONFIG_BUS_SPEED_90MHZ is not set
+# CONFIG_BUS_SPEED_100MHZ is not set
+CONFIG_BUS_SPEED_133MHZ=y
+# ALLOW_PIO3 is not set
+# CPU_HAS_PMECC is not set
+
+#
+# Memory selection
+#
+# CONFIG_SDRAM is not set
+# CONFIG_SDDRC is not set
+CONFIG_DDR2=y
+# ALLOW_DATAFLASH is not set
+# ALLOW_FLASH is not set
+ALLOW_NANDFLASH=y
+# ALLOW_SDCARD is not set
+# ALLOW_HSMCI is not set
+# ALLOW_PSRAM is not set
+# ALLOW_SDRAM_16BIT is not set
+# CONFIG_RAM_32MB is not set
+# CONFIG_RAM_64MB is not set
+# CONFIG_RAM_128MB is not set
+# CONFIG_RAM_256MB is not set
+CONFIG_RAM_512MB=y
+# CONFIG_DATAFLASH is not set
+# CONFIG_FLASH is not set
+CONFIG_NANDFLASH=y
+# CONFIG_SDCARD is not set
+CONFIG_MEMORY="nandflash"
+# CONFIG_SDCARD_HS is not set
+
+#
+# NAND Flash configuration
+#
+CONFIG_ENABLE_SW_ECC=y
+CONFIG_ENABLE_SW_ECC_BCH=y
+CONFIG_SW_ECC_BCH_BLOCKSIZE=512
+CONFIG_SW_ECC_BCH_BITS=8
+# CONFIG_NANDFLASH_SMALL_BLOCKS is not set
+# ALLOW_NANDFLASH_RECOVERY is not set
+CONFIG_BOOTSTRAP_MAXSIZE="23000"
+CONFIG_PROJECT="nandflash"
+# CONFIG_LOAD_UBOOT is not set
+CONFIG_LOAD_LINUX=y
+# CONFIG_LOAD_1MB is not set
+# CONFIG_LOAD_4MB is not set
+# CONFIG_LOAD_64KB is not set
+
+#
+# Linux Image Storage Setup
+#
+CONFIG_OS_MEM_BANK="0x70000000"
+CONFIG_OS_MEM_SIZE="0x10000000"
+CONFIG_LINUX_KERNEL_ARG_STRING=""
+CONFIG_IMG_ADDRESS="0x00060000"
+CONFIG_IMG_SIZE="0x3a0000"
+CONFIG_JUMP_ADDR="0x72000000"
+# CONFIG_LINUX_DT is not set
+CONFIG_IMAGE_NAME="linux"
+# CONFIG_LONG_TEST is not set
+CONFIG_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_LOUD is not set
+# CONFIG_DEBUG_VERY_LOUD is not set
+CONFIG_HW_INIT=y
+# CONFIG_USER_HW_INIT is not set
+CONFIG_THUMB=y
+CONFIG_SCLK=y
diff --git a/config/.gitignore b/config/.gitignore
old mode 100644
new mode 100755
diff --git a/config/Makefile b/config/Makefile
old mode 100644
new mode 100755
diff --git a/config/Makefile.kconfig b/config/Makefile.kconfig
old mode 100644
new mode 100755
diff --git a/config/POTFILES.in b/config/POTFILES.in
old mode 100644
new mode 100755
diff --git a/config/README.at91bootstrap b/config/README.at91bootstrap
old mode 100644
new mode 100755
diff --git a/config/conf.c b/config/conf.c
old mode 100644
new mode 100755
diff --git a/config/confdata.c b/config/confdata.c
old mode 100644
new mode 100755
diff --git a/config/expr.c b/config/expr.c
old mode 100644
new mode 100755
diff --git a/config/expr.h b/config/expr.h
old mode 100644
new mode 100755
diff --git a/config/foo.h b/config/foo.h
old mode 100644
new mode 100755
diff --git a/config/gconf.c b/config/gconf.c
old mode 100644
new mode 100755
diff --git a/config/gconf.glade b/config/gconf.glade
old mode 100644
new mode 100755
diff --git a/config/images.c b/config/images.c
old mode 100644
new mode 100755
diff --git a/config/kconfig-language.txt b/config/kconfig-language.txt
old mode 100644
new mode 100755
diff --git a/config/kconfig-to-at91bootstrap.patch b/config/kconfig-to-at91bootstrap.patch
old mode 100644
new mode 100755
diff --git a/config/kconfig_load.c b/config/kconfig_load.c
old mode 100644
new mode 100755
diff --git a/config/kxgettext.c b/config/kxgettext.c
old mode 100644
new mode 100755
diff --git a/config/lex.zconf.c_shipped b/config/lex.zconf.c_shipped
old mode 100644
new mode 100755
diff --git a/config/lkc.h b/config/lkc.h
old mode 100644
new mode 100755
diff --git a/config/lkc_proto.h b/config/lkc_proto.h
old mode 100644
new mode 100755
diff --git a/config/lxdialog/.gitignore b/config/lxdialog/.gitignore
old mode 100644
new mode 100755
diff --git a/config/lxdialog/BIG.FAT.WARNING b/config/lxdialog/BIG.FAT.WARNING
old mode 100644
new mode 100755
diff --git a/config/lxdialog/checklist.c b/config/lxdialog/checklist.c
old mode 100644
new mode 100755
diff --git a/config/lxdialog/dialog.h b/config/lxdialog/dialog.h
old mode 100644
new mode 100755
diff --git a/config/lxdialog/inputbox.c b/config/lxdialog/inputbox.c
old mode 100644
new mode 100755
diff --git a/config/lxdialog/menubox.c b/config/lxdialog/menubox.c
old mode 100644
new mode 100755
diff --git a/config/lxdialog/textbox.c b/config/lxdialog/textbox.c
old mode 100644
new mode 100755
diff --git a/config/lxdialog/util.c b/config/lxdialog/util.c
old mode 100644
new mode 100755
diff --git a/config/lxdialog/yesno.c b/config/lxdialog/yesno.c
old mode 100644
new mode 100755
diff --git a/config/mconf.c b/config/mconf.c
old mode 100644
new mode 100755
diff --git a/config/menu.c b/config/menu.c
old mode 100644
new mode 100755
diff --git a/config/qconf.cc b/config/qconf.cc
old mode 100644
new mode 100755
diff --git a/config/qconf.h b/config/qconf.h
old mode 100644
new mode 100755
diff --git a/config/streamline_config.pl b/config/streamline_config.pl
old mode 100644
new mode 100755
diff --git a/config/symbol.c b/config/symbol.c
old mode 100644
new mode 100755
diff --git a/config/util.c b/config/util.c
old mode 100644
new mode 100755
diff --git a/config/zconf.gperf b/config/zconf.gperf
old mode 100644
new mode 100755
diff --git a/config/zconf.hash.c_shipped b/config/zconf.hash.c_shipped
old mode 100644
new mode 100755
diff --git a/config/zconf.l b/config/zconf.l
old mode 100644
new mode 100755
diff --git a/config/zconf.tab.c_shipped b/config/zconf.tab.c_shipped
old mode 100644
new mode 100755
diff --git a/config/zconf.y b/config/zconf.y
old mode 100644
new mode 100755
diff --git a/crt0_gnu.S b/crt0_gnu.S
old mode 100644
new mode 100755
index 87b5ea0..ce6efe2
--- a/crt0_gnu.S
+++ b/crt0_gnu.S
@@ -49,7 +49,7 @@ _exception_vectors:
 	b 	swi_vector   	/* Software Interrupt */
 	b 	pabt_vector  	/* Prefetch Abort */
 	b 	dabt_vector  	/* Data Abort */
-.word		_edata		/* Size of the binary for ROMCode loading */
+.word		_edata		/* Size of the image for SAM-BA */
 	b 	irq_vector	/* IRQ : read the AIC */
 	b 	fiq_vector      /* FIQ */
 
diff --git a/driver/Config.in.dataflash b/driver/Config.in.dataflash
old mode 100644
new mode 100755
diff --git a/driver/Config.in.driver b/driver/Config.in.driver
old mode 100644
new mode 100755
index fd6caa7..6b5582e
--- a/driver/Config.in.driver
+++ b/driver/Config.in.driver
@@ -11,12 +11,4 @@ config CPU_HAS_PMECC
 	bool
 	default n
 
-config CONFIG_LOAD_ONE_WIRE
-	bool
-	default n
-
-config CONFIG_MMC_SUPPORT
-	bool
-	default n
-
 source "driver/Config.in.memory"
diff --git a/driver/Config.in.memory b/driver/Config.in.memory
old mode 100644
new mode 100755
index 5bbb861..2ace912
--- a/driver/Config.in.memory
+++ b/driver/Config.in.memory
@@ -49,6 +49,7 @@ config	ALLOW_SDRAM_16BIT
 choice
 	prompt "RAM size"
 	depends on CONFIG_SDRAM || CONFIG_SDDRC || CONFIG_DDR2
+	default CONFIG_RAM_128MB if CONFIG_STAMP9G45
 	default CONFIG_RAM_64MB
 
 config	CONFIG_RAM_32MB
@@ -123,10 +124,9 @@ source "driver/Config.in.nandflash"
 
 config CONFIG_BOOTSTRAP_MAXSIZE
 	string
-	default "4096" if CONFIG_AT91SAM9260EK
-	default "8192" if CONFIG_AT91SAM9G10EK && CONFIG_SDCARD
-	default "12288" if CONFIG_AT91SAM9G10EK && !CONFIG_SDCARD
-	default "65536"	if CONFIG_AT91SAMA5D3XEK
+	default "4096"  if CONFIG_AT91SAM9260EK
+	default "8192"  if CONFIG_AT91SAM9G10EK && CONFIG_SDCARD
+	default "12288"  if CONFIG_AT91SAM9G10EK && !CONFIG_SDCARD
 	default "23000"
 
 endmenu
diff --git a/driver/Config.in.nandflash b/driver/Config.in.nandflash
old mode 100644
new mode 100755
index a49401b..97fca9f
--- a/driver/Config.in.nandflash
+++ b/driver/Config.in.nandflash
@@ -10,6 +10,23 @@ config	CONFIG_ENABLE_SW_ECC
 	bool "Support NAND flash software ECC"
 	depends on CONFIG_NANDFLASH && CPU_HAS_PMECC
 
+config	CONFIG_ENABLE_SW_ECC_BCH
+	bool "Enable BCH algorithm"
+	default y
+	depends on CONFIG_ENABLE_SW_ECC
+	help
+	  Stronger ECC algorithm supporting multi-bit corrections
+
+config	CONFIG_SW_ECC_BCH_BLOCKSIZE
+	int "BCH block size"
+	default 512
+	depends on CONFIG_ENABLE_SW_ECC_BCH
+
+config	CONFIG_SW_ECC_BCH_BITS
+	int "Number of correctable bits per BCH block"
+	default 4
+	depends on CONFIG_ENABLE_SW_ECC_BCH
+
 config CONFIG_NANDFLASH_SMALL_BLOCKS
 	bool "Use NAND flash with small blocks"
 	default n
diff --git a/driver/at91_mci.c b/driver/at91_mci.c
old mode 100644
new mode 100755
index f6f412f..8dc6b67
--- a/driver/at91_mci.c
+++ b/driver/at91_mci.c
@@ -1,7 +1,7 @@
 /* ----------------------------------------------------------------------------
  *         ATMEL Microcontroller Software Support
  * ----------------------------------------------------------------------------
- * Copyright (c) 2012, Atmel Corporation
+ * Copyright (c) 2008, Atmel Corporation
  *
  * All rights reserved.
  *
@@ -26,288 +26,1147 @@
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "common.h"
+#include "string.h"
 #include "hardware.h"
 #include "board.h"
 #include "arch/at91_mci.h"
+#include "mmc.h"
 
 #include "debug.h"
 
-inline unsigned int mci_readl(unsigned int reg)
-{
-	return readl((void *)CONFIG_SYS_BASE_MCI + reg);
-}
+/* command definition */
+#define MMC_CMD_GO_IDLE_STATE		0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID		2
+#define MMC_CMD_SET_RELATIVE_ADDR	3
+#define MMC_CMD_SET_DSR			4
+#define MMC_CMD_SWITCH			6
+#define MMC_CMD_SELECT_CARD		7
+#define MMC_CMD_SEND_EXT_CSD		8
+#define MMC_CMD_SEND_CSD		9
+#define MMC_CMD_SEND_CID		10
+#define MMC_CMD_STOP_TRANSMISSION	12
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_SINGLE_BLOCK	17
+#define MMC_CMD_READ_MULTIPLE_BLOCK	18
+#define MMC_CMD_WRITE_SINGLE_BLOCK	24
+#define MMC_CMD_WRITE_MULTIPLE_BLOCK	25
+#define MMC_CMD_APP_CMD			55
+#define MMC_CMD_SPI_READ_OCR		58
+#define MMC_CMD_SPI_CRC_ON_OFF		59
 
-inline void mci_writel(unsigned int reg, unsigned int value)
-{
-	writel((value), (void *)CONFIG_SYS_BASE_MCI + reg);
-}
+#define SD_CMD_SEND_RELATIVE_ADDR	3
+#define SD_CMD_SWITCH_FUNC		6
+#define SD_CMD_SEND_IF_COND		8
+
+#define SD_CMD_APP_SET_BUS_WIDTH	6
+#define SD_CMD_APP_SEND_OP_COND		41
+#define SD_CMD_APP_SEND_SCR		51
+#define SD_CMD_APP_SD_STATUS		13
+
+#define CONFIG_SYS_MMC_DEFAULT_CLK	1000000
+#define CONFIG_SYS_MMC_DEFAULT_BLKLEN	512
+
+#define MCI_SUPPORT_MAX_BLKS 65535
 
-static int at91_mci_set_clock_blklen(unsigned int clock,
-					unsigned int blklen)
+/* function macro */
+#define mci_readl(reg)					\
+	readl((void *)CONFIG_SYS_BASE_MCI + reg)
+
+#define mci_writel(reg, value)				\
+	writel((value), (void *)CONFIG_SYS_BASE_MCI + reg)
+
+/* Setup for MCI Clock and Block Size */
+static void mci_set_mode(unsigned int clock, unsigned int blklen)
 {
-	unsigned int clkdiv;
+	unsigned int main_clock = MASTER_CLOCK; 
+	unsigned int clkdiv = 255;
 	unsigned int reg;
 
-	clkdiv = (MASTER_CLOCK + clock) / clock;
+	if (clock > 0)
+		clkdiv = (main_clock + clock) / clock;
 
 	blklen &= 0xfffc;
 
+#if defined(AT91SAM9X5) || defined(AT91SAM9N12) || defined(AT91SAMA5D3X)
+	/* set blklen in Block Register */
 	reg = mci_readl(MCI_BLKR);
-	reg &= ~(((0x1 << 16) - 1) << 16);
+	reg &= ~(((0x1 << 16) -1) << 16);
 	reg |= (blklen << 16);
 	mci_writel(MCI_BLKR, reg);
 
-#if defined(AT91SAM9X5) || defined(AT91SAM9N12) || defined(AT91SAMA5D3X)
+	/* set Mode Register */
+	reg = AT91C_MCI_RDPROOF_ENABLE;
+	reg |= AT91C_MCI_WRPROOF_ENABLE;
+
 	clkdiv -= 2;
-	reg = mci_readl(MCI_MR);
-	reg &= ~((0x01 << 8) - 1);
 	reg |= (clkdiv >> 1);
-	reg |= (clkdiv & 1) ? AT91C_MCI_CLKODD : 0;
+	if (clkdiv & 1)
+		reg |=	AT91C_MCI_CLKODD;
 
 	mci_writel(MCI_MR, reg);
 #else
 	clkdiv = clkdiv / 2 - 1;
-	if (clkdiv > 0xff)
-		clkdiv = 0xff;
+	if (clkdiv & ~255UL)
+		clkdiv = 255;
 
-	reg = mci_readl(MCI_MR);
-	reg &= ~((0x01 << 8) - 1);
-	reg &= ~(((0x1 << 16) - 1) << 16);
-	reg |= AT91C_MCI_MRBLKLEN(blklen);
-	reg |= AT91C_MCI_CLKDIV(clkdiv);
+	reg = AT91C_MCI_MRBLKLEN(blklen)
+		| AT91C_MCI_RDPROOF_ENABLE
+		| AT91C_MCI_WRPROOF_ENABLE
+		| AT91C_MCI_CLKDIV(clkdiv);
 
 	mci_writel(MCI_MR, reg);
-#endif
+#endif	/* #if defined(AT91SAM9X5) || defined(AT91SAM9N12) || defined(AT91SAMA5D3X) */
+}
+
+static void mci_set_clock(unsigned int clock)
+{
+	mci_set_mode(clock, CONFIG_SYS_MMC_DEFAULT_BLKLEN);
+}
 
+static int mci_set_blkr(unsigned int blkcnt, unsigned int blklen)
+{
+	mci_writel(MCI_BLKR, (blklen << 16) | blkcnt);
 	return 0;
 }
 
-int at91_mci_init(unsigned int clock, unsigned int blklen)
+static int mci_set_bus_width(unsigned int buswidth)
 {
-	int ret;
+	unsigned int reg;
+
+	reg = mci_readl(MCI_SDCR);
 
+	if (buswidth == 8)
+		reg |=  AT91C_MCI_SCDBUS_8BIT;
+	else if (buswidth == 4)
+		reg |= AT91C_MCI_SCDBUS_4BIT;
+	else
+		reg |= AT91C_MCI_SCDBUS_1BIT;
+
+	mci_writel(MCI_SDCR, reg);
+
+	return 0;
+}
+
+static void mci_init(void)
+{
 	/* software reset */
 	mci_writel(MCI_CR, AT91C_MCI_SWRST);
 
 	/* disable mci and disable power save mode */
 	mci_writel(MCI_CR, AT91C_MCI_PWSDIS | AT91C_MCI_MCIDIS);
 
-	/* enable Read Proof and Write Proof   */
-	mci_writel(MCI_MR, AT91C_MCI_RDPROOF_ENABLE | AT91C_MCI_WRPROOF_ENABLE);
-
-	/* select Slot A and set bus width 1 bit*/
-	mci_writel(MCI_SDCR, AT91C_MCI_SCDSEL_SLOTA
-				| AT91C_MCI_SCDBUS_1BIT);
+	/* SDCard/SDIO Slot */
+	mci_writel(MCI_SDCR, AT91C_MCI_SCDSEL_SLOTA);
 
-	/* set the Data Timeout Register */
+	/* initialize timeout register */
 	mci_writel(MCI_DTOR, 0x7f);
 
 	/* disable Interrupt */
 	mci_writel(MCI_IDR, ~0L);
 
-	/* set mci clock and blocklen */
-	ret = at91_mci_set_clock_blklen(clock, blklen);
-	if (ret)
-		return ret;
+	/* set default bus width */
+	mci_set_bus_width(1);
+
+	/* set default clocks and blocklen */
+	mci_set_mode(CONFIG_SYS_MMC_DEFAULT_CLK, CONFIG_SYS_MMC_DEFAULT_BLKLEN);
 
 	/* enable mci */
 	mci_writel(MCI_CR, AT91C_MCI_MCIEN);
+}
+
+/* response type definition */
+#define MMC_RSP_PRESENT (1 << 0)
+#define MMC_RSP_136	(1 << 1)	/* 136 bit response */
+#define MMC_RSP_CRC	(1 << 2)	/* expect valid crc */
+#define MMC_RSP_BUSY	(1 << 3)	/* card may send busy */
+#define MMC_RSP_OPCODE	(1 << 4)	/* response contains opcode */
+
+#define MMC_RSP_NONE	(0)
+#define MMC_RSP_R1	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R1b	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE| \
+			MMC_RSP_BUSY)
+#define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
+#define MMC_RSP_R3	(MMC_RSP_PRESENT)
+#define MMC_RSP_R4	(MMC_RSP_PRESENT)
+#define MMC_RSP_R5	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R7	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+
+/* Data Time-out Error */
+/* Response Direction Error */
+/* Response End Bit Error */
+/* Response Index Error */
+/* Response Time-out Error */
+#define ERROR_FLAGS	(AT91C_MCI_DTOE	\
+			| AT91C_MCI_RDIRE \
+			| AT91C_MCI_RENDE \
+			| AT91C_MCI_RINDE \
+			| AT91C_MCI_RTOE)
+
+static int mmc_cmd(unsigned short cmd,
+			unsigned int resp_type,
+			unsigned int cmdarg,
+			unsigned int flags,
+			unsigned int *response)
+{
+	unsigned int cmdr;
+	unsigned int status;
+	unsigned int error_flags = ERROR_FLAGS;
+
+	/* Default Flags for the Command */
+	flags |= AT91C_MCI_MAXLAT_64;
+
+	if (resp_type & MMC_RSP_CRC)
+		error_flags |= AT91C_MCI_RCRCE; 
+	if (resp_type & MMC_RSP_136)
+		flags |= AT91C_MCI_RSPTYP_136; 
+	else if (resp_type & MMC_RSP_BUSY)
+		flags |= AT91C_MCI_RSPTYP_R1B; 
+	else if (resp_type & MMC_RSP_PRESENT)
+		flags |= AT91C_MCI_RSPTYP_48;
+
+	cmdr = cmd | flags;
+
+	/* Send the command */
+	mci_writel(MCI_ARGR, cmdarg);
+	mci_writel(MCI_CMDR, cmdr);
+
+	/* Wait for the command to complete */
+	while (!((status = mci_readl(MCI_SR)) & AT91C_MCI_CMDRDY));
+
+	if (status & error_flags) {
+		dbg_log(1, "Error status,cmd: %d, status: %d\n\r", cmd, status);
+		return COMM_ERR;
+	}
+
+	/* Copy the response to the response buffer */
+	if (resp_type & MMC_RSP_136) {
+		*response++ = mci_readl(MCI_RSPR);
+		*response++ = mci_readl(MCI_RSPR1);
+		*response++ = mci_readl(MCI_RSPR2);
+		*response++ = mci_readl(MCI_RSPR3);
+	} else
+		*response = mci_readl(MCI_RSPR); 
 
 	return 0;
 }
 
-int at91_mci_set_clock(unsigned int clock)
+static int mmc_go_idle(void)
 {
-	unsigned int blklen;
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
 	int ret;
 
-	blklen = (mci_readl(MCI_BLKR) >> 16) & 0xffff;
+	udelay(1000);
 
-	ret = at91_mci_set_clock_blklen(clock, blklen);
+	cmd = MMC_CMD_GO_IDLE_STATE;
+	cmdarg = 0;
+	resp_type = MMC_RSP_NONE;
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
 	if (ret)
 		return ret;
 
+	udelay(2000);
+
 	return 0;
 }
 
-void at91_mci_set_blkr(unsigned int blkcnt, unsigned int blklen)
+static int mmc_send_if_cond(struct mmc *mmc)
 {
-	mci_writel(MCI_BLKR, (blklen << 16) | blkcnt);
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+
+	cmd = SD_CMD_SEND_IF_COND;
+
+	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
+	cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
+	resp_type = MMC_RSP_R7;
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
+
+	if ((response[0] & 0xff) != 0xaa)
+		return UNUSABLE_ERR;
+	else
+		mmc->version = SD_VERSION_2;
+
+	return 0;
 }
 
-int at91_mci_set_bus_width(unsigned int buswidth)
+static int sd_send_op_cond(struct mmc *mmc)
 {
-	unsigned int reg;
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+	int timeout = 1000;
 
-	reg = mci_readl(MCI_SDCR);
-	reg &= ~(AT91C_MCI_SCDBUS);
+	do {
+		cmd = MMC_CMD_APP_CMD;
+		resp_type = MMC_RSP_R1;
+		cmdarg = 0;
+		flags = 0;
 
-	switch (buswidth) {
-	case 8:
-		reg |=  AT91C_MCI_SCDBUS_8BIT;
-		break;
+		ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+		if (ret)
+			return ret;
 
-	case 4:
-		reg |= AT91C_MCI_SCDBUS_4BIT;
-		break;
+		cmd = SD_CMD_APP_SEND_OP_COND;
+		resp_type = MMC_RSP_R3;
 
-	case 1:
-		reg |= AT91C_MCI_SCDBUS_1BIT;
-		break;
+		/*
+		 * Most cards do not answer if some reserved bits
+		 * in the ocr are set. However, Some controller
+		 * can set bit 7 (reserved for low voltages), but
+		 * how to manage low voltages SD card is not yet
+		 * specified.
+		 */
+		cmdarg = mmc->voltages & 0xff8000;
 
-	default:
-		return -1;
-	}
+		if (mmc->version == SD_VERSION_2)
+			cmdarg |= OCR_HCS;
 
-	mci_writel(MCI_SDCR, reg);
+		flags = 0;
+
+		ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+		if (ret)
+			return ret;
+
+		udelay(1000);
+
+	} while ((!(response[0] & OCR_BUSY)) && timeout--);
+
+	if (timeout <= 0)
+		return UNUSABLE_ERR;
+
+	if (mmc->version != SD_VERSION_2)
+		mmc->version = SD_VERSION_1_0;
+
+	mmc->ocr = response[0];
+
+	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
+	mmc->rca = 0;
 
 	return 0;
 }
 
-/*
- * Refer to the at91sam9g20 datasheet:
- * Figure 35-10. Read Function Flow Diagram
- */
-static int at91_mci_read_data(unsigned int *data)
+static int mmc_send_op_cond(struct mmc *mmc)
 {
-	unsigned int status;
-	unsigned int error_check = (AT91C_MCI_DCRCE
-					| AT91C_MCI_DTOE
-					| AT91C_MCI_OVRE);
-	/*
-	 * Read status register MCI_SR
-	 * Wait for RXRDY or error bits
-	 */
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+	int timeout = 10000;
+
+ 	/* Asking to the card its capabilities */
+ 	cmd = MMC_CMD_SEND_OP_COND;
+ 	resp_type = MMC_RSP_R3;
+ 	cmdarg = 0;
+ 	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+ 	if (ret)
+ 		return ret;
+
+ 	udelay(1000);
+
 	do {
-		status = mci_readl(MCI_SR);
-	} while ((!(status & AT91C_MCI_RXRDY))
-			&& (!(status & error_check))); 
+		cmd = MMC_CMD_SEND_OP_COND;
+		resp_type = MMC_RSP_R3;
+		cmdarg = (mmc->voltages & (response[0] & OCR_VOLTAGE_MASK))
+				| (response[0] & OCR_ACCESS_MODE);
+		flags = 0;
 
-	if (status & error_check) {
-		dbg_log(1, "Error to read data, sr: %d\n\r", status);
-		return -1;
-	}
+		ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+		if (ret)
+			return ret;
+
+		udelay(1000);
+	} while (!(response[0] & OCR_BUSY) && timeout--);
+
+	if (timeout <= 0)
+		return UNUSABLE_ERR;
+
+	mmc->version = MMC_VERSION_UNKNOWN;
+	mmc->ocr = response[0];
 
-	if (status & AT91C_MCI_RXRDY)
-		*data = mci_readl(MCI_RDR);
+	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
+	mmc->rca = 0;
 
 	return 0;
 }
 
-int at91_mci_read_block_data(unsigned int *data,
-			unsigned int bytes_to_read,
-			unsigned int block_len)
+static int sd_init_card(struct mmc *mmc)
 {
-	unsigned int count;
-	unsigned int words_to_read = bytes_to_read >> 2;
-	unsigned int words_of_block = block_len >> 2;
-	unsigned int tmp;
-	int timeout = 10000;
 	int ret;
 
-	/* Read the valid data of the block */
-	for (count = 0; count < words_to_read; count++, data++) {
-		ret = at91_mci_read_data(data);
-		if (ret)
-			return ret;
-	}
+	ret = mmc_go_idle();
+	if (ret)
+		return ret;
 
-	/* Read the no useful data the block */
-	for (; count < words_of_block; count++) {
-		ret = at91_mci_read_data(&tmp);
+	/* Test for SD version 2 */
+	ret = mmc_send_if_cond(mmc);
+
+	/* Now try to get the SD card's operating condition */
+	ret = sd_send_op_cond(mmc);
+
+	return ret;
+}
+
+static int mmc_init_card(struct mmc *mmc)
+{
+	int ret;
+
+	ret = mmc_go_idle();
+	if (ret)
+		return ret;
+
+	ret = mmc_send_op_cond(mmc);
+
+	return ret;
+}
+
+static int mmc_send_status(struct mmc *mmc, int timeout)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+
+	cmd = MMC_CMD_SEND_STATUS;
+	resp_type = MMC_RSP_R1;
+	cmdarg = mmc->rca << 16;
+	flags = 0;
+
+	do {
+		ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
 		if (ret)
 			return ret;
-	}
+		else if (response[0] & MMC_STATUS_RDY_FOR_DATA)
+			break;
+
+		udelay(1000);
 
-	while ((mci_readl(MCI_SR) & AT91C_MCI_DTIP) && (--timeout))
-		;
+		if (response[0] & MMC_STATUS_MASK) {
+			dbg_log(1, "send_status, card status Error: %d\n\r", response[0]);
+			return COMM_ERR;
+		}
+	} while (timeout--);
 
 	if (!timeout) {
-		dbg_log(1, "Data Transfer in Progress.\n\r");
-		return -1;
+		dbg_log(1, "send_status, timeout waiting card ready\n\r");
+		return TIMEOUT;
 	}
 
 	return 0;
 }
 
-int at91_mci_read_blocks(unsigned int *data,
-			unsigned int blocks,
-			unsigned int block_len)
+static int mmc_send_all_cid(struct mmc *mmc)
 {
-	unsigned int block;
-	unsigned int count;
-	unsigned int words_of_block = block_len >> 2;
-	int timeout = 10000;
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
 	int ret;
 
-	for (block = 0; block < blocks; block++) {
-		for (count = 0; count < words_of_block; count++, data++) {
-			ret = at91_mci_read_data(data);
-			if (ret)
-				return ret;
-		}
-	}
+	/* Put the Card in Identify Mode */
+	cmd = MMC_CMD_ALL_SEND_CID;
+	resp_type = MMC_RSP_R2;
+	cmdarg = 0;
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
 
-	while ((mci_readl(MCI_SR) & AT91C_MCI_DTIP) && (--timeout))
-		;
+	memcpy(mmc->cid, response, 16);
+	return 0;
+}
 
-	if (!timeout) {
-		dbg_log(1, "Data Transfer in Progress.\n\r");
-		return -1;
+static int mmc_send_rca(struct mmc *mmc)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+
+	cmd = SD_CMD_SEND_RELATIVE_ADDR;
+	cmdarg = mmc->rca << 16;
+	resp_type = MMC_RSP_R6;
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
+
+	if (IS_SD(mmc))
+		mmc->rca = (response[0] >> 16) & 0xffff;
+
+	return 0;
+}
+
+static int mmc_send_csd(struct mmc *mmc)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+	int timeout = 1000;
+
+	cmd = MMC_CMD_SEND_CSD;
+	resp_type = MMC_RSP_R2;
+	cmdarg = mmc->rca << 16;
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+
+	/* Waiting for the ready status */
+	mmc_send_status(mmc, timeout);
+	if (ret)
+		return ret;
+
+	mmc->csd[0] = response[0];
+	mmc->csd[1] = response[1];
+	mmc->csd[2] = response[2];
+	mmc->csd[3] = response[3];
+
+	if (mmc->version == MMC_VERSION_UNKNOWN) {
+		int version = (mmc->csd[0] >> 26) & 0xf;
+
+		if (version == 0)
+			mmc->version = MMC_VERSION_1_2;
+		else if (version == 1)
+			mmc->version = MMC_VERSION_1_4;
+		else if (version == 2)
+			mmc->version = MMC_VERSION_2_2;
+		else if (version == 3)
+			mmc->version = MMC_VERSION_3;
+		else if (version == 4)
+			mmc->version = MMC_VERSION_4;
+		else
+			mmc->version = MMC_VERSION_1_2;
 	}
 
+	mmc->read_bl_len = 1 << ((mmc->csd[1] >> 16) & 0xf);
+	if (mmc->read_bl_len > 512)
+		mmc->read_bl_len = 512;
+
+	return 0;
+}
+
+static int mmc_send_select_card(struct mmc *mmc)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+
+	cmd = MMC_CMD_SELECT_CARD;
+	resp_type = MMC_RSP_R1b;
+	cmdarg = mmc->rca << 16;
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 
-static int at91_mci_write_data(unsigned int *data)
+static int mmc_data_read(struct mmc *mmc,
+			unsigned int *data,
+			unsigned int blocksize,
+			unsigned int blkcnt)
 {
 	unsigned int status;
+	unsigned int word_count;
+	unsigned int block_count;
+	unsigned int *tmp;
+	unsigned int sys_blocksize = mmc->read_bl_len;
+	unsigned int dummy;
+	unsigned int timeout;
 
-	/*
-	 * Read status register MCI_SR
-	 * Wait for TXRDY or error bits
-	 */
+	for (block_count = 0; block_count < blkcnt; block_count++) {
+		word_count = 0;
+
+		/* read the data of the block */
+		do {
+			do {
+				status = mci_readl(MCI_SR);
+				if (status & (ERROR_FLAGS | AT91C_MCI_OVRE)) {
+					dbg_log(1, "Comm/Overrun Error, MCI_SR:%d\n\r", status);
+					return status;
+				}
+			} while (!(status & AT91C_MCI_RXRDY));
+
+			if (status & AT91C_MCI_RXRDY) {
+				*data++ = mci_readl(MCI_RDR);
+				word_count++;
+			}
+		} while (word_count < (blocksize / 4));
+
+		/* read the rest of the full block */
+		tmp = &dummy;
+		while (word_count < (sys_blocksize / 4)) {
+			do {
+				status = mci_readl(MCI_SR);
+				if (status & (ERROR_FLAGS | AT91C_MCI_OVRE)) {
+					dbg_log(1, "Comm/Overrun Error, MCI_SR:%d\n\r", status);
+					return status;
+				}
+			} while (!(status & AT91C_MCI_RXRDY));
+
+			if (status & AT91C_MCI_RXRDY) {
+				*tmp = mci_readl(MCI_RDR);
+				word_count++;
+			}
+		}
+	}
+
+	timeout = 0;
 	do {
 		status = mci_readl(MCI_SR);
-	} while (!(status & AT91C_MCI_TXRDY));
+		if (status & ERROR_FLAGS) {
+			dbg_log(1, "Comm Error MCI_SR:%d\n\r", status);
+			return COMM_ERR;
+		}
+		timeout++;
+	} while ((status & AT91C_MCI_DTIP) && (timeout < 10000));
 
-	mci_writel(MCI_TDR, *data);
+	if (status & AT91C_MCI_DTIP) {
+		dbg_log(1, "MCI_SR:%d\n\r", status);
+		return COMM_ERR;
+	}
 
 	return 0;
 }
 
-int at91_mci_write_block_data(unsigned int *data,
-			unsigned int bytes_to_write,
-			unsigned int block_len)
+static int sd_set_bus_width_4(struct mmc *mmc)
 {
-	unsigned int count;
-	unsigned int words_to_write = bytes_to_write >> 2;
-	unsigned int words_of_block = block_len >> 2;
-	unsigned int tmp = 0;
-	int timeout = 10000;
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
 	int ret;
 
-	/* write the valid data of the block */
-	for (count = 0; count < words_to_write; count++, data++) {
-		ret = at91_mci_write_data(data);
+	cmd = MMC_CMD_APP_CMD;
+	resp_type = MMC_RSP_R1;
+	cmdarg = mmc->rca << 16;
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
+
+	cmd = SD_CMD_APP_SET_BUS_WIDTH;
+	resp_type = MMC_RSP_R1;
+	cmdarg = 2;	/* 4 bit width */
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
+
+	mci_set_bus_width(4);
+
+	return 0;
+}
+
+static int sd_send_scr(struct mmc *mmc)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+	int timeout;
+
+	unsigned int scr[2];
+	unsigned int blocksize = 8;
+
+	mmc->card_caps = 0;
+
+	/* Read the SCR to find out if this card supports higher speeds */
+	cmd = MMC_CMD_APP_CMD;
+	resp_type = MMC_RSP_R1;
+	cmdarg = mmc->rca << 16;
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
+
+	cmd = SD_CMD_APP_SEND_SCR;
+	resp_type = MMC_RSP_R1;
+	cmdarg = 0;
+	flags = AT91C_MCI_TRCMD_START | AT91C_MCI_TRDIR_READ;
+
+	timeout = 3;
+retry_scr:
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret) {
+		if (timeout--)
+			goto retry_scr;
+
+		return ret;
+	}
+
+	blocksize = 8;
+	ret = mmc_data_read(mmc, scr, blocksize, 1);
+	if (ret)
+		return ret;
+
+	mmc->scr[0] = be32_to_cpu(scr[0]);
+	mmc->scr[1] = be32_to_cpu(scr[1]);
+
+	int version = (mmc->scr[0] >> 24) & 0xf;
+
+	if (version ==  0)
+		mmc->version = SD_VERSION_1_0;
+	else if (version == 1)
+		mmc->version = SD_VERSION_1_10;
+	else if (version == 2)
+		mmc->version = SD_VERSION_2;
+	else
+		mmc->version = SD_VERSION_1_0;
+
+	if (mmc->scr[0] & SD_DATA_4BIT)
+		mmc->card_caps |= MMC_MODE_4BIT;
+
+	return 0;
+}
+
+static int mmc_send_ext_csd(struct mmc *mmc, char *ext_csd)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+
+	unsigned int *data = (unsigned int *)ext_csd;
+	unsigned int blocksize = 512;
+
+	/* Get the Card Status Register */
+	cmd = MMC_CMD_SEND_EXT_CSD;
+	resp_type = MMC_RSP_R1;
+	cmdarg = 0;
+	flags = AT91C_MCI_TRCMD_START | AT91C_MCI_TRDIR_READ;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
+
+	ret = mmc_data_read(mmc, data, blocksize, 1);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int mmc_switch(struct mmc *mmc, unsigned char set, unsigned char index, unsigned char value)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+
+	int timeout = 1000;
+
+	cmd = MMC_CMD_SWITCH;
+	resp_type = MMC_RSP_R1b;
+	cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24)
+			| (index << 16)
+			| (value << 8);
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+
+	/* Waiting for the ready status */
+	mmc_send_status(mmc, timeout);
+
+	return ret;
+
+}
+
+static int sd_switch(struct mmc *mmc,
+			int mode,
+			int group,
+			unsigned char value,
+			unsigned char *resp)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+
+	unsigned int *data = (unsigned int *)resp;
+	unsigned int blocksize = 64;
+
+	/* Switch the frequency */
+	cmd = SD_CMD_SWITCH_FUNC;
+	resp_type = MMC_RSP_R1;
+	cmdarg = (mode << 31) | 0xffffff;
+	cmdarg &= ~(0xf << (group * 4));
+	cmdarg |= value << (group * 4);
+	flags = AT91C_MCI_TRCMD_START | AT91C_MCI_TRDIR_READ;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
+
+	ret = mmc_data_read(mmc, data, blocksize, 1);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int mmc_change_freq(struct mmc *mmc)
+{
+	int ret;
+	char ext_csd[512];
+	char cardtype;
+
+	mmc->card_caps = 0;
+
+	/* Only version 4 supports high-speed */
+	if (mmc->version < MMC_VERSION_4)
+		return 0;
+
+	mmc->card_caps |= MMC_MODE_4BIT;
+
+	ret = mmc_send_ext_csd(mmc, ext_csd);
+	if (ret)
+		return ret;
+
+	cardtype = ext_csd[196] & 0xf;
+
+	ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
+
+	if (ret)
+		return ret;
+
+	/* Now check to see that it worked */
+	ret = mmc_send_ext_csd(mmc, ext_csd);
+	if (ret)
+		return ret;
+
+	/* No high-speed support */
+	if (!ext_csd[185])
+		return 0;
+
+	/* High Speed is set, there are two types: 52MHz and 26MHz */
+	if (cardtype & MMC_HS_52MHZ)
+		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+	else
+		mmc->card_caps |= MMC_MODE_HS;
+
+	return 0;
+}
+
+static int sd_change_freq(struct mmc *mmc)
+{
+	unsigned int switch_status[16];
+	int timeout;
+	int ret;
+
+	timeout = 6;
+	while (timeout--) {
+		ret = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1, (unsigned char *)&switch_status);
 		if (ret)
 			return ret;
+
+		/* The high-speed function is busy.  Try again */
+		if (!(be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
+			break;
 	}
 
-	/* write the no useful data the block */
-	for (; count < words_of_block; count++) {
-		ret = at91_mci_write_data(&tmp);
+	/* If high-speed isn't supported, we return */
+	if (!(be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED))
+		return 0;
+
+	ret = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (unsigned char *)&switch_status);
+	if (ret)
+		return ret;
+
+	if ((be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
+		mmc->card_caps |= MMC_MODE_HS;
+
+	return 0;
+}
+
+static int mmc_set_buswidth_clock(struct mmc *mmc)
+{
+	int ret;
+
+	if (IS_SD(mmc)) {
+		/* Read the SD Configuration Register(SCR) */
+		ret = sd_send_scr(mmc);
+		if (ret)
+			return ret;
+
+		/* Version 1.0 doesn't support switching */
+		if (mmc->version != SD_VERSION_1_0)
+			ret = sd_change_freq(mmc);
+			if (ret)
+				return ret;
+	} else {
+		ret = mmc_change_freq(mmc);
 		if (ret)
 			return ret;
 	}
 
-	while ((mci_readl(MCI_SR) & AT91C_MCI_DTIP) && (--timeout))
-		;
+	/* Restrict card's capabilities by what the host can do */
+	mmc->card_caps &= mmc->host_caps;
 
-	if (!timeout) {
-		dbg_log(1, "Data Transfer in Progress.\n\r");
-		return -1;
+	if (IS_SD(mmc)) {
+		if (mmc->card_caps & MMC_MODE_4BIT)
+			ret = sd_set_bus_width_4(mmc);
+			if (ret)
+				return ret;
+
+		if (mmc->card_caps & MMC_MODE_HS)
+			mci_set_clock(40000000);
+		else
+			mci_set_clock(20000000);
+	} else {
+		if (mmc->card_caps & MMC_MODE_4BIT) {
+			/* Set the card to use 4 bit*/
+			ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_BUS_WIDTH,
+					EXT_CSD_BUS_WIDTH_4);
+
+			if (ret)
+				return ret;
+
+			mci_set_bus_width(4);
+		} else if (mmc->card_caps & MMC_MODE_8BIT) {
+			/* Set the card to use 8 bit*/
+			ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_BUS_WIDTH,
+					EXT_CSD_BUS_WIDTH_8);
+
+			if (ret)
+				return ret;
+
+			mci_set_bus_width(8);
+		}
+
+		if (mmc->card_caps & MMC_MODE_HS) {
+			if (mmc->card_caps & MMC_MODE_HS_52MHz)
+				mci_set_clock(52000000);
+			else
+				mci_set_clock(26000000);
+		} else
+			mci_set_clock(20000000);
+	}
+
+	return 0;
+}
+
+static struct mmc atmel_mmc;
+
+int mmc_initialize(void)
+{
+	struct mmc *mmc = &atmel_mmc;
+	int ret;
+
+	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+#ifdef CONFIG_SDCARD_HS
+	mmc->host_caps = MMC_MODE_4BIT | MMC_MODE_HS;
+#else
+	mmc->host_caps = MMC_MODE_4BIT;
+#endif
+
+	/* Initialize mci interface */
+	mci_init();
+
+	/* Card Indentification mode */
+	ret = sd_init_card(mmc);
+	if (ret == TIMEOUT) {
+		ret = mmc_init_card(mmc);
+		if (ret)
+			return UNUSABLE_ERR;
+	}
+
+	/* Ask any card CID number */
+	ret = mmc_send_all_cid(mmc);
+	if (ret)
+		return ret;
+
+	/*
+	 * For MMC cards, set the Relative Address.
+	 * For SD cards, get the Relatvie Address.
+	 * This also puts the cards into Standby State
+	 */
+	ret = mmc_send_rca(mmc);
+	if (ret)
+		return ret;
+
+	/* Get the Card-Specific Data */
+	ret = mmc_send_csd(mmc);
+	if (ret)
+		return ret;
+
+	/* Select the card, and put it into Transfer Mode */
+	ret = mmc_send_select_card(mmc);
+	if (ret)
+		return ret;
+
+	/* Set bus width and clock */
+	ret = mmc_set_buswidth_clock(mmc);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int mmc_set_blocklen(int blocklen)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+
+	cmd = MMC_CMD_SET_BLOCKLEN;
+	resp_type = MMC_RSP_R1;
+	cmdarg = blocklen;
+	flags = 0;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int mmc_stop_transmission(struct mmc *mmc)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int timeout = 1000;
+
+	cmd = MMC_CMD_STOP_TRANSMISSION;
+	cmdarg = 0;
+	resp_type = MMC_RSP_R1b;
+	flags = 0;
+	if (mmc_cmd(cmd, resp_type, cmdarg, flags, response)) {
+		dbg_log(1, "mmc fail to send stop cmd\n\r");
+		return 0;
 	}
 
+	/* Waiting for the ready status */
+	mmc_send_status(mmc, timeout);
+
 	return 0;
 }
+
+static int mmc_read_blocks(struct mmc *mmc,
+				void *dest,
+				unsigned int start,
+				unsigned int blkcnt)
+{
+	unsigned short cmd;
+	unsigned int  cmdarg;
+	unsigned int  resp_type;
+	unsigned int  flags;
+	unsigned int  response[4];
+	int ret;
+
+	unsigned int blocklen = mmc->read_bl_len;
+
+	/* set block count and block length */
+	mci_set_blkr(blkcnt, blocklen);
+
+	flags = AT91C_MCI_TRCMD_START | AT91C_MCI_TRDIR_READ;
+	if (blkcnt > 1) {
+		cmd = MMC_CMD_READ_MULTIPLE_BLOCK;
+		flags |= AT91C_MCI_TRTYP_MULTIPLE;
+	} else {
+		cmd = MMC_CMD_READ_SINGLE_BLOCK;
+		flags |= AT91C_MCI_TRTYP_SINGLE;
+	}
+
+	if (mmc->high_capacity) 
+		cmdarg = start;
+	else
+		cmdarg = start * mmc->read_bl_len;
+
+	resp_type = MMC_RSP_R1;
+
+	ret = mmc_cmd(cmd, resp_type, cmdarg, flags, response);
+	if (ret)
+		return 0;
+
+	ret = mmc_data_read(mmc, dest, blocklen, blkcnt);
+	if (ret)
+		return 0;
+
+	if (blkcnt > 1) 
+		mmc_stop_transmission(mmc);
+
+	return blkcnt;
+}
+
+unsigned int mmc_bread(unsigned int start, unsigned int blkcnt, void *dest)
+{
+	struct mmc *mmc = &atmel_mmc;
+	unsigned int cur_blocks, blocks_todo = blkcnt;
+
+	if (blkcnt == 0)
+		return 0;
+
+	if (mmc_set_blocklen(mmc->read_bl_len))
+		return 0;
+
+	do {
+		cur_blocks = (blocks_todo > MCI_SUPPORT_MAX_BLKS) ? MCI_SUPPORT_MAX_BLKS : blocks_todo;
+		if(mmc_read_blocks(mmc, dest, start, cur_blocks) != cur_blocks)
+			return 0;
+
+		blocks_todo -= cur_blocks;
+		start += cur_blocks;
+		dest += cur_blocks * mmc->read_bl_len;
+	} while (blocks_todo > 0);
+
+	return blkcnt;
+}
diff --git a/driver/at91_pio.c b/driver/at91_pio.c
old mode 100644
new mode 100755
diff --git a/driver/at91_pit.c b/driver/at91_pit.c
old mode 100644
new mode 100755
index c04a2f2..525fcc1
--- a/driver/at91_pit.c
+++ b/driver/at91_pit.c
@@ -26,12 +26,8 @@
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "hardware.h"
-#include "board.h"
-
 #include "arch/at91_pit.h"
-#include "arch/at91_pmc.h"
-
-#define MAX_PIV		0xfffff
+#include "board.h"
 
 static inline int pit_readl(unsigned int reg)
 {
@@ -43,60 +39,61 @@ static inline void pit_writel(unsigned int value, unsigned reg)
 	writel(value, (AT91C_BASE_PITC + reg));
 }
 
-/*
- * If MASTER_CLOCK = 132M, the maximum delay is about 520.6 second(8.6767 min).
- * it is long enough for using in bootstrap.
- */
-int timer_init(void)
+/* time unit: ms */
+int start_intervl_timer(unsigned int time)
 {
-	pit_writel((MAX_PIV | AT91C_PIT_PITEN), PIT_MR);
-
-	/* Enable PITC Clock */
-#ifdef AT91C_ID_PIT
-	writel((1 << AT91C_ID_PIT), (PMC_PCER + AT91C_BASE_PMC));
-#else
-	writel((1 << AT91C_ID_SYS), (PMC_PCER + AT91C_BASE_PMC));
-#endif
+	unsigned int interval_val;
+	unsigned int reg;
+
+	interval_val = (MASTER_CLOCK / 16 / 1000) * time;
+	if (interval_val > 0xFFFFF)
+		return -1;
+
+	reg = interval_val | AT91C_PIT_PITEN;
+	pit_writel(reg, PIT_MR);
+
 	return 0;
 }
 
-static unsigned int at91_get_pit_value(void)
+/* wait_timer unit: ms */
+/* timer unit: ms */
+unsigned int wait_interval_timer(unsigned int wait_time, unsigned int timer)
 {
-	return(pit_readl(PIT_PIIR));
-}
+	unsigned int check_counter = wait_time / timer;
+	unsigned int counter;
 
-/* If MASTER_CLOCK = 132M, require usec <= 21537 us (0xffffffff / 132000) */
-void udelay(unsigned int usec)
-{
-	unsigned int base = at91_get_pit_value();
-	unsigned int delay = ((MASTER_CLOCK / 1000) * usec) / (16 * 1000);
-	unsigned int current;
+	if (check_counter > 0xFFF)
+		return -1;
 
 	do {
-		current = at91_get_pit_value();
-		current -= base;
-	} while (current < delay);
-}
+		counter = pit_readl(PIT_PIIR) >> 20;
+	} while (counter < check_counter);
 
-/* Init a special timer for slow clock switch function */
-static int timer1_base;
-
-int start_interval_timer(void)
-{
-	timer1_base = at91_get_pit_value();
+	pit_writel(0x00, PIT_MR);
 
 	return 0;
 }
 
-int wait_interval_timer(unsigned int msec)
+/* time unit: us */
+int wait_timer(unsigned int time)
 {
-	unsigned int delay = ((MASTER_CLOCK / 1000) * msec) / 16;
-	unsigned int current;
+	unsigned int reg;
+	unsigned int interval_val;
 
-	do {
-		current = at91_get_pit_value();
-		current -= timer1_base;
-	} while (current < delay);
+	interval_val = ((MASTER_CLOCK / 1000) * time) / 16 / 1000;
+	if (interval_val > 0xFFFFF)
+		return -1;
+
+	/* enable PIT */
+	reg = interval_val | AT91C_PIT_PITEN;
+	pit_writel(reg, PIT_MR);
+
+	/* clear bit PITS in PIT_SR */
+	pit_readl(PIT_PIVR);
+
+	while((pit_readl(PIT_SR) & AT91C_PIT_PITS) == 0);
+
+	pit_writel(0x00, PIT_MR);
 
 	return 0;
 }
diff --git a/driver/at91_slowclk.c b/driver/at91_slowclk.c
old mode 100644
new mode 100755
index c003dd0..dffbd0e
--- a/driver/at91_slowclk.c
+++ b/driver/at91_slowclk.c
@@ -27,7 +27,7 @@
  */
 #include "hardware.h"
 #include "arch/at91_slowclk.h"
-#include "timer.h"
+#include "pit_timer.h"
 
 int slowclk_enable_osc32(void)
 {
@@ -40,8 +40,9 @@ int slowclk_enable_osc32(void)
 	reg |= AT91C_SLCKSEL_OSC32EN;
 	writel(reg, AT91C_BASE_SCKCR);
 
-	/* start a internal timer */
-	start_interval_timer();
+	/* start a 100ms internal timer */
+	if (start_intervl_timer(100) != 0)
+		return -1;
 
 	return 0;
 }
@@ -54,7 +55,7 @@ int slowclk_switch_osc32(void)
 	 * Wait 32768 Hz Startup Time for clock stabilization (software loop)
 	 * wait about 1s (1000ms)
 	 */
-	wait_interval_timer(1000);
+	wait_interval_timer(1000, 100);
 
 	/*
 	 * Switching from internal 32kHz RC oscillator to 32768 Hz oscillator
@@ -68,8 +69,7 @@ int slowclk_switch_osc32(void)
 	 * Waiting 5 slow clock cycles for internal resynchronization
 	 * 5 slow clock cycles = ~153 us (5 / 32768)
 	 */
-	udelay(153);
-
+	wait_timer(153);
 	/*
 	 * Disable the 32kHz RC oscillator by setting the bit RCEN to 0
 	 */
diff --git a/driver/at91_spi.c b/driver/at91_spi.c
old mode 100644
new mode 100755
index aa0a430..f335f57
--- a/driver/at91_spi.c
+++ b/driver/at91_spi.c
@@ -34,123 +34,143 @@
 #include "debug.h"
 #include "board.h"
 
-static inline unsigned int spi_readl(unsigned int reg)
-{
-	return readl(CONFIG_SYS_BASE_SPI + reg);
-}
+#define spi_readl(reg)			\
+	readl(CONFIG_SYS_BASE_SPI + reg)
 
-static inline void spi_writel(unsigned int reg, unsigned int value)
-{
-	writel(value, CONFIG_SYS_BASE_SPI + reg);
-}
+#define spi_writel(reg, value)		\
+	writel(value, CONFIG_SYS_BASE_SPI + reg)
 
-void at91_spi_cs_activate(void)
+static unsigned int at91_spi_get_cs(void)
 {
-	pio_set_value(CONFIG_SYS_SPI_PCS, 0);
-}
+	unsigned int cs;
 
-void at91_spi_cs_deactivate(void)
-{
-	pio_set_value(CONFIG_SYS_SPI_PCS, 1);
+	cs = CONFIG_SYS_SPI_CS;
+	return cs;
 }
 
-void at91_spi_enable(void)
+static void spi_cs_activate(void)
 {
-	spi_writel(SPI_CR, AT91C_SPI_SPIEN);
+	pio_set_value(CONFIG_SYS_SPI_PCS, 0);
 }
 
-void at91_spi_disable(void)
+static void spi_cs_deactivate(void)
 {
-	spi_writel(SPI_CR, AT91C_SPI_SPIDIS);
+	pio_set_value(CONFIG_SYS_SPI_PCS, 1);
 }
 
-int at91_spi_init(unsigned int pcs, unsigned int clock, unsigned int mode)
+int at91_spi_init(unsigned int clock, unsigned int mode)
 {
-	unsigned int	ncs;
 	unsigned int	scbr;
-	unsigned int	reg;
-
-	/* Reset SPI, sometimes the SPI may need twice reset */
-	spi_writel(SPI_CR, AT91C_SPI_SWRST);
-	spi_writel(SPI_CR, AT91C_SPI_SWRST);
-
-	switch (pcs) {
-	case AT91C_SPI_PCS0_DATAFLASH:
-		ncs = 0;
-		break;
-
-	case AT91C_SPI_PCS1_DATAFLASH:
-		ncs = 1;
-		break;
-
-	case AT91C_SPI_PCS2_DATAFLASH:
-		ncs = 2;
-		break;
-
-	case AT91C_SPI_PCS3_DATAFLASH:
-		ncs = 3;
-		break;
-
-	default:
-		dbg_log(1, "SPI: Error pcs : %d\n\r", pcs);
-		return -1;
-	}
+	unsigned int 	csrx;
+	unsigned int	mr;
+	unsigned int	cs = at91_spi_get_cs();
 
-	reg = AT91C_SPI_MSTR
-		| AT91C_SPI_MODFDIS
-		| AT91C_SPI_PCS((~(1 << ncs) & 0xf));
+	scbr = MASTER_CLOCK/ clock;
+	csrx = AT91C_SPI_SCBR(scbr);
+	csrx |= AT91C_SPI_BITS_8;
+	if (!(mode & SPI_CPHA))
+		csrx |= AT91C_SPI_NCPHA;
+	if (mode & SPI_CPOL)
+		csrx |= AT91C_SPI_CPOL;
 
-	spi_writel(SPI_MR, reg);
+	mr = AT91C_SPI_MSTR 
+			| AT91C_SPI_MODFDIS
+			| AT91C_SPI_PCS((~(1 << cs) & 0xf));
 
-	if (!clock)
-		return -1;
-
-	scbr = MASTER_CLOCK/clock;
-	reg = AT91C_SPI_SCBR(scbr);
-	reg |= AT91C_SPI_BITS_8;
-
-	switch (mode) {
-	case SPI_MODE0:
-		reg |= AT91C_SPI_NCPHA;
-		break;
-
-	case SPI_MODE1:
-		break;
-
-	case SPI_MODE2:
-		reg |= (AT91C_SPI_NCPHA | AT91C_SPI_CPOL);
-		break;
-
-	case SPI_MODE3:
-		reg |= AT91C_SPI_CPOL;
-		break;
-	default:
-		dbg_log(1, "SPI: Error mode : %d\n\r", mode);
-		return -1;
-	}
-
-	spi_writel(SPI_CSR(ncs), reg);
+	spi_writel(SPI_CSR(cs), csrx);
+	spi_writel(SPI_MR, mr);
 
 	return 0;
 }
 
-void at91_spi_write_data(unsigned short data)
+int at91_spi_enable(void)
 {
-	while ((spi_readl(SPI_SR) & AT91C_SPI_TXEMPTY) == 0)
-		;
-	spi_writel(SPI_TDR, data);
-	while ((spi_readl(SPI_SR) & AT91C_SPI_TDRE) == 0)
-		;
+	/* Enable the SPI hardware */
+	spi_writel(SPI_CR, AT91C_SPI_SPIEN);
+
+	return 0;
 }
 
-unsigned int at91_spi_read_spi(void)
+void at91_spi_disable(void)
 {
-	while ((spi_readl(SPI_SR) & AT91C_SPI_RDRF) == 0)
-		;
-	return spi_readl(SPI_RDR) & 0xffff;
+	/* Disable the SPI hardware */
+	spi_writel(SPI_CR, AT91C_SPI_SPIDIS);
 }
 
-unsigned int at91_spi_read_sr(void)
+int spi_xfer(unsigned int len, const void *dout, 
+		void *din, unsigned long flags)
 {
-	return spi_readl(SPI_SR);
+	unsigned int	len_tx;
+	unsigned int	len_rx;
+	const unsigned char	*txp = dout;
+	unsigned char		*rxp = din;
+	unsigned int 	status;
+	unsigned char	value;
+
+	if (len == 0)
+		goto out;
+
+	/*
+	 * The controller can do automatic CS control, but it is
+	 * somewhat quirky, and it doesn't really buy us much anyway
+	 * in the context of U-Boot.
+	 */
+	if (flags & SPI_XFER_BEGIN) {
+		spi_cs_activate();
+		/*
+		 * sometimes the RDR is not empty when we get here,
+		 * in theory that should not happen, but it DOES happen.
+		 * Read it here to be on the safe side.
+		 * That also clears the OVRES flag. Required if the
+		 * following loop exits due to OVRES!
+		 */
+		spi_readl(SPI_RDR);
+		spi_readl(SPI_SR);
+	}
+
+	for (len_tx = 0, len_rx = 0; len_rx < len; ) {
+		/* send data */
+		if (len_tx < len) {
+			do {
+				status = spi_readl(SPI_SR);
+			} while ((status & AT91C_SPI_TDRE) == 0);
+
+			if (txp)
+				value = *txp++;
+			else
+				value = 0;
+
+			spi_writel(SPI_TDR, value);
+			len_tx++;
+		}
+
+		/* recv data */
+		do {
+			status = spi_readl(SPI_SR);
+			if (status & AT91C_SPI_OVRES) {
+				spi_cs_deactivate();
+				return -1;
+			}
+		} while ((status & AT91C_SPI_RDRF) == 0);
+
+		value = spi_readl(SPI_RDR);
+		if (rxp)
+			*rxp++ = value;
+		len_rx++;
+	}
+
+out:
+	if (flags & SPI_XFER_END) {
+		/*
+		 * Wait until the transfer is completely done before
+		 * we deactivate CS.
+		 */
+		do {
+			status = spi_readl(SPI_SR);
+		} while (!(status & AT91C_SPI_TXEMPTY));
+
+		spi_cs_deactivate();
+	}
+
+	return 0;
 }
diff --git a/driver/at91_wdt.c b/driver/at91_wdt.c
deleted file mode 100644
index a1f6a23..0000000
--- a/driver/at91_wdt.c
+++ /dev/null
@@ -1,38 +0,0 @@
-/* ----------------------------------------------------------------------------
- *         ATMEL Microcontroller Software Support
- * ----------------------------------------------------------------------------
- * Copyright (c) 2012, Atmel Corporation
-
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the disclaimer below.
- *
- * Atmel's name may not be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
- * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include "hardware.h"
-#include "arch/at91_wdt.h"
-
-#ifdef CONFIG_DISABLE_WATCHDOG
-void at91_disable_wdt(void)
-{
-	writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
-}
-#else
-void at91_disable_wdt(void) {}
-#endif
diff --git a/driver/bch.c b/driver/bch.c
new file mode 100644
index 0000000..ca1909a
--- /dev/null
+++ b/driver/bch.c
@@ -0,0 +1,1406 @@
+/*
+ * Generic binary BCH encoding/decoding library
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 51
+ * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright  2011 Parrot S.A.
+ *
+ * Author: Ivan Djelic <ivan.djelic@parrot.com>
+ *
+ * Description:
+ *
+ * This library provides runtime configurable encoding/decoding of binary
+ * Bose-Chaudhuri-Hocquenghem (BCH) codes.
+ *
+ * Call init_bch to get a pointer to a newly allocated bch_control structure for
+ * the given m (Galois field order), t (error correction capability) and
+ * (optional) primitive polynomial parameters.
+ *
+ * Call encode_bch to compute and store ecc parity bytes to a given buffer.
+ * Call decode_bch to detect and locate errors in received data.
+ *
+ * On systems supporting hw BCH features, intermediate results may be provided
+ * to decode_bch in order to skip certain steps. See decode_bch() documentation
+ * for details.
+ *
+ * Option CONFIG_BCH_CONST_PARAMS can be used to force fixed values of
+ * parameters m and t; thus allowing extra compiler optimizations and providing
+ * better (up to 2x) encoding performance. Using this option makes sense when
+ * (m,t) are fixed and known in advance, e.g. when using BCH error correction
+ * on a particular NAND flash device.
+ *
+ * Algorithmic details:
+ *
+ * Encoding is performed by processing 32 input bits in parallel, using 4
+ * remainder lookup tables.
+ *
+ * The final stage of decoding involves the following internal steps:
+ * a. Syndrome computation
+ * b. Error locator polynomial computation using Berlekamp-Massey algorithm
+ * c. Error locator root finding (by far the most expensive step)
+ *
+ * In this implementation, step c is not performed using the usual Chien search.
+ * Instead, an alternative approach described in [1] is used. It consists in
+ * factoring the error locator polynomial using the Berlekamp Trace algorithm
+ * (BTA) down to a certain degree (4), after which ad hoc low-degree polynomial
+ * solving techniques [2] are used. The resulting algorithm, called BTZ, yields
+ * much better performance than Chien search for usual (m,t) values (typically
+ * m >= 13, t < 32, see [1]).
+ *
+ * [1] B. Biswas, V. Herbert. Efficient root finding of polynomials over fields
+ * of characteristic 2, in: Western European Workshop on Research in Cryptology
+ * - WEWoRC 2009, Graz, Austria, LNCS, Springer, July 2009, to appear.
+ * [2] [Zin96] V.A. Zinoviev. On the solution of equations of degree 10 over
+ * finite fields GF(2^q). In Rapport de recherche INRIA no 2829, 1996.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <bch/bch.h>
+
+#ifndef NULL
+#define NULL  0
+#endif
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x)  (sizeof(x) / sizeof(x[0]))
+#endif
+
+#ifndef GFP_KERNEL
+#define GFP_KERNEL  0
+#endif
+
+#ifndef EINVAL
+#define EINVAL  1
+#endif
+
+#ifndef EBADMSG
+#define EBADMSG  2
+#endif
+
+#define cpu_to_be32(x)  ((((x) & 0xFF000000) >> 24) | \
+                         (((x) & 0x00FF0000) >> 8) | \
+                         (((x) & 0x0000FF00) << 8) | \
+                         (((x) & 0x000000FF) << 24))
+
+void *_sbrk(int increment);
+#define malloc(s)      _sbrk(s)
+#define free(p)
+#define kmalloc(s, f)  malloc(s)
+#define kzalloc(s, f)  ({void* p = malloc(s); if(p != NULL) memset(p, 0, s); p;})
+#define kfree(p)       free(p)
+
+#if defined(CONFIG_BCH_CONST_PARAMS)
+#define GF_M(_p)               (CONFIG_BCH_CONST_M)
+#define GF_T(_p)               (CONFIG_BCH_CONST_T)
+#define GF_N(_p)               ((1 << (CONFIG_BCH_CONST_M))-1)
+#else
+#define GF_M(_p)               ((_p)->m)
+#define GF_T(_p)               ((_p)->t)
+#define GF_N(_p)               ((_p)->n)
+#endif
+
+#define BCH_ECC_WORDS(_p)      DIV_ROUND_UP(GF_M(_p)*GF_T(_p), 32)
+#define BCH_ECC_BYTES(_p)      DIV_ROUND_UP(GF_M(_p)*GF_T(_p), 8)
+
+#ifndef dbg
+#define dbg(_fmt, args...)     do {} while (0)
+#endif
+
+/*
+ * represent a polynomial over GF(2^m)
+ */
+struct gf_poly {
+	unsigned int deg;    /* polynomial degree */
+	unsigned int c[0];   /* polynomial terms */
+};
+
+/* given its degree, compute a polynomial size in bytes */
+#define GF_POLY_SZ(_d) (sizeof(struct gf_poly)+((_d)+1)*sizeof(unsigned int))
+
+/* polynomial of degree 1 */
+struct gf_poly_deg1 {
+	struct gf_poly poly;
+	unsigned int   c[2];
+};
+
+int fls(int i)
+{
+	unsigned int x = sizeof(i) * 8;
+
+	while(x > 0)
+	{
+		if(i & (1 << (x - 1)))
+			return(x);
+		x--;
+	}
+
+	return(0);
+}
+
+/*
+ * same as encode_bch(), but process input data one byte at a time
+ */
+static void encode_bch_unaligned(struct bch_control *bch,
+				 const unsigned char *data, unsigned int len,
+				 uint32_t *ecc)
+{
+	int i;
+	const uint32_t *p;
+	const int l = BCH_ECC_WORDS(bch)-1;
+
+	while (len--) {
+		p = bch->mod8_tab + (l+1)*(((ecc[0] >> 24)^(*data++)) & 0xff);
+
+		for (i = 0; i < l; i++)
+			ecc[i] = ((ecc[i] << 8)|(ecc[i+1] >> 24))^(*p++);
+
+		ecc[l] = (ecc[l] << 8)^(*p);
+	}
+}
+
+/*
+ * convert ecc bytes to aligned, zero-padded 32-bit ecc words
+ */
+static void load_ecc8(struct bch_control *bch, uint32_t *dst,
+		      const uint8_t *src)
+{
+	uint8_t pad[4] = {0, 0, 0, 0};
+	unsigned int i, nwords = BCH_ECC_WORDS(bch)-1;
+
+	for (i = 0; i < nwords; i++, src += 4)
+		dst[i] = (src[0] << 24)|(src[1] << 16)|(src[2] << 8)|src[3];
+
+	memcpy(pad, src, BCH_ECC_BYTES(bch)-4*nwords);
+	dst[nwords] = (pad[0] << 24)|(pad[1] << 16)|(pad[2] << 8)|pad[3];
+}
+
+/*
+ * convert 32-bit ecc words to ecc bytes
+ */
+static void store_ecc8(struct bch_control *bch, uint8_t *dst,
+		       const uint32_t *src)
+{
+	uint8_t pad[4];
+	unsigned int i, nwords = BCH_ECC_WORDS(bch)-1;
+
+	for (i = 0; i < nwords; i++) {
+		*dst++ = (src[i] >> 24);
+		*dst++ = (src[i] >> 16) & 0xff;
+		*dst++ = (src[i] >>  8) & 0xff;
+		*dst++ = (src[i] >>  0) & 0xff;
+	}
+	pad[0] = (src[nwords] >> 24);
+	pad[1] = (src[nwords] >> 16) & 0xff;
+	pad[2] = (src[nwords] >>  8) & 0xff;
+	pad[3] = (src[nwords] >>  0) & 0xff;
+	memcpy(dst, pad, BCH_ECC_BYTES(bch)-4*nwords);
+}
+
+/**
+ * encode_bch - calculate BCH ecc parity of data
+ * @bch:   BCH control structure
+ * @data:  data to encode
+ * @len:   data length in bytes
+ * @ecc:   ecc parity data, must be initialized by caller
+ *
+ * The @ecc parity array is used both as input and output parameter, in order to
+ * allow incremental computations. It should be of the size indicated by member
+ * @ecc_bytes of @bch, and should be initialized to 0 before the first call.
+ *
+ * The exact number of computed ecc parity bits is given by member @ecc_bits of
+ * @bch; it may be less than m*t for large values of t.
+ */
+void encode_bch(struct bch_control *bch, const uint8_t *data,
+		unsigned int len, uint8_t *ecc)
+{
+	const unsigned int l = BCH_ECC_WORDS(bch)-1;
+	unsigned int i, mlen;
+	unsigned long m;
+	uint32_t w, r[l+1];
+	const uint32_t * const tab0 = bch->mod8_tab;
+	const uint32_t * const tab1 = tab0 + 256*(l+1);
+	const uint32_t * const tab2 = tab1 + 256*(l+1);
+	const uint32_t * const tab3 = tab2 + 256*(l+1);
+	const uint32_t *pdata, *p0, *p1, *p2, *p3;
+
+	if (ecc) {
+		/* load ecc parity bytes into internal 32-bit buffer */
+		load_ecc8(bch, bch->ecc_buf, ecc);
+	} else {
+		memset(bch->ecc_buf, 0, sizeof(r));
+	}
+
+	/* process first unaligned data bytes */
+	m = ((unsigned long)data) & 3;
+	if (m) {
+		mlen = (len < (4-m)) ? len : 4-m;
+		encode_bch_unaligned(bch, data, mlen, bch->ecc_buf);
+		data += mlen;
+		len  -= mlen;
+	}
+
+	/* process 32-bit aligned data words */
+	pdata = (uint32_t *)data;
+	mlen  = len/4;
+	data += 4*mlen;
+	len  -= 4*mlen;
+	memcpy(r, bch->ecc_buf, sizeof(r));
+
+	/*
+	 * split each 32-bit word into 4 polynomials of weight 8 as follows:
+	 *
+	 * 31 ...24  23 ...16  15 ... 8  7 ... 0
+	 * xxxxxxxx  yyyyyyyy  zzzzzzzz  tttttttt
+	 *                               tttttttt  mod g = r0 (precomputed)
+	 *                     zzzzzzzz  00000000  mod g = r1 (precomputed)
+	 *           yyyyyyyy  00000000  00000000  mod g = r2 (precomputed)
+	 * xxxxxxxx  00000000  00000000  00000000  mod g = r3 (precomputed)
+	 * xxxxxxxx  yyyyyyyy  zzzzzzzz  tttttttt  mod g = r0^r1^r2^r3
+	 */
+	while (mlen--) {
+		/* input data is read in big-endian format */
+		w = r[0]^cpu_to_be32(*pdata);
+		pdata++;
+		p0 = tab0 + (l+1)*((w >>  0) & 0xff);
+		p1 = tab1 + (l+1)*((w >>  8) & 0xff);
+		p2 = tab2 + (l+1)*((w >> 16) & 0xff);
+		p3 = tab3 + (l+1)*((w >> 24) & 0xff);
+
+		for (i = 0; i < l; i++)
+			r[i] = r[i+1]^p0[i]^p1[i]^p2[i]^p3[i];
+
+		r[l] = p0[l]^p1[l]^p2[l]^p3[l];
+	}
+	memcpy(bch->ecc_buf, r, sizeof(r));
+
+	/* process last unaligned bytes */
+	if (len)
+		encode_bch_unaligned(bch, data, len, bch->ecc_buf);
+
+	/* store ecc parity bytes into original parity buffer */
+	if (ecc)
+		store_ecc8(bch, ecc, bch->ecc_buf);
+}
+
+static inline int modulo(struct bch_control *bch, unsigned int v)
+{
+	const unsigned int n = GF_N(bch);
+	while (v >= n) {
+		v -= n;
+		v = (v & n) + (v >> GF_M(bch));
+	}
+	return v;
+}
+
+/*
+ * shorter and faster modulo function, only works when v < 2N.
+ */
+static inline int mod_s(struct bch_control *bch, unsigned int v)
+{
+	const unsigned int n = GF_N(bch);
+	return (v < n) ? v : v-n;
+}
+
+static inline int deg(unsigned int poly)
+{
+	/* polynomial degree is the most-significant bit index */
+	return fls(poly)-1;
+}
+
+static inline int parity(unsigned int x)
+{
+	/*
+	 * public domain code snippet, lifted from
+	 * http://www-graphics.stanford.edu/~seander/bithacks.html
+	 */
+	x ^= x >> 1;
+	x ^= x >> 2;
+	x = (x & 0x11111111U) * 0x11111111U;
+	return (x >> 28) & 1;
+}
+
+/* Galois field basic operations: multiply, divide, inverse, etc. */
+
+static inline unsigned int gf_mul(struct bch_control *bch, unsigned int a,
+				  unsigned int b)
+{
+	return (a && b) ? bch->a_pow_tab[mod_s(bch, bch->a_log_tab[a]+
+					       bch->a_log_tab[b])] : 0;
+}
+
+static inline unsigned int gf_sqr(struct bch_control *bch, unsigned int a)
+{
+	return a ? bch->a_pow_tab[mod_s(bch, 2*bch->a_log_tab[a])] : 0;
+}
+
+static inline unsigned int gf_div(struct bch_control *bch, unsigned int a,
+				  unsigned int b)
+{
+	return a ? bch->a_pow_tab[mod_s(bch, bch->a_log_tab[a]+
+					GF_N(bch)-bch->a_log_tab[b])] : 0;
+}
+
+static inline unsigned int gf_inv(struct bch_control *bch, unsigned int a)
+{
+	return bch->a_pow_tab[GF_N(bch)-bch->a_log_tab[a]];
+}
+
+static inline unsigned int a_pow(struct bch_control *bch, int i)
+{
+	return bch->a_pow_tab[modulo(bch, i)];
+}
+
+static inline int a_log(struct bch_control *bch, unsigned int x)
+{
+	return bch->a_log_tab[x];
+}
+
+static inline int a_ilog(struct bch_control *bch, unsigned int x)
+{
+	return mod_s(bch, GF_N(bch)-bch->a_log_tab[x]);
+}
+
+/*
+ * compute 2t syndromes of ecc polynomial, i.e. ecc(a^j) for j=1..2t
+ */
+static void compute_syndromes(struct bch_control *bch, uint32_t *ecc,
+			      unsigned int *syn)
+{
+	int i, j, s;
+	unsigned int m;
+	uint32_t poly;
+	const int t = GF_T(bch);
+
+	s = bch->ecc_bits;
+
+	/* make sure extra bits in last ecc word are cleared */
+	m = ((unsigned int)s) & 31;
+	if (m)
+		ecc[s/32] &= ~((1u << (32-m))-1);
+	memset(syn, 0, 2*t*sizeof(*syn));
+
+	/* compute v(a^j) for j=1 .. 2t-1 */
+	do {
+		poly = *ecc++;
+		s -= 32;
+		while (poly) {
+			i = deg(poly);
+			for (j = 0; j < 2*t; j += 2)
+				syn[j] ^= a_pow(bch, (j+1)*(i+s));
+
+			poly ^= (1 << i);
+		}
+	} while (s > 0);
+
+	/* v(a^(2j)) = v(a^j)^2 */
+	for (j = 0; j < t; j++)
+		syn[2*j+1] = gf_sqr(bch, syn[j]);
+}
+
+static void gf_poly_copy(struct gf_poly *dst, struct gf_poly *src)
+{
+	memcpy(dst, src, GF_POLY_SZ(src->deg));
+}
+
+static int compute_error_locator_polynomial(struct bch_control *bch,
+					    const unsigned int *syn)
+{
+	const unsigned int t = GF_T(bch);
+	const unsigned int n = GF_N(bch);
+	unsigned int i, j, tmp, l, pd = 1, d = syn[0];
+	struct gf_poly *elp = bch->elp;
+	struct gf_poly *pelp = bch->poly_2t[0];
+	struct gf_poly *elp_copy = bch->poly_2t[1];
+	int k, pp = -1;
+
+	memset(pelp, 0, GF_POLY_SZ(2*t));
+	memset(elp, 0, GF_POLY_SZ(2*t));
+
+	pelp->deg = 0;
+	pelp->c[0] = 1;
+	elp->deg = 0;
+	elp->c[0] = 1;
+
+	/* use simplified binary Berlekamp-Massey algorithm */
+	for (i = 0; (i < t) && (elp->deg <= t); i++) {
+		if (d) {
+			k = 2*i-pp;
+			gf_poly_copy(elp_copy, elp);
+			/* e[i+1](X) = e[i](X)+di*dp^-1*X^2(i-p)*e[p](X) */
+			tmp = a_log(bch, d)+n-a_log(bch, pd);
+			for (j = 0; j <= pelp->deg; j++) {
+				if (pelp->c[j]) {
+					l = a_log(bch, pelp->c[j]);
+					elp->c[j+k] ^= a_pow(bch, tmp+l);
+				}
+			}
+			/* compute l[i+1] = max(l[i]->c[l[p]+2*(i-p]) */
+			tmp = pelp->deg+k;
+			if (tmp > elp->deg) {
+				elp->deg = tmp;
+				gf_poly_copy(pelp, elp_copy);
+				pd = d;
+				pp = 2*i;
+			}
+		}
+		/* di+1 = S(2i+3)+elp[i+1].1*S(2i+2)+...+elp[i+1].lS(2i+3-l) */
+		if (i < t-1) {
+			d = syn[2*i+2];
+			for (j = 1; j <= elp->deg; j++)
+				d ^= gf_mul(bch, elp->c[j], syn[2*i+2-j]);
+		}
+	}
+	dbg("elp=%s\n", gf_poly_str(elp));
+	return (elp->deg > t) ? -1 : (int)elp->deg;
+}
+
+/*
+ * solve a m x m linear system in GF(2) with an expected number of solutions,
+ * and return the number of found solutions
+ */
+static int solve_linear_system(struct bch_control *bch, unsigned int *rows,
+			       unsigned int *sol, int nsol)
+{
+	const int m = GF_M(bch);
+	unsigned int tmp, mask;
+	int rem, c, r, p, k, param[m];
+
+	k = 0;
+	mask = 1 << m;
+
+	/* Gaussian elimination */
+	for (c = 0; c < m; c++) {
+		rem = 0;
+		p = c-k;
+		/* find suitable row for elimination */
+		for (r = p; r < m; r++) {
+			if (rows[r] & mask) {
+				if (r != p) {
+					tmp = rows[r];
+					rows[r] = rows[p];
+					rows[p] = tmp;
+				}
+				rem = r+1;
+				break;
+			}
+		}
+		if (rem) {
+			/* perform elimination on remaining rows */
+			tmp = rows[p];
+			for (r = rem; r < m; r++) {
+				if (rows[r] & mask)
+					rows[r] ^= tmp;
+			}
+		} else {
+			/* elimination not needed, store defective row index */
+			param[k++] = c;
+		}
+		mask >>= 1;
+	}
+	/* rewrite system, inserting fake parameter rows */
+	if (k > 0) {
+		p = k;
+		for (r = m-1; r >= 0; r--) {
+			if ((r > m-1-k) && rows[r])
+				/* system has no solution */
+				return 0;
+
+			rows[r] = (p && (r == param[p-1])) ?
+				p--, 1u << (m-r) : rows[r-p];
+		}
+	}
+
+	if (nsol != (1 << k))
+		/* unexpected number of solutions */
+		return 0;
+
+	for (p = 0; p < nsol; p++) {
+		/* set parameters for p-th solution */
+		for (c = 0; c < k; c++)
+			rows[param[c]] = (rows[param[c]] & ~1)|((p >> c) & 1);
+
+		/* compute unique solution */
+		tmp = 0;
+		for (r = m-1; r >= 0; r--) {
+			mask = rows[r] & (tmp|1);
+			tmp |= parity(mask) << (m-r);
+		}
+		sol[p] = tmp >> 1;
+	}
+	return nsol;
+}
+
+/*
+ * this function builds and solves a linear system for finding roots of a degree
+ * 4 affine monic polynomial X^4+aX^2+bX+c over GF(2^m).
+ */
+static int find_affine4_roots(struct bch_control *bch, unsigned int a,
+			      unsigned int b, unsigned int c,
+			      unsigned int *roots)
+{
+	int i, j, k;
+	const int m = GF_M(bch);
+	unsigned int mask = 0xff, t, rows[16] = {0,};
+
+	j = a_log(bch, b);
+	k = a_log(bch, a);
+	rows[0] = c;
+
+	/* buid linear system to solve X^4+aX^2+bX+c = 0 */
+	for (i = 0; i < m; i++) {
+		rows[i+1] = bch->a_pow_tab[4*i]^
+			(a ? bch->a_pow_tab[mod_s(bch, k)] : 0)^
+			(b ? bch->a_pow_tab[mod_s(bch, j)] : 0);
+		j++;
+		k += 2;
+	}
+	/*
+	 * transpose 16x16 matrix before passing it to linear solver
+	 * warning: this code assumes m < 16
+	 */
+	for (j = 8; j != 0; j >>= 1, mask ^= (mask << j)) {
+		for (k = 0; k < 16; k = (k+j+1) & ~j) {
+			t = ((rows[k] >> j)^rows[k+j]) & mask;
+			rows[k] ^= (t << j);
+			rows[k+j] ^= t;
+		}
+	}
+	return solve_linear_system(bch, rows, roots, 4);
+}
+
+/*
+ * compute root r of a degree 1 polynomial over GF(2^m) (returned as log(1/r))
+ */
+static int find_poly_deg1_roots(struct bch_control *bch, struct gf_poly *poly,
+				unsigned int *roots)
+{
+	int n = 0;
+
+	if (poly->c[0])
+		/* poly[X] = bX+c with c!=0, root=c/b */
+		roots[n++] = mod_s(bch, GF_N(bch)-bch->a_log_tab[poly->c[0]]+
+				   bch->a_log_tab[poly->c[1]]);
+	return n;
+}
+
+/*
+ * compute roots of a degree 2 polynomial over GF(2^m)
+ */
+static int find_poly_deg2_roots(struct bch_control *bch, struct gf_poly *poly,
+				unsigned int *roots)
+{
+	int n = 0, i, l0, l1, l2;
+	unsigned int u, v, r;
+
+	if (poly->c[0] && poly->c[1]) {
+
+		l0 = bch->a_log_tab[poly->c[0]];
+		l1 = bch->a_log_tab[poly->c[1]];
+		l2 = bch->a_log_tab[poly->c[2]];
+
+		/* using z=a/bX, transform aX^2+bX+c into z^2+z+u (u=ac/b^2) */
+		u = a_pow(bch, l0+l2+2*(GF_N(bch)-l1));
+		/*
+		 * let u = sum(li.a^i) i=0..m-1; then compute r = sum(li.xi):
+		 * r^2+r = sum(li.(xi^2+xi)) = sum(li.(a^i+Tr(a^i).a^k)) =
+		 * u + sum(li.Tr(a^i).a^k) = u+a^k.Tr(sum(li.a^i)) = u+a^k.Tr(u)
+		 * i.e. r and r+1 are roots iff Tr(u)=0
+		 */
+		r = 0;
+		v = u;
+		while (v) {
+			i = deg(v);
+			r ^= bch->xi_tab[i];
+			v ^= (1 << i);
+		}
+		/* verify root */
+		if ((gf_sqr(bch, r)^r) == u) {
+			/* reverse z=a/bX transformation and compute log(1/r) */
+			roots[n++] = modulo(bch, 2*GF_N(bch)-l1-
+					    bch->a_log_tab[r]+l2);
+			roots[n++] = modulo(bch, 2*GF_N(bch)-l1-
+					    bch->a_log_tab[r^1]+l2);
+		}
+	}
+	return n;
+}
+
+/*
+ * compute roots of a degree 3 polynomial over GF(2^m)
+ */
+static int find_poly_deg3_roots(struct bch_control *bch, struct gf_poly *poly,
+				unsigned int *roots)
+{
+	int i, n = 0;
+	unsigned int a, b, c, a2, b2, c2, e3, tmp[4];
+
+	if (poly->c[0]) {
+		/* transform polynomial into monic X^3 + a2X^2 + b2X + c2 */
+		e3 = poly->c[3];
+		c2 = gf_div(bch, poly->c[0], e3);
+		b2 = gf_div(bch, poly->c[1], e3);
+		a2 = gf_div(bch, poly->c[2], e3);
+
+		/* (X+a2)(X^3+a2X^2+b2X+c2) = X^4+aX^2+bX+c (affine) */
+		c = gf_mul(bch, a2, c2);           /* c = a2c2      */
+		b = gf_mul(bch, a2, b2)^c2;        /* b = a2b2 + c2 */
+		a = gf_sqr(bch, a2)^b2;            /* a = a2^2 + b2 */
+
+		/* find the 4 roots of this affine polynomial */
+		if (find_affine4_roots(bch, a, b, c, tmp) == 4) {
+			/* remove a2 from final list of roots */
+			for (i = 0; i < 4; i++) {
+				if (tmp[i] != a2)
+					roots[n++] = a_ilog(bch, tmp[i]);
+			}
+		}
+	}
+	return n;
+}
+
+/*
+ * compute roots of a degree 4 polynomial over GF(2^m)
+ */
+static int find_poly_deg4_roots(struct bch_control *bch, struct gf_poly *poly,
+				unsigned int *roots)
+{
+	int i, l, n = 0;
+	unsigned int a, b, c, d, e = 0, f, a2, b2, c2, e4;
+
+	if (poly->c[0] == 0)
+		return 0;
+
+	/* transform polynomial into monic X^4 + aX^3 + bX^2 + cX + d */
+	e4 = poly->c[4];
+	d = gf_div(bch, poly->c[0], e4);
+	c = gf_div(bch, poly->c[1], e4);
+	b = gf_div(bch, poly->c[2], e4);
+	a = gf_div(bch, poly->c[3], e4);
+
+	/* use Y=1/X transformation to get an affine polynomial */
+	if (a) {
+		/* first, eliminate cX by using z=X+e with ae^2+c=0 */
+		if (c) {
+			/* compute e such that e^2 = c/a */
+			f = gf_div(bch, c, a);
+			l = a_log(bch, f);
+			l += (l & 1) ? GF_N(bch) : 0;
+			e = a_pow(bch, l/2);
+			/*
+			 * use transformation z=X+e:
+			 * z^4+e^4 + a(z^3+ez^2+e^2z+e^3) + b(z^2+e^2) +cz+ce+d
+			 * z^4 + az^3 + (ae+b)z^2 + (ae^2+c)z+e^4+be^2+ae^3+ce+d
+			 * z^4 + az^3 + (ae+b)z^2 + e^4+be^2+d
+			 * z^4 + az^3 +     b'z^2 + d'
+			 */
+			d = a_pow(bch, 2*l)^gf_mul(bch, b, f)^d;
+			b = gf_mul(bch, a, e)^b;
+		}
+		/* now, use Y=1/X to get Y^4 + b/dY^2 + a/dY + 1/d */
+		if (d == 0)
+			/* assume all roots have multiplicity 1 */
+			return 0;
+
+		c2 = gf_inv(bch, d);
+		b2 = gf_div(bch, a, d);
+		a2 = gf_div(bch, b, d);
+	} else {
+		/* polynomial is already affine */
+		c2 = d;
+		b2 = c;
+		a2 = b;
+	}
+	/* find the 4 roots of this affine polynomial */
+	if (find_affine4_roots(bch, a2, b2, c2, roots) == 4) {
+		for (i = 0; i < 4; i++) {
+			/* post-process roots (reverse transformations) */
+			f = a ? gf_inv(bch, roots[i]) : roots[i];
+			roots[i] = a_ilog(bch, f^e);
+		}
+		n = 4;
+	}
+	return n;
+}
+
+/*
+ * build monic, log-based representation of a polynomial
+ */
+static void gf_poly_logrep(struct bch_control *bch,
+			   const struct gf_poly *a, int *rep)
+{
+	int i, d = a->deg, l = GF_N(bch)-a_log(bch, a->c[a->deg]);
+
+	/* represent 0 values with -1; warning, rep[d] is not set to 1 */
+	for (i = 0; i < d; i++)
+		rep[i] = a->c[i] ? mod_s(bch, a_log(bch, a->c[i])+l) : -1;
+}
+
+/*
+ * compute polynomial Euclidean division remainder in GF(2^m)[X]
+ */
+static void gf_poly_mod(struct bch_control *bch, struct gf_poly *a,
+			const struct gf_poly *b, int *rep)
+{
+	int la, p, m;
+	unsigned int i, j, *c = a->c;
+	const unsigned int d = b->deg;
+
+	if (a->deg < d)
+		return;
+
+	/* reuse or compute log representation of denominator */
+	if (!rep) {
+		rep = bch->cache;
+		gf_poly_logrep(bch, b, rep);
+	}
+
+	for (j = a->deg; j >= d; j--) {
+		if (c[j]) {
+			la = a_log(bch, c[j]);
+			p = j-d;
+			for (i = 0; i < d; i++, p++) {
+				m = rep[i];
+				if (m >= 0)
+					c[p] ^= bch->a_pow_tab[mod_s(bch,
+								     m+la)];
+			}
+		}
+	}
+	a->deg = d-1;
+	while (!c[a->deg] && a->deg)
+		a->deg--;
+}
+
+/*
+ * compute polynomial Euclidean division quotient in GF(2^m)[X]
+ */
+static void gf_poly_div(struct bch_control *bch, struct gf_poly *a,
+			const struct gf_poly *b, struct gf_poly *q)
+{
+	if (a->deg >= b->deg) {
+		q->deg = a->deg-b->deg;
+		/* compute a mod b (modifies a) */
+		gf_poly_mod(bch, a, b, NULL);
+		/* quotient is stored in upper part of polynomial a */
+		memcpy(q->c, &a->c[b->deg], (1+q->deg)*sizeof(unsigned int));
+	} else {
+		q->deg = 0;
+		q->c[0] = 0;
+	}
+}
+
+/*
+ * compute polynomial GCD (Greatest Common Divisor) in GF(2^m)[X]
+ */
+static struct gf_poly *gf_poly_gcd(struct bch_control *bch, struct gf_poly *a,
+				   struct gf_poly *b)
+{
+	struct gf_poly *tmp;
+
+	dbg("gcd(%s,%s)=", gf_poly_str(a), gf_poly_str(b));
+
+	if (a->deg < b->deg) {
+		tmp = b;
+		b = a;
+		a = tmp;
+	}
+
+	while (b->deg > 0) {
+		gf_poly_mod(bch, a, b, NULL);
+		tmp = b;
+		b = a;
+		a = tmp;
+	}
+
+	dbg("%s\n", gf_poly_str(a));
+
+	return a;
+}
+
+/*
+ * Given a polynomial f and an integer k, compute Tr(a^kX) mod f
+ * This is used in Berlekamp Trace algorithm for splitting polynomials
+ */
+static void compute_trace_bk_mod(struct bch_control *bch, int k,
+				 const struct gf_poly *f, struct gf_poly *z,
+				 struct gf_poly *out)
+{
+	const int m = GF_M(bch);
+	int i, j;
+
+	/* z contains z^2j mod f */
+	z->deg = 1;
+	z->c[0] = 0;
+	z->c[1] = bch->a_pow_tab[k];
+
+	out->deg = 0;
+	memset(out, 0, GF_POLY_SZ(f->deg));
+
+	/* compute f log representation only once */
+	gf_poly_logrep(bch, f, bch->cache);
+
+	for (i = 0; i < m; i++) {
+		/* add a^(k*2^i)(z^(2^i) mod f) and compute (z^(2^i) mod f)^2 */
+		for (j = z->deg; j >= 0; j--) {
+			out->c[j] ^= z->c[j];
+			z->c[2*j] = gf_sqr(bch, z->c[j]);
+			z->c[2*j+1] = 0;
+		}
+		if (z->deg > out->deg)
+			out->deg = z->deg;
+
+		if (i < m-1) {
+			z->deg *= 2;
+			/* z^(2(i+1)) mod f = (z^(2^i) mod f)^2 mod f */
+			gf_poly_mod(bch, z, f, bch->cache);
+		}
+	}
+	while (!out->c[out->deg] && out->deg)
+		out->deg--;
+
+	dbg("Tr(a^%d.X) mod f = %s\n", k, gf_poly_str(out));
+}
+
+/*
+ * factor a polynomial using Berlekamp Trace algorithm (BTA)
+ */
+static void factor_polynomial(struct bch_control *bch, int k, struct gf_poly *f,
+			      struct gf_poly **g, struct gf_poly **h)
+{
+	struct gf_poly *f2 = bch->poly_2t[0];
+	struct gf_poly *q  = bch->poly_2t[1];
+	struct gf_poly *tk = bch->poly_2t[2];
+	struct gf_poly *z  = bch->poly_2t[3];
+	struct gf_poly *gcd;
+
+	dbg("factoring %s...\n", gf_poly_str(f));
+
+	*g = f;
+	*h = NULL;
+
+	/* tk = Tr(a^k.X) mod f */
+	compute_trace_bk_mod(bch, k, f, z, tk);
+
+	if (tk->deg > 0) {
+		/* compute g = gcd(f, tk) (destructive operation) */
+		gf_poly_copy(f2, f);
+		gcd = gf_poly_gcd(bch, f2, tk);
+		if (gcd->deg < f->deg) {
+			/* compute h=f/gcd(f,tk); this will modify f and q */
+			gf_poly_div(bch, f, gcd, q);
+			/* store g and h in-place (clobbering f) */
+			*h = &((struct gf_poly_deg1 *)f)[gcd->deg].poly;
+			gf_poly_copy(*g, gcd);
+			gf_poly_copy(*h, q);
+		}
+	}
+}
+
+/*
+ * find roots of a polynomial, using BTZ algorithm; see the beginning of this
+ * file for details
+ */
+static int find_poly_roots(struct bch_control *bch, unsigned int k,
+			   struct gf_poly *poly, unsigned int *roots)
+{
+	int cnt;
+	struct gf_poly *f1, *f2;
+
+	switch (poly->deg) {
+		/* handle low degree polynomials with ad hoc techniques */
+	case 1:
+		cnt = find_poly_deg1_roots(bch, poly, roots);
+		break;
+	case 2:
+		cnt = find_poly_deg2_roots(bch, poly, roots);
+		break;
+	case 3:
+		cnt = find_poly_deg3_roots(bch, poly, roots);
+		break;
+	case 4:
+		cnt = find_poly_deg4_roots(bch, poly, roots);
+		break;
+	default:
+		/* factor polynomial using Berlekamp Trace Algorithm (BTA) */
+		cnt = 0;
+		if (poly->deg && (k <= GF_M(bch))) {
+			factor_polynomial(bch, k, poly, &f1, &f2);
+			if (f1)
+				cnt += find_poly_roots(bch, k+1, f1, roots);
+			if (f2)
+				cnt += find_poly_roots(bch, k+1, f2, roots+cnt);
+		}
+		break;
+	}
+	return cnt;
+}
+
+#if defined(USE_CHIEN_SEARCH)
+/*
+ * exhaustive root search (Chien) implementation - not used, included only for
+ * reference/comparison tests
+ */
+static int chien_search(struct bch_control *bch, unsigned int len,
+			struct gf_poly *p, unsigned int *roots)
+{
+	int m;
+	unsigned int i, j, syn, syn0, count = 0;
+	const unsigned int k = 8*len+bch->ecc_bits;
+
+	/* use a log-based representation of polynomial */
+	gf_poly_logrep(bch, p, bch->cache);
+	bch->cache[p->deg] = 0;
+	syn0 = gf_div(bch, p->c[0], p->c[p->deg]);
+
+	for (i = GF_N(bch)-k+1; i <= GF_N(bch); i++) {
+		/* compute elp(a^i) */
+		for (j = 1, syn = syn0; j <= p->deg; j++) {
+			m = bch->cache[j];
+			if (m >= 0)
+				syn ^= a_pow(bch, m+j*i);
+		}
+		if (syn == 0) {
+			roots[count++] = GF_N(bch)-i;
+			if (count == p->deg)
+				break;
+		}
+	}
+	return (count == p->deg) ? count : 0;
+}
+#define find_poly_roots(_p, _k, _elp, _loc) chien_search(_p, len, _elp, _loc)
+#endif /* USE_CHIEN_SEARCH */
+
+/**
+ * decode_bch - decode received codeword and find bit error locations
+ * @bch:      BCH control structure
+ * @data:     received data, ignored if @calc_ecc is provided
+ * @len:      data length in bytes, must always be provided
+ * @recv_ecc: received ecc, if NULL then assume it was XORed in @calc_ecc
+ * @calc_ecc: calculated ecc, if NULL then calc_ecc is computed from @data
+ * @syn:      hw computed syndrome data (if NULL, syndrome is calculated)
+ * @errloc:   output array of error locations
+ *
+ * Returns:
+ *  The number of errors found, or -EBADMSG if decoding failed, or -EINVAL if
+ *  invalid parameters were provided
+ *
+ * Depending on the available hw BCH support and the need to compute @calc_ecc
+ * separately (using encode_bch()), this function should be called with one of
+ * the following parameter configurations -
+ *
+ * by providing @data and @recv_ecc only:
+ *   decode_bch(@bch, @data, @len, @recv_ecc, NULL, NULL, @errloc)
+ *
+ * by providing @recv_ecc and @calc_ecc:
+ *   decode_bch(@bch, NULL, @len, @recv_ecc, @calc_ecc, NULL, @errloc)
+ *
+ * by providing ecc = recv_ecc XOR calc_ecc:
+ *   decode_bch(@bch, NULL, @len, NULL, ecc, NULL, @errloc)
+ *
+ * by providing syndrome results @syn:
+ *   decode_bch(@bch, NULL, @len, NULL, NULL, @syn, @errloc)
+ *
+ * Once decode_bch() has successfully returned with a positive value, error
+ * locations returned in array @errloc should be interpreted as follows -
+ *
+ * if (errloc[n] >= 8*len), then n-th error is located in ecc (no need for
+ * data correction)
+ *
+ * if (errloc[n] < 8*len), then n-th error is located in data and can be
+ * corrected with statement data[errloc[n]/8] ^= 1 << (errloc[n] % 8);
+ *
+ * Note that this function does not perform any data correction by itself, it
+ * merely indicates error locations.
+ */
+int decode_bch(struct bch_control *bch, const uint8_t *data, unsigned int len,
+	       const uint8_t *recv_ecc, const uint8_t *calc_ecc,
+	       const unsigned int *syn, unsigned int *errloc)
+{
+	const unsigned int ecc_words = BCH_ECC_WORDS(bch);
+	unsigned int nbits;
+	int i, err, nroots;
+	uint32_t sum;
+
+	/* sanity check: make sure data length can be handled */
+	if (8*len > (bch->n-bch->ecc_bits))
+		return -EINVAL;
+
+	/* if caller does not provide syndromes, compute them */
+	if (!syn) {
+		if (!calc_ecc) {
+			/* compute received data ecc into an internal buffer */
+			if (!data || !recv_ecc)
+				return -EINVAL;
+			encode_bch(bch, data, len, NULL);
+		} else {
+			/* load provided calculated ecc */
+			load_ecc8(bch, bch->ecc_buf, calc_ecc);
+		}
+		/* load received ecc or assume it was XORed in calc_ecc */
+		if (recv_ecc) {
+			load_ecc8(bch, bch->ecc_buf2, recv_ecc);
+			/* XOR received and calculated ecc */
+			for (i = 0, sum = 0; i < (int)ecc_words; i++) {
+				bch->ecc_buf[i] ^= bch->ecc_buf2[i];
+				sum |= bch->ecc_buf[i];
+			}
+			if (!sum)
+				/* no error found */
+				return 0;
+		}
+		compute_syndromes(bch, bch->ecc_buf, bch->syn);
+		syn = bch->syn;
+	}
+
+	err = compute_error_locator_polynomial(bch, syn);
+	if (err > 0) {
+		nroots = find_poly_roots(bch, 1, bch->elp, errloc);
+		if (err != nroots)
+			err = -1;
+	}
+	if (err > 0) {
+		/* post-process raw error locations for easier correction */
+		nbits = (len*8)+bch->ecc_bits;
+		for (i = 0; i < err; i++) {
+			if (errloc[i] >= nbits) {
+				err = -1;
+				break;
+			}
+			errloc[i] = nbits-1-errloc[i];
+			errloc[i] = (errloc[i] & ~7)|(7-(errloc[i] & 7));
+		}
+	}
+	return (err >= 0) ? err : -EBADMSG;
+}
+
+/*
+ * generate Galois field lookup tables
+ */
+static int build_gf_tables(struct bch_control *bch, unsigned int poly)
+{
+	unsigned int i, x = 1;
+	const unsigned int k = 1 << deg(poly);
+
+	/* primitive polynomial must be of degree m */
+	if (k != (1u << GF_M(bch)))
+		return -1;
+
+	for (i = 0; i < GF_N(bch); i++) {
+		bch->a_pow_tab[i] = x;
+		bch->a_log_tab[x] = i;
+		if (i && (x == 1))
+			/* polynomial is not primitive (a^i=1 with 0<i<2^m-1) */
+			return -1;
+		x <<= 1;
+		if (x & k)
+			x ^= poly;
+	}
+	bch->a_pow_tab[GF_N(bch)] = 1;
+	bch->a_log_tab[0] = 0;
+
+	return 0;
+}
+
+/*
+ * compute generator polynomial remainder tables for fast encoding
+ */
+static void build_mod8_tables(struct bch_control *bch, const uint32_t *g)
+{
+	int i, j, b, d;
+	uint32_t data, hi, lo, *tab;
+	const int l = BCH_ECC_WORDS(bch);
+	const int plen = DIV_ROUND_UP(bch->ecc_bits+1, 32);
+	const int ecclen = DIV_ROUND_UP(bch->ecc_bits, 32);
+
+	memset(bch->mod8_tab, 0, 4*256*l*sizeof(*bch->mod8_tab));
+
+	for (i = 0; i < 256; i++) {
+		/* p(X)=i is a small polynomial of weight <= 8 */
+		for (b = 0; b < 4; b++) {
+			/* we want to compute (p(X).X^(8*b+deg(g))) mod g(X) */
+			tab = bch->mod8_tab + (b*256+i)*l;
+			data = i << (8*b);
+			while (data) {
+				d = deg(data);
+				/* subtract X^d.g(X) from p(X).X^(8*b+deg(g)) */
+				data ^= g[0] >> (31-d);
+				for (j = 0; j < ecclen; j++) {
+					hi = (d < 31) ? g[j] << (d+1) : 0;
+					lo = (j+1 < plen) ?
+						g[j+1] >> (31-d) : 0;
+					tab[j] ^= hi|lo;
+				}
+			}
+		}
+	}
+}
+
+/*
+ * build a base for factoring degree 2 polynomials
+ */
+static int build_deg2_base(struct bch_control *bch)
+{
+	const int m = GF_M(bch);
+	int i, j, r;
+	unsigned int sum, x, y, remaining, ak = 0, xi[m];
+
+	/* find k s.t. Tr(a^k) = 1 and 0 <= k < m */
+	for (i = 0; i < m; i++) {
+		for (j = 0, sum = 0; j < m; j++)
+			sum ^= a_pow(bch, i*(1 << j));
+
+		if (sum) {
+			ak = bch->a_pow_tab[i];
+			break;
+		}
+	}
+	/* find xi, i=0..m-1 such that xi^2+xi = a^i+Tr(a^i).a^k */
+	remaining = m;
+	memset(xi, 0, sizeof(xi));
+
+	for (x = 0; (x <= GF_N(bch)) && remaining; x++) {
+		y = gf_sqr(bch, x)^x;
+		for (i = 0; i < 2; i++) {
+			r = a_log(bch, y);
+			if (y && (r < m) && !xi[r]) {
+				bch->xi_tab[r] = x;
+				xi[r] = 1;
+				remaining--;
+				dbg("x%d = %x\n", r, x);
+				break;
+			}
+			y ^= ak;
+		}
+	}
+	/* should not happen but check anyway */
+	return remaining ? -1 : 0;
+}
+
+#define bch_alloc(size, err)  malloc(size)
+/*
+static void *bch_alloc(size_t size, int *err)
+{
+	void *ptr;
+
+	ptr = kmalloc(size, GFP_KERNEL);
+	if (ptr == NULL)
+		*err = 1;
+	return ptr;
+}
+*/
+
+/*
+ * compute generator polynomial for given (m,t) parameters.
+ */
+static uint32_t *compute_generator_polynomial(struct bch_control *bch)
+{
+	const unsigned int m = GF_M(bch);
+	const unsigned int t = GF_T(bch);
+	int n, err = 0;
+	unsigned int i, j, nbits, r, word, *roots;
+	struct gf_poly *g;
+	uint32_t *genpoly;
+
+	g = bch_alloc(GF_POLY_SZ(m*t), &err);
+	roots = bch_alloc((bch->n+1)*sizeof(*roots), &err);
+	genpoly = bch_alloc(DIV_ROUND_UP(m*t+1, 32)*sizeof(*genpoly), &err);
+
+	if (err) {
+		kfree(genpoly);
+		genpoly = NULL;
+		goto finish;
+	}
+
+	/* enumerate all roots of g(X) */
+	memset(roots , 0, (bch->n+1)*sizeof(*roots));
+	for (i = 0; i < t; i++) {
+		for (j = 0, r = 2*i+1; j < m; j++) {
+			roots[r] = 1;
+			r = mod_s(bch, 2*r);
+		}
+	}
+	/* build generator polynomial g(X) */
+	g->deg = 0;
+	g->c[0] = 1;
+	for (i = 0; i < GF_N(bch); i++) {
+		if (roots[i]) {
+			/* multiply g(X) by (X+root) */
+			r = bch->a_pow_tab[i];
+			g->c[g->deg+1] = 1;
+			for (j = g->deg; j > 0; j--)
+				g->c[j] = gf_mul(bch, g->c[j], r)^g->c[j-1];
+
+			g->c[0] = gf_mul(bch, g->c[0], r);
+			g->deg++;
+		}
+	}
+	/* store left-justified binary representation of g(X) */
+	n = g->deg+1;
+	i = 0;
+
+	while (n > 0) {
+		nbits = (n > 32) ? 32 : n;
+		for (j = 0, word = 0; j < nbits; j++) {
+			if (g->c[n-1-j])
+				word |= 1u << (31-j);
+		}
+		genpoly[i++] = word;
+		n -= nbits;
+	}
+	bch->ecc_bits = g->deg;
+
+finish:
+	kfree(g);
+	kfree(roots);
+
+	return genpoly;
+}
+
+/**
+ * init_bch - initialize a BCH encoder/decoder
+ * @m:          Galois field order, should be in the range 5-15
+ * @t:          maximum error correction capability, in bits
+ * @prim_poly:  user-provided primitive polynomial (or 0 to use default)
+ *
+ * Returns:
+ *  a newly allocated BCH control structure if successful, NULL otherwise
+ *
+ * This initialization can take some time, as lookup tables are built for fast
+ * encoding/decoding; make sure not to call this function from a time critical
+ * path. Usually, init_bch() should be called on module/driver init and
+ * free_bch() should be called to release memory on exit.
+ *
+ * You may provide your own primitive polynomial of degree @m in argument
+ * @prim_poly, or let init_bch() use its default polynomial.
+ *
+ * Once init_bch() has successfully returned a pointer to a newly allocated
+ * BCH control structure, ecc length in bytes is given by member @ecc_bytes of
+ * the structure.
+ */
+struct bch_control *init_bch(int m, int t, unsigned int prim_poly)
+{
+	int err = 0;
+	unsigned int i, words;
+	uint32_t *genpoly;
+	struct bch_control *bch = NULL;
+
+	const int min_m = 5;
+	const int max_m = 15;
+
+	/* default primitive polynomials */
+	static const unsigned int prim_poly_tab[] = {
+		0x25, 0x43, 0x83, 0x11d, 0x211, 0x409, 0x805, 0x1053, 0x201b,
+		0x402b, 0x8003,
+	};
+
+/*#if defined(CONFIG_BCH_CONST_PARAMS)
+	if ((m != (CONFIG_BCH_CONST_M)) || (t != (CONFIG_BCH_CONST_T))) {
+		printk(KERN_ERR "bch encoder/decoder was configured to support "
+		       "parameters m=%d, t=%d only!\n",
+		       CONFIG_BCH_CONST_M, CONFIG_BCH_CONST_T);
+		goto fail;
+	}
+#endif*/
+	if ((m < min_m) || (m > max_m))
+		/*
+		 * values of m greater than 15 are not currently supported;
+		 * supporting m > 15 would require changing table base type
+		 * (uint16_t) and a small patch in matrix transposition
+		 */
+		goto fail;
+
+	/* sanity checks */
+	if ((t < 1) || (m*t >= ((1 << m)-1)))
+		/* invalid t value */
+		goto fail;
+
+	/* select a primitive polynomial for generating GF(2^m) */
+	if (prim_poly == 0)
+		prim_poly = prim_poly_tab[m-min_m];
+
+	bch = kzalloc(sizeof(*bch), GFP_KERNEL);
+	if (bch == NULL)
+		goto fail;
+
+	bch->m = m;
+	bch->t = t;
+	bch->n = (1 << m)-1;
+	words  = DIV_ROUND_UP(m*t, 32);
+	bch->ecc_bytes = DIV_ROUND_UP(m*t, 8);
+	bch->a_pow_tab = bch_alloc((1+bch->n)*sizeof(*bch->a_pow_tab), &err);
+	bch->a_log_tab = bch_alloc((1+bch->n)*sizeof(*bch->a_log_tab), &err);
+	bch->mod8_tab  = bch_alloc(words*1024*sizeof(*bch->mod8_tab), &err);
+	bch->ecc_buf   = bch_alloc(words*sizeof(*bch->ecc_buf), &err);
+	bch->ecc_buf2  = bch_alloc(words*sizeof(*bch->ecc_buf2), &err);
+	bch->xi_tab    = bch_alloc(m*sizeof(*bch->xi_tab), &err);
+	bch->syn       = bch_alloc(2*t*sizeof(*bch->syn), &err);
+	bch->cache     = bch_alloc(2*t*sizeof(*bch->cache), &err);
+	bch->elp       = bch_alloc((t+1)*sizeof(struct gf_poly_deg1), &err);
+
+	for (i = 0; i < ARRAY_SIZE(bch->poly_2t); i++)
+		bch->poly_2t[i] = bch_alloc(GF_POLY_SZ(2*t), &err);
+
+	if (err)
+		goto fail;
+
+	err = build_gf_tables(bch, prim_poly);
+	if (err)
+		goto fail;
+
+	/* use generator polynomial for computing encoding tables */
+	genpoly = compute_generator_polynomial(bch);
+	if (genpoly == NULL)
+		goto fail;
+
+	build_mod8_tables(bch, genpoly);
+	kfree(genpoly);
+
+	err = build_deg2_base(bch);
+	if (err)
+		goto fail;
+
+	return bch;
+
+fail:
+	free_bch(bch);
+	return NULL;
+}
+
+/**
+ *  free_bch - free the BCH control structure
+ *  @bch:    BCH control structure to release
+ */
+void free_bch(struct bch_control *bch)
+{
+	unsigned int i;
+
+	if (bch) {
+		kfree(bch->a_pow_tab);
+		kfree(bch->a_log_tab);
+		kfree(bch->mod8_tab);
+		kfree(bch->ecc_buf);
+		kfree(bch->ecc_buf2);
+		kfree(bch->xi_tab);
+		kfree(bch->syn);
+		kfree(bch->cache);
+		kfree(bch->elp);
+
+		for (i = 0; i < ARRAY_SIZE(bch->poly_2t); i++)
+			kfree(bch->poly_2t[i]);
+
+		kfree(bch);
+	}
+}
diff --git a/driver/dataflash.c b/driver/dataflash.c
deleted file mode 100644
index 73c968a..0000000
--- a/driver/dataflash.c
+++ /dev/null
@@ -1,618 +0,0 @@
-/* ----------------------------------------------------------------------------
- *         ATMEL Microcontroller Software Support
- * ----------------------------------------------------------------------------
- * Copyright (c) 2008, Atmel Corporation
-
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the disclaimer below.
- *
- * Atmel's name may not be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
- * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "common.h"
-#include "hardware.h"
-#include "board.h"
-#include "spi.h"
-#include "arch/at91_pio.h"
-#include "gpio.h"
-#include "string.h"
-#include "timer.h"
-
-#include "debug.h"
-
-/* Manufacturer Device ID Read */
-#define CMD_READ_DEV_ID			0x9f
-/* Continuous Array Read */
-#define CMD_READ_ARRAY_FAST		0x0b
-
-/* JEDEC Code */
-#define MANUFACTURER_ID_ATMEL		0x1f
-
-/* Family Code */
-#define DF_FAMILY_AT26F			0x00
-#define DF_FAMILY_AT45			0x20
-#define DF_FAMILY_AT26DF		0x40	/* AT25DF and AT26DF */
-
-/* AT45 Density Code */
-#define DENSITY_AT45DB011D		0x0C
-#define DENSITY_AT45DB021D		0x14
-#define DENSITY_AT45DB041D		0x1C
-#define DENSITY_AT45DB081D		0x24
-#define DENSITY_AT45DB161D		0x2C
-#define DENSITY_AT45DB321D		0x34
-#define DENSITY_AT45DB642D		0x3C
-#define DENSITY_AT45DB1282D		0x10
-#define DENSITY_AT45DB2562D		0x18
-#define DENSITY_AT45DB5122D		0x20
-
-/* AT45 Status Register Read */
-#define CMD_READ_STATUS_AT45		0xd7
-
-/* AT45 status register bits */
-#define STATUS_PAGE_SIZE_AT45		(1 << 0)
-#define STATUS_READY_AT45		(1 << 7)
-
-struct dataflash_descriptor;
-
-struct dataflash_descriptor {
-	unsigned char	family;
-
-	unsigned int	pages;		/* page number */
-	unsigned int	page_size;	/* page size */
-	unsigned int	page_offset;	/* page offset in command */
-	unsigned char	is_power_2;	/* = 1: power of 2, = 0: not*/
-};
-
-static int df_send_command(unsigned char *cmd,
-				unsigned char cmd_len,
-				unsigned char *data,
-				unsigned int data_len)
-{
-	int i;
-
-	if (!cmd)
-		return -1;
-
-	if (!cmd_len)
-		return -1;
-
-	if (data_len)
-		if (!data)
-			return -1;
-
-	at91_spi_cs_activate();
-
-	/* read spi status to clear events */
-	at91_spi_read_sr();
-
-	for (i = 0; i < cmd_len; i++) {
-		at91_spi_write_data(*cmd++);
-		at91_spi_read_spi();
-	}
-
-	for (i = 0; i < data_len; i++) {
-		at91_spi_write_data(0);
-		*data++ = at91_spi_read_spi();
-	}
-
-	at91_spi_cs_deactivate();
-
-	return 0;
-}
-
-static int dataflash_read_array(struct dataflash_descriptor *df_desc,
-				unsigned int offset,
-				unsigned int len,
-				void *buf)
-{
-	unsigned char cmd[5];
-	unsigned char cmd_len;
-	unsigned int address;
-	unsigned int page_addr;
-	unsigned int byte_addr;
-	unsigned int page_shift;
-	unsigned int page_size;
-	int ret;
-
-	if (!df_desc->is_power_2) {
-		page_shift = df_desc->page_offset;
-		page_size = df_desc->page_size;
-
-		page_addr = offset / page_size;
-		byte_addr = offset % page_size;
-
-		address = (page_addr << page_shift) + byte_addr;
-	} else
-		address = offset;
-
-	cmd[0] = CMD_READ_ARRAY_FAST;
-	if (df_desc->pages > 16384) {
-		cmd[1] = (unsigned char)(address >> 24);
-		cmd[2] = (unsigned char)(address >> 16);
-		cmd[3] = (unsigned char)(address >> 8);
-		cmd[4] = (unsigned char)address;
-
-	} else {
-		cmd[1] = (unsigned char)(address >> 16);
-		cmd[2] = (unsigned char)(address >> 8);
-		cmd[3] = (unsigned char)address;
-		cmd[4] = 0x00;
-	}
-
-	cmd_len = 5;
-
-	ret = df_send_command(cmd, cmd_len, buf, len);
-	if (ret)
-		return -1;
-
-	return 0;
-}
-
-static unsigned char df_read_status_at45(unsigned char *status)
-{
-	unsigned char cmd = CMD_READ_STATUS_AT45;
-	int ret;
-
-	ret = df_send_command(&cmd, 1, status, 1);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-#ifdef CONFIG_DATAFLASH_RECOVERY
-
-/* AT25 Block Erase(4-KBytes) Command*/
-#define CMD_ERASE_BLOCK4K_AT25		0x20
-/* Write Enable Command */
-#define CMD_WRITE_ENABLE_AT25		0x06
-/* Status Register Commands */
-#define CMD_READ_STATUS_AT25		0x05
-#define CMD_WRITE_STATUS_AT25           0x01
-/* Page Erase AT45 */
-#define CMD_ERASE_PAGE_AT45		0x81
-
-/* AT25 status register bits */
-#define STATUS_READY_AT25		(1 << 0)
-#define STATUS_WEL_AT25			(1 << 1)
-#define STATUS_SWP_AT25			(3 << 2)
-#define STATUS_EPE_AT25			(1 << 5)
-#define STATUS_SPRL_AT25		(1 << 7)
-
-static unsigned char df_read_status_at25(unsigned char *status)
-{
-	unsigned char cmd = CMD_READ_STATUS_AT25;
-	int ret;
-
-	ret = df_send_command(&cmd, 1, status, 1);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int at25_cmd_write_enbale(void)
-{
-	unsigned char cmd;
-	int ret;
-
-	cmd = CMD_WRITE_ENABLE_AT25;
-	ret = df_send_command(&cmd, 1, NULL, 0);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int at25_cmd_write_status_register(unsigned char status)
-{
-	unsigned char cmd[2];
-	int ret;
-
-	cmd[0] = CMD_WRITE_STATUS_AT25;
-	cmd[1] = status;
-
-	ret = df_send_command(cmd, 2, NULL, 0);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int at25_unprotect(void)
-{
-	unsigned char status;
-	int ret;
-
-	/* read status register */
-	ret = df_read_status_at25(&status);
-	if (ret)
-		return ret;
-
-	/* check if All sectors are software unprotected
-	 * (all Sector Protection Register are 0)
-	 */
-	if (!(status & STATUS_SWP_AT25))
-		return 0;
-
-	/* check if Sector Protection Registers are locked */
-	if (status & STATUS_SPRL_AT25) {
-		/* Unprotect Sector Potection Registers. */
-		ret = at25_cmd_write_enbale();
-		if (ret)
-			return ret;
-
-		ret = at25_cmd_write_status_register(0);
-		if (ret)
-			return ret;
-	}
-
-	/* a global unprotect command */
-	ret = at25_cmd_write_enbale();
-	if (ret)
-		return ret;
-
-	ret = at25_cmd_write_status_register(0);
-	if (ret)
-		return ret;
-
-	/* check Status Register SPRL & SWP bits */
-	ret = df_read_status_at25(&status);
-	if (ret)
-		return ret;
-
-	if (status & (STATUS_SPRL_AT25 | STATUS_SWP_AT25)) {
-		dbg_log(1, "SF: Unprotect AT25 failed\n\r");
-		return -1;
-	}
-
-	return 0;
-}
-
-static int dataflash_page0_erase_at25(void)
-{
-	unsigned char status;
-	unsigned char cmd[5];
-	unsigned int timeout = 100;
-	int ret;
-
-	ret = at25_unprotect();
-	if (ret)
-		return ret;
-
-	ret = at25_cmd_write_enbale();
-	if (ret)
-		return ret;
-
-	/* Erase page0 */
-	cmd[0] = CMD_ERASE_BLOCK4K_AT25;
-	cmd[1] = 0;
-	cmd[2] = 0;
-	cmd[3] = 0;
-
-	ret = df_send_command(cmd, 4, NULL, 0);
-	if (ret) {
-		dbg_log(1, "SF: AT25 page 0 erase failed\n\r");
-		return ret;
-	}
-
-	udelay(1000000); /* 1000 ms */
-
-	do {
-		ret = df_read_status_at25(&status);
-		if (ret)
-			return ret;
-
-		if (!(status & STATUS_READY_AT25))
-			break;
-	} while (--timeout);
-
-	if (!timeout) {
-		dbg_log(1, "SF: AT25 page0 erase timed out\n\r");
-		return -1;
-	}
-
-	return 0;
-}
-
-static int dataflash_page0_erase_at45(void)
-{
-	unsigned char status;
-	unsigned char cmd[4];
-	unsigned int timeout = 100;
-	int ret;
-
-	cmd[0] = CMD_ERASE_PAGE_AT45;
-	cmd[1] = 0;
-	cmd[2] = 0;
-	cmd[3] = 0;
-
-	ret = df_send_command(cmd, 4, NULL, 0);
-	if (ret) {
-		dbg_log(1, "SF: AT45 page 0 erase failed\n\r");
-		return ret;
-	}
-
-	udelay(500000); /* 500 ms */
-
-	do {
-		ret = df_read_status_at45(&status);
-		if (ret)
-			return ret;
-
-		if (status & STATUS_READY_AT45)
-			break;
-	} while (--timeout);
-
-	if (!(status & STATUS_READY_AT45)) {
-		dbg_log(1,	"SF: AT45 page0 erase timed out\n\r");
-		return -1;
-	}
-
-	return 0;
-}
-
-static int dataflash_recovery(struct dataflash_descriptor *df_desc)
-{
-	int ret;
-
-	/*
-	 * If Recovery Button is pressed during boot sequence,
-	 * erase dataflash page0
-	*/
-	dbg_log(1, "SF: Press the recovery button (%s) to recovery\n\r",
-			RECOVERY_BUTTON_NAME);
-
-	if ((pio_get_value(CONFIG_SYS_RECOVERY_BUTTON_PIN)) == 0) {
-		dbg_log(1, "SF: The recovery button (%s) has been pressed,\n\r",
-				RECOVERY_BUTTON_NAME);
-		dbg_log(1, "SF: The page 0 is erasing...\n\r");
-
-		if ((df_desc->family == DF_FAMILY_AT26F)
-			|| (df_desc->family == DF_FAMILY_AT26DF))
-			ret = dataflash_page0_erase_at25();
-		 else
-			ret = dataflash_page0_erase_at45();
-
-		if (ret) {
-			dbg_log(1, "SF: The erasing failed\n\r");
-			return ret;
-		}
-		dbg_log(1, "SF: The erasing is done\n\r");
-
-		return 0;
-	}
-
-	return -1;
-}
-#endif /* #ifdef CONFIG_DATAFLASH_RECOVERY */
-
-static int df_at45_desc_init(struct dataflash_descriptor *df_desc)
-{
-	unsigned char status;
-	unsigned char density;
-	int ret;
-
-	ret = df_read_status_at45(&status);
-	if (ret)
-		return ret;
-
-	if (status & STATUS_PAGE_SIZE_AT45)
-		df_desc->is_power_2 = 1;
-	else
-		df_desc->is_power_2 = 0;
-
-	density = status & 0x3c;
-	switch (density) {
-	case DENSITY_AT45DB011D:
-		df_desc->pages = 512;
-		df_desc->page_size = 264;
-		df_desc->page_offset = 9;
-	break;
-
-	case DENSITY_AT45DB021D:
-		df_desc->pages = 1024;
-		df_desc->page_size = 264;
-		df_desc->page_offset = 9;
-		break;
-
-	case DENSITY_AT45DB041D:
-		df_desc->pages = 2048;
-		df_desc->page_size = 264;
-		df_desc->page_offset = 9;
-		break;
-
-	case DENSITY_AT45DB081D:
-		df_desc->pages = 4096;
-		df_desc->page_size = 264;
-		df_desc->page_offset = 9;
-		break;
-
-	case DENSITY_AT45DB161D:
-		df_desc->pages = 4096;
-		df_desc->page_size = 528;
-		df_desc->page_offset = 10;
-		break;
-
-	case DENSITY_AT45DB321D:
-		df_desc->pages = 8192;
-		df_desc->page_size = 528;
-		df_desc->page_offset = 10;
-		break;
-
-	case DENSITY_AT45DB642D:
-		df_desc->pages = 8192;
-		df_desc->page_size = 1056;
-		df_desc->page_offset = 11;
-		break;
-/*
-	case DENSITY_AT45DB1282D:
-		df_desc->pages = 16384;
-		df_desc->pages_size = 1056;
-		df_desc->page_offset = 11;
-		break;
-
-	case DENSITY_AT45DB2562D:
-		df_desc->pages = 16384;
-		df_desc->page_size = 2112;
-		df_desc->page_offset = 12;
-		break;
-
-	case DENSITY_AT45DB5122D:
-		df_desc->pages = 32768;
-		df_desc->page_size = 2112;
-		df_desc->page_offset = 12;
-		break;
-*/
-	default:
-		return -1;
-	}
-
-	return 0;
-}
-
-static int df_at25_desc_init(struct dataflash_descriptor *df_desc)
-{
-	/* AT25DF321 */
-	df_desc->is_power_2 = 1;
-
-	df_desc->pages = 16384;
-	df_desc->page_size = 256;
-	df_desc->page_offset = 0;
-
-	return 0;
-}
-
-static int df_desc_init(struct dataflash_descriptor *df_desc,
-			unsigned char family)
-{
-	int ret;
-
-	df_desc->family = family;
-
-	if ((df_desc->family == DF_FAMILY_AT26F)
-		|| (df_desc->family == DF_FAMILY_AT26DF)) {
-		ret = df_at25_desc_init(df_desc);
-		if (ret)
-			return ret;
-	} else if (df_desc->family == DF_FAMILY_AT45) {
-		ret = df_at45_desc_init(df_desc);
-		if (ret)
-			return ret;
-	} else {
-		dbg_log(1, "SF: Unsupported SerialFlash family %d\n\r", family);
-		return -1;
-	}
-
-	return 0;
-}
-
-static int dataflash_probe_atmel(struct dataflash_descriptor *df_desc)
-{
-	unsigned char dev_id[5];
-	unsigned char cmd = CMD_READ_DEV_ID;
-	int ret;
-
-	/* Read device ID */
-	ret = df_send_command(&cmd, 1, dev_id, 5);
-	if (ret)
-		return ret;
-
-#ifdef CONFIG_DEBUG
-	unsigned int i;
-	unsigned char *p = dev_id;
-
-	dbg_log(1, "SF: Got Manufacturer and Device ID:");
-	for (i = 0; i < 5; i++)
-		dbg_log(1, "%d ", *p++);
-	dbg_log(1, "\n\r");
-#endif
-
-	if (dev_id[0] != MANUFACTURER_ID_ATMEL) {
-		dbg_log(1, "Not supported spi flash Manufactorer ID: %d\n\r",
-				dev_id[0]);
-		return -1;
-	}
-
-	ret = df_desc_init(df_desc, (dev_id[1] & 0xe0));
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-int load_dataflash(struct image_info *image)
-{
-	struct dataflash_descriptor	df_descriptor;
-	struct dataflash_descriptor	*df_desc = &df_descriptor;
-	int ret = 0;
-
-	at91_spi0_hw_init();
-
-	ret = at91_spi_init(AT91C_SPI_PCS_DATAFLASH,
-				CONFIG_SYS_SPI_CLOCK, CONFIG_SYS_SPI_MODE);
-	if (ret) {
-		dbg_log(1, "SF: Fail to initialize spi\n\r");
-		return -1;
-	}
-
-	at91_spi_enable();
-
-	ret = dataflash_probe_atmel(df_desc);
-	if (ret) {
-		dbg_log(1, "SF: Fail to probe atmel spi flash\n\r");
-		ret = -1;
-		goto err_exit;
-	}
-
-#ifdef CONFIG_DATAFLASH_RECOVERY
-	if (!dataflash_recovery(df_desc)) {
-		ret = -2;
-		goto err_exit;
-	}
-#endif
-
-	dbg_log(1, "SF: Copy %d bytes from %d to %d\n\r",
-			image->length, image->offset, image->dest);
-
-	ret = dataflash_read_array(df_desc,
-			image->offset, image->length, image->dest);
-	if (ret) {
-		dbg_log(1, "** SF: Serial flash read error**\n\r");
-		ret = -1;
-		goto err_exit;
-	}
-
-	if (image->of) {
-		dbg_log(1, "SF: dt blob: Copy %d bytes from %d to %d\n\r",
-			image->of_length, image->of_offset, image->of_dest);
-
-		ret = dataflash_read_array(df_desc,
-			image->of_offset, image->of_length, image->of_dest);
-		if (ret) {
-			dbg_log(1, "** SF: DT: Serial flash read error**\n\r");
-			ret = -1;
-			goto err_exit;
-		}
-	}
-
-err_exit:
-	at91_spi_disable();
-	return ret;
-}
diff --git a/driver/dbgu.c b/driver/dbgu.c
old mode 100644
new mode 100755
index 3171250..46bc93b
--- a/driver/dbgu.c
+++ b/driver/dbgu.c
@@ -65,6 +65,7 @@ void dbgu_print(const char *ptr)
 		write_dbgu(DBGU_THR, ptr[i]);
 		i++;
 	}
+	while (!(read_dbgu(DBGU_CSR) & AT91C_DBGU_TXEMPTY)) ;
 }
 
 char dbgu_getc(void)
diff --git a/driver/ddramc.c b/driver/ddramc.c
old mode 100644
new mode 100755
index a6ec767..573b12e
--- a/driver/ddramc.c
+++ b/driver/ddramc.c
@@ -33,7 +33,6 @@
 #include "arch/at91_ccfg.h"
 #include "debug.h"
 #include "ddramc.h"
-#include "timer.h"
 
 /* write DDRC register */
 static void write_ddramc(unsigned int address,
@@ -98,7 +97,7 @@ int ddram_initialize(unsigned int base_address,
 
 	/* A minimum pause wait 200 us is provided to precede any signal toggle.
 	(6 core cycles per iteration, core is at 396MHz: min 13340 loops) */
-	udelay(200);
+	delay(13340);
 
 	/*
 	 * Step 4:  An NOP command is issued to the DDR2-SDRAM
@@ -107,7 +106,7 @@ int ddram_initialize(unsigned int base_address,
 	*((unsigned volatile int *)ram_address) = 0;
 	/* Now, CKE is driven high */
 	/* wait 400 ns min */
-	udelay(1);
+	delay(27);
 
 	/*
 	 * Step 5: An all banks precharge command is issued to the DDR2-SDRAM.
@@ -116,7 +115,7 @@ int ddram_initialize(unsigned int base_address,
 	*((unsigned volatile int *)ram_address) = 0;
 
 	/* wait 2 cycles min (of tCK) = 15 ns min */
-	udelay(1);
+	delay(2);
 
 	/*
 	 * Step 6: An Extended Mode Register set(EMRS2) cycle is issued to chose between commercial or high
@@ -128,7 +127,7 @@ int ddram_initialize(unsigned int base_address,
 	*((unsigned int *)(ram_address + (0x2 << ba_offset))) = 0;
 
 	/* wait 2 cycles min (of tCK) = 15 ns min */
-	udelay(1);
+	delay(2);
 
 	/*
 	 * Step 7: An Extended Mode Register set(EMRS3) cycle is issued
@@ -140,7 +139,7 @@ int ddram_initialize(unsigned int base_address,
 	*((unsigned int *)(ram_address + (0x3 << ba_offset))) = 0;
 
 	/* wait 2 cycles min (of tCK) = 15 ns min */
-	udelay(1);
+	delay(2);
 
 	/*
 	 * Step 8: An Extened Mode Register set(EMRS1) cycle is issued to enable DLL,
@@ -152,7 +151,7 @@ int ddram_initialize(unsigned int base_address,
 	*((unsigned int *)(ram_address + (0x1 << ba_offset))) = 0;
 
 	/* An additional 200 cycles of clock are required for locking DLL */
-	udelay(1);
+	delay(100);
 
 	/*
 	 * Step 9: Program DLL field into the Configuration Register to high(Enable DLL reset)
@@ -169,7 +168,7 @@ int ddram_initialize(unsigned int base_address,
 	*((unsigned int *)(ram_address + (0x0 << ba_offset))) = 0;
 
 	/* wait 2 cycles min (of tCK) = 15 ns min */
-	udelay(1);
+	delay(2);
 
 	/*
 	 * Step 11: An all banks precharge command is issued to the DDR2-SDRAM.
@@ -178,7 +177,7 @@ int ddram_initialize(unsigned int base_address,
 	*(((unsigned volatile int *)ram_address)) = 0;
 
 	/* wait 400 ns min (not needed on certain DDR2 devices) */
-	udelay(1);
+	delay(27);
 
 	/*
 	 * Step 12: Two auto-refresh (CBR) cycles are provided.
@@ -188,14 +187,14 @@ int ddram_initialize(unsigned int base_address,
 	*(((unsigned volatile int *)ram_address)) = 0;
 
 	/* wait TRFC cycles min (135 ns min) extended to 400 ns */
-	udelay(1);
+	delay(27);
 
 	/* Set 2nd CBR */
 	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_RFSH_CMD);
 	*(((unsigned volatile int *)ram_address)) = 0;
 
 	/* wait TRFC cycles min (135 ns min) extended to 400 ns */
-	udelay(1);
+	delay(27);
 
 	/*
 	 * Step 13: Program DLL field into the Configuration Register to low(Disable DLL reset).
@@ -214,7 +213,7 @@ int ddram_initialize(unsigned int base_address,
 	*((unsigned int *)(ram_address + (0x0 << ba_offset))) = 0;
 
 	/* wait 2 cycles min (of tCK) = 15 ns min */
-	udelay(1);
+	delay(2);
 
 	/*
 	 * Step 15: Program OCD field into the Configuration Register
@@ -224,7 +223,7 @@ int ddram_initialize(unsigned int base_address,
 	write_ddramc(base_address, HDDRSDRC2_CR, cr | AT91C_DDRC2_OCD_DEFAULT);
 
 	/* wait 2 cycles min (of tCK) = 15 ns min */
-	udelay(1);
+	delay(2);
 
 	/*
 	 * Step 16: An Extended Mode Register set (EMRS1) cycle is issued to OCD default value.
@@ -235,7 +234,7 @@ int ddram_initialize(unsigned int base_address,
 	*((unsigned int *)(ram_address + (0x1 << ba_offset))) = 0;
 
 	/* wait 2 cycles min (of tCK) = 15 ns min */
-	udelay(1);
+	delay(2);
 
 	/*
 	 * Step 17: Program OCD field into the Configuration Register
@@ -245,7 +244,7 @@ int ddram_initialize(unsigned int base_address,
 	write_ddramc(base_address, HDDRSDRC2_CR, cr & (~AT91C_DDRC2_OCD_DEFAULT));
 
 	/* wait 2 cycles min (of tCK) = 15 ns min */
-	udelay(1);
+	delay(2);
 
 	/*
 	 * Step 18: An Extended Mode Register set (EMRS1) cycle is issued to enable OCD exit.
@@ -256,7 +255,7 @@ int ddram_initialize(unsigned int base_address,
 	*((unsigned int *)(ram_address + (0x1 << ba_offset))) = 0;
 
 	/* wait 2 cycles min (of tCK) = 15 ns min */
-	udelay(1);
+	delay(2);
 
 	/*
 	 * Step 19: A Nornal mode command is provided.
@@ -278,7 +277,7 @@ int ddram_initialize(unsigned int base_address,
 	 * Now we are ready to work on the DDRSDR
 	 *  wait for end of calibration
 	 */
-	udelay(10);
+	delay(500);
 
 	return 0;
 }
diff --git a/driver/debug.c b/driver/debug.c
old mode 100644
new mode 100755
diff --git a/driver/driver.mk b/driver/driver.mk
old mode 100644
new mode 100755
index b3572e3..66faf07
--- a/driver/driver.mk
+++ b/driver/driver.mk
@@ -4,15 +4,14 @@
 DRIVERS:=
 DRIVERS_SRC:=$(TOPDIR)/driver
 
+COBJS-$(CONFIG_DEBUG)		+= $(DRIVERS_SRC)/dbgu.o
 COBJS-$(CONFIG_DEBUG)		+= $(DRIVERS_SRC)/debug.o
 
 COBJS-$(CONFIG_SCLK)		+= $(DRIVERS_SRC)/at91_slowclk.o
+COBJS-$(CONFIG_SCLK)		+= $(DRIVERS_SRC)/at91_pit.o
 
 COBJS-y				+= $(DRIVERS_SRC)/at91_pio.o
 COBJS-y				+= $(DRIVERS_SRC)/pmc.o
-COBJS-y				+= $(DRIVERS_SRC)/at91_pit.o
-COBJS-y				+= $(DRIVERS_SRC)/at91_wdt.o
-COBJS-y				+= $(DRIVERS_SRC)/dbgu.o
 
 COBJS-$(CONFIG_USER_HW_INIT)	+= $(DRIVERS_SRC)/hw_init_hook.o
 
@@ -21,8 +20,6 @@ COBJS-$(CONFIG_SDDRC)		+= $(DRIVERS_SRC)/sddrc.o
 COBJS-$(CONFIG_DDR2)		+= $(DRIVERS_SRC)/ddramc.o
 
 COBJS-$(CONFIG_SDCARD)		+= $(DRIVERS_SRC)/at91_mci.o
-
-COBJS-$(CONFIG_SDCARD)		+= $(DRIVERS_SRC)/mci_media.o
 COBJS-$(CONFIG_SDCARD)		+= $(DRIVERS_SRC)/sdcard.o
 
 ifeq ($(CONFIG_BOARD), "at91sam9260ek")
@@ -30,13 +27,21 @@ COBJS-$(CONFIG_NANDFLASH)	+= $(DRIVERS_SRC)/nandflash_9260.o
 else
 COBJS-$(CONFIG_NANDFLASH)	+= $(DRIVERS_SRC)/nandflash.o
 endif
-COBJS-$(CONFIG_ENABLE_SW_ECC) 	+= $(DRIVERS_SRC)/hamming.o
+
+ifeq ($(CONFIG_ENABLE_SW_ECC), y)
+ifeq ($(CONFIG_ENABLE_SW_ECC_BCH), y)
+COBJS-y += $(DRIVERS_SRC)/bch.o $(TOPDIR)/glue.o
+else
+COBJS-y	+= $(DRIVERS_SRC)/hamming.o
+endif
+endif
 
 COBJS-$(CONFIG_DATAFLASH)	+= $(DRIVERS_SRC)/at91_spi.o
-COBJS-$(CONFIG_DATAFLASH)	+= $(DRIVERS_SRC)/dataflash.o
+COBJS-$(CONFIG_DATAFLASH)	+= $(DRIVERS_SRC)/serial_flash.o
 
 COBJS-$(CONFIG_FLASH)		+= $(DRIVERS_SRC)/flash.o
 
 COBJS-$(CONFIG_LOAD_LINUX)	+= $(DRIVERS_SRC)/load_kernel.o
 
-COBJS-$(CONFIG_LOAD_ONE_WIRE)	+= $(DRIVERS_SRC)/ds24xx.o
+# Currently, 9x5 only
+COBJS-$(CONFIG_AT91SAM9X5EK)	+= $(DRIVERS_SRC)/ds24xx.o
diff --git a/driver/driver_cpp.mk b/driver/driver_cpp.mk
old mode 100644
new mode 100755
index 8e08852..a9e956d
--- a/driver/driver_cpp.mk
+++ b/driver/driver_cpp.mk
@@ -70,12 +70,12 @@ ifeq ($(CONFIG_LOAD_LINUX),y)
 CPPFLAGS += -DCONFIG_LOAD_LINUX
 endif
 
-ifeq ($(CONFIG_SDCARD_HS),y)
-CPPFLAGS += -DCONFIG_SDCARD_HS
+ifeq ($(CONFIG_LINUX_DT),y)
+CPPFLAGS += -DCONFIG_LINUX_DT
 endif
 
-ifeq ($(CONFIG_OF_LIBFDT),y)
-CPPFLAGS += -DCONFIG_OF_LIBFDT
+ifeq ($(CONFIG_SDCARD_HS),y)
+CPPFLAGS += -DCONFIG_SDCARD_HS
 endif
 
 # Dataflash support
@@ -107,6 +107,13 @@ ifeq ($(CONFIG_ENABLE_SW_ECC), y)
 CPPFLAGS += -DCONFIG_ENABLE_SW_ECC
 endif
 
+ifeq ($(CONFIG_ENABLE_SW_ECC_BCH), y)
+CPPFLAGS += -DCONFIG_ENABLE_SW_ECC_BCH
+CPPFLAGS += -DCONFIG_BCH_CONST_PARAMS
+CPPFLAGS += -DCONFIG_BCH_CONST_M=$(shell python -c "import math;print math.trunc(math.log($(SW_ECC_BCH_BLOCKSIZE)*8,2)+1)")
+CPPFLAGS += -DCONFIG_BCH_CONST_T=$(SW_ECC_BCH_BITS)
+endif
+
 ifeq ($(CONFIG_NANDFLASH_RECOVERY),y)
 CPPFLAGS += -DCONFIG_NANDFLASH_RECOVERY
 endif
@@ -123,7 +130,3 @@ endif
 ifeq ($(CONFIG_DEBUG_VERY_LOUD),y)
 CPPFLAGS += -DBOOTSTRAP_DEBUG_LEVEL=DEBUG_VERY_LOUD
 endif
-
-ifeq ($(CONFIG_DISABLE_WATCHDOG),y)
-CPPFLAGS += -DCONFIG_DISABLE_WATCHDOG
-endif
diff --git a/driver/ds24xx.c b/driver/ds24xx.c
old mode 100644
new mode 100755
index d68a9bf..a95c7fe
--- a/driver/ds24xx.c
+++ b/driver/ds24xx.c
@@ -25,15 +25,12 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "common.h"
-#include "hardware.h"
-#include "board.h"
-#include "arch/at91_pio.h"
 #include "gpio.h"
+#include "pmc.h"
 #include "debug.h"
-#include "timer.h"
-#include "string.h"
+#include "hardware.h"
 #include "onewire_info.h"
+#include "string.h"
 
 #define ROM_COMMAND_READ		0x33
 #define ROM_COMMAND_MATCH		0x55
@@ -60,7 +57,10 @@
 
 #define FAMILY_CODE_DS2431		0x2D
 #define FAMILY_CODE_DS2433		0x23
-#define FAMILY_CODE_DS28EC		0x43
+#define DS2431_SIZE_BYTES		0x88
+#define DS2433_SIZE_BYTES		0x200
+#define DS2431_SCRATCHPAD_SIZE		0x8
+#define DS2433_SCRATCHPAD_SIZE		0x20
 
 #define MAX_RETRY			10
 #define MAX_BUF_LEN			256
@@ -83,44 +83,53 @@
 #define CM_REV_MASK			0x1F
 #define CM_REV_OFFSET			0
 
-#define LEN_ONE_WIRE_INFO		0x20
-
-/*  */
-struct one_wire_info {
-	unsigned char total_bytes;
-	char vendor_name[VENDOR_NAME_LEN];
-	char vendor_country[VENDOR_COUNTRY_LEN];
-	unsigned char board_name[BOARD_NAME_LEN];
-	unsigned char year;
-	unsigned char week;
-	unsigned char revision_code;
-	unsigned char revision_id;
-	unsigned char reserved;
-};
+#define TRUE    1
+#define FALSE   0
 
-struct ek_boards {
-	char *board_name;
-	unsigned char board_type;
-	unsigned char board_id;
-};
+#define BOARD_MAINOSC   12000000
+#define BOARD_MCK       ((unsigned long)((BOARD_MAINOSC / 3 / 2 / 3) * 200))
 
-struct ek_vendors {
-	char *vendor_name;
-	char vendor_id;
-};
+size_t strlen(const char *str);
+extern char *strcpy(char *dst, const char *src);
+extern int strcmp(const char *p1, const char *p2);
+extern int strncmp(const char *p1, const char *p2, size_t cnt);
+extern void *memset(void *dst, int val, int cnt);
+extern void *memcpy(void *dst, const void *src, int cnt);
 
 static unsigned int sn = 0xffffffff;
 static unsigned int rev = 0xffffffff;
 
+/* global search state */
 static unsigned char device_id_array[MAX_ITEMS][CHIP_ADDR_LEN];
 static unsigned char LastDiscrepancy;
 static unsigned char LastFamilyDiscrepancy;
 static unsigned char LastDeviceFlag;
+static unsigned char crc8;
 
 static unsigned char buf[MAX_BUF_LEN];
 static unsigned char cmp[MAX_BUF_LEN];
 
-static struct ek_boards	board_list[] = {
+static unsigned char board_type, board_id, vendor_id, revision_code, revision_id;
+
+struct one_wire_info {
+	unsigned char total_bytes;
+	char vendor_name[VENDOR_NAME_LEN];
+	char vendor_country[VENDOR_COUNTRY_LEN];
+	char board_name[BOARD_NAME_LEN];
+	unsigned char year;
+	unsigned char week;
+	unsigned char revision_code;
+	unsigned char revision_id;
+	unsigned char reserved;
+	unsigned char checksum_l;
+	unsigned char checksum_h;
+}__attribute__ ((packed));
+
+struct board_info {
+	char *board_name;
+	unsigned char board_type;
+	unsigned char board_id;
+}__attribute__ ((packed)) board_list[] = {
 	{"SAM9x5-EK",		BOARD_TYPE_EK,		0},
 	{"SAM9x5-DM",		BOARD_TYPE_DM,		1},
 	{"SAM9G15-CM",		BOARD_TYPE_CPU,		2},
@@ -128,39 +137,33 @@ static struct ek_boards	board_list[] = {
 	{"SAM9G35-CM",		BOARD_TYPE_CPU,		4},
 	{"SAM9X25-CM",		BOARD_TYPE_CPU,		5},
 	{"SAM9X35-CM",		BOARD_TYPE_CPU,		6},
-	{"PDA-DM",		BOARD_TYPE_DM,		7},
-	{"SAMA5D3x-MB",		BOARD_TYPE_EK,		8},
-	{"SAMA5D3x-DM",		BOARD_TYPE_DM,		9},
-	{"SAMA5D31-CM",		BOARD_TYPE_CPU,		10},
-	{"SAMA5D33-CM",		BOARD_TYPE_CPU,		11},
-	{"SAMA5D34-CM",		BOARD_TYPE_CPU,		12},
-	{"SAMA5D35-CM",		BOARD_TYPE_CPU,		13},
 	{0,			0,			0},
 };
 
-static struct ek_vendors	vendor_list[] = {
+struct vendor_info {
+	char *vendor_name;
+	char vendor_id;
+}__attribute__ ((packed)) vendor_list[] = {
 	{"EMBEST",		VENDOR_EMBEST},
 	{"FLEX",		VENDOR_FLEX},
 	{"RONETIX",		VENDOR_RONETIX},
 	{"COGENT",		VENDOR_COGENT},
-	{"PDA",			VENDOR_PDA},
 	{0,			0},
 };
 
-/*------------------------------------------------*/
 static inline void set_wire_low()
 {
-	pio_set_gpio_output(CONFIG_SYS_ONE_WIRE_PIN, 0);
+	pio_set_gpio_output(AT91C_PIN_PB(18), 0);
 }
 
 static inline void set_wire_input()
 {
-	pio_set_gpio_input(CONFIG_SYS_ONE_WIRE_PIN, 0);
+	pio_set_gpio_input(AT91C_PIN_PB(18), 0);
 }
 
 static inline int read_wire_bit()
 {
-	return pio_get_value(CONFIG_SYS_ONE_WIRE_PIN);
+	return pio_get_value(AT91C_PIN_PB(18));
 }
 
 static unsigned char dscrc_table[] = {
@@ -182,9 +185,20 @@ static unsigned char dscrc_table[] = {
 	116, 42,200,150, 21, 75,169,247,182,232, 10, 84,215,137,107, 53
 };
 
-static unsigned char docrc8(unsigned char crc8, unsigned char value)
+static unsigned char docrc8(unsigned char value)
 {
-	return dscrc_table[crc8 ^ value];
+	crc8 = dscrc_table[crc8 ^ value];
+
+	return crc8;
+}
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int us;
+
+	for(; num > 0; num--)
+		for(us = (BOARD_MCK / 17000000); us > 0; us--)
+			;
 }
 
 static int ds24xx_reset(void)
@@ -192,14 +206,15 @@ static int ds24xx_reset(void)
 	int i;
 
 	set_wire_low();
-	udelay(tRSTL);
+	delay(tRSTL);
 
 	set_wire_input();
-	udelay(tPDH);
+	delay(tPDH);
 
 	i = read_wire_bit();
-	udelay(tPDL);
+	delay(tPDL);
 
+	/* i == 0 means chip presence */
 	return i ^ 1;
 }
 
@@ -207,14 +222,14 @@ static void ds24xx_write_bit(int bit)
 {
 	if (bit == 1) {
 		set_wire_low();
-		udelay(tW1L);
+		delay(tW1L);
 		set_wire_input();
-		udelay(tSLOT-tW1L);
+		delay(tSLOT-tW1L);
 	} else {
 		set_wire_low();
-		udelay(tWOL);
+		delay(tWOL);
 		set_wire_input();
-		udelay(tSLOT-tWOL);
+		delay(tSLOT-tWOL);
 	}
 }
 
@@ -223,13 +238,13 @@ static int ds24xx_read_bit()
 	int status;
 
 	set_wire_low();
-	udelay(tRL);
+	delay(tRL);
 
 	set_wire_input();
-	udelay(tMSR / 2);
+	delay(tMSR / 2);
 
 	status = read_wire_bit();
-	udelay(tSLOT-tRL-tMSR);
+	delay(tSLOT-tRL-tMSR);
 
 	return status;
 }
@@ -265,7 +280,6 @@ static int ds24xx_search_rom()
 	int last_zero, rom_byte_number, search_result;
 	int id_bit, cmp_id_bit;
 	unsigned char rom_byte_mask, search_direction;
-	unsigned char crc8 = 0;
 
 	/* initialize for search */
 	id_bit_number = 1;
@@ -273,17 +287,17 @@ static int ds24xx_search_rom()
 	rom_byte_number = 0;
 	rom_byte_mask = 1;
 	search_result = 0;
+	crc8 = 0;
 
 	/* if the last call was not the last one */
 	if (!LastDeviceFlag) {
 		/* 1-Wire reset */
 		if (!ds24xx_reset()) {
 			 /* reset the search*/
-			 dbg_log(1, "1-Wire: reset fail\n\r");
 			 LastDiscrepancy = 0;
-			 LastDeviceFlag = 0;
+			 LastDeviceFlag = FALSE;
 			 LastFamilyDiscrepancy = 0;
-			 return 0;
+			 return FALSE;
 		}
 
 		/* issue the search command */
@@ -296,52 +310,37 @@ static int ds24xx_search_rom()
 			id_bit = ds24xx_read_bit();
 			cmp_id_bit = ds24xx_read_bit();
 
-			/* check for no devices on 1-Wire */
+			/* check for no devices on 1-wire */
 			if ((id_bit == 1) && (cmp_id_bit == 1))
 				break;
 			else {
 				/* all devices coupled have 0 or 1 */
 				if (id_bit != cmp_id_bit)
-					search_direction = id_bit;
+					search_direction = id_bit;  /* bit write value for search */
 				else {
 					/*
-					 * if this discrepancy if before
-					 * the Last Discrepancy on a previous
-					 * next then pick the same as last time
+					 if this discrepancy if before the Last Discrepancy
+					 on a previous next then pick the same as last time
 					 */
 					if (id_bit_number < LastDiscrepancy)
-						search_direction =
-							((buf[rom_byte_number]
-							& rom_byte_mask) > 0);
+						search_direction = ((buf[rom_byte_number] & rom_byte_mask) > 0);
 					else
-						/*
-						 * if equal to last pick 1,
-						 * if not then pick 0
-						 */
-						search_direction
-						= (id_bit_number
-							== LastDiscrepancy);
+						/* if equal to last pick 1, if not then pick 0 */
+						search_direction = (id_bit_number == LastDiscrepancy);
 
-					/*
-					 * if 0 was picked then record its
-					 * position in LastZero
-					 */
+					/* if 0 was picked then record its position in LastZero */
 					if (search_direction == 0) {
 						last_zero = id_bit_number;
-						/*
-						 * check for Last discrepancy
-						 * in family
-						 */
+						/* check for Last discrepancy in family */
 						if (last_zero < 9)
-							LastFamilyDiscrepancy
-								= last_zero;
+							LastFamilyDiscrepancy = last_zero;
 					}
 				}
 
 				/*
-				 * set or clear the bit in the ROM byte
-				 * rom_byte_number with mask rom_byte_mask
-				 */
+				 set or clear the bit in the ROM byte rom_byte_number
+				 with mask rom_byte_mask
+				*/
 				if (search_direction == 1)
 					buf[rom_byte_number] |= rom_byte_mask;
 				else
@@ -354,19 +353,15 @@ static int ds24xx_search_rom()
 					ds24xx_write_bit(0);
 
 				/*
-				 * increment the byte counter id_bit_number
-				 * and shift the mask rom_byte_mask
-				 */
+				 increment the byte counter id_bit_number
+				 and shift the mask rom_byte_mask
+				*/
 				id_bit_number++;
 				rom_byte_mask <<= 1;
 
-				/*
-				 * if the mask is 0 then go to new SerialNum
-				 * byte rom_byte_number and reset mask
-				 */
+				/* if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask */
 				if (rom_byte_mask == 0) {
-					crc8 = docrc8(crc8,
-						buf[rom_byte_number]);
+					docrc8(buf[rom_byte_number]);  /* accumulate the CRC */
 					rom_byte_number++;
 					rom_byte_mask = 1;
 				}
@@ -380,18 +375,18 @@ static int ds24xx_search_rom()
 
 			/* check for last device */
 			if (LastDiscrepancy == 0)
-				LastDeviceFlag = 1;
+				LastDeviceFlag = TRUE;
 
-			search_result = 1;
+			search_result = TRUE;
 		}
 	}
 
 	/* if no device found then reset counters so next 'search' will be like a first */
 	if (!search_result || !buf[0]) {
 		LastDiscrepancy = 0;
-		LastDeviceFlag = 0;
+		LastDeviceFlag = FALSE;
 		LastFamilyDiscrepancy = 0;
-		search_result = 0;
+		search_result = FALSE;
 	}
 
 	return search_result;
@@ -401,7 +396,7 @@ static int ds24xx_find_first()
 {
 	/* reset the search state */
 	LastDiscrepancy = 0;
-	LastDeviceFlag = 0;
+	LastDeviceFlag = FALSE;
 	LastFamilyDiscrepancy = 0;
 
 	return ds24xx_search_rom();
@@ -413,27 +408,30 @@ static int ds24xx_find_next()
 	return ds24xx_search_rom();
 }
 
-static unsigned int enumerate_all_rom(void)
+static int enumerate_all_rom(void)
 {
 	int i;
-	int result;
-	unsigned int cnt = 0;
+	int result, cnt;
 
-	dbg_log(1, "1-Wire: ROM Searching ... ");
+	dbg_log(1, "Enumerate all roms:\n\r");
+	cnt = 0;
 
 	result = ds24xx_find_first();
 	while (result) {
+		dbg_log(1, "Rom#%d: ", cnt);
+		for (i = 7; i >= 0; i--)
+			dbg_log(1, "%x ", buf[i]);
+		dbg_log(1, "\n\r");
 
 		/* save device info */
 		for (i = 7; i >= 0; i--)
-			device_id_array[cnt][i] = buf[i];
+			device_id_array[cnt][i]=buf[i];
 		cnt++;
 
 		result = ds24xx_find_next();
 	}
 
-	dbg_log(1, "Done, %d 1-Wire chips found\n\r\n\r", cnt);
-
+	dbg_log(1, "Done, %d 1-wire chips found!\n\r\n\r", cnt);
 	return cnt;
 }
 
@@ -446,19 +444,15 @@ static int ds24xx_read_memory(int chip_index, unsigned char addrh,
 	switch(device_id_array[chip_index][0]){
 	case FAMILY_CODE_DS2431:
 	case FAMILY_CODE_DS2433:
-	case FAMILY_CODE_DS28EC:
 		break;
 	default:
-		dbg_log(1, "1-Wire: family %d is not supported\n\r",
-					device_id_array[chip_index][0]);
+		dbg_log(1, "Device_%d is not supported\n\r", device_id_array[chip_index][0]);
 		return -1;
 	}
 
 retry:
 	for (round = 0; round < 2; round++) {
-		if (!ds24xx_reset())
-			dbg_log(1, "1-Wire: reset failed\n\r");
-
+		ds24xx_reset();
 		ds24xx_write_byte(ROM_COMMAND_MATCH);
 		for(i = 0; i < 8; i++)
 			ds24xx_write_byte(device_id_array[chip_index][i]);
@@ -471,13 +465,10 @@ retry:
 			pbuf[round][i] = ds24xx_read_byte();
 	}
 
-
 	/* Compare the buffer, if all the same, return 0 */
-	for (i = 0; i < len; i++) {
+	for (i = 0; i < len; i++)
 		if (p[i] != cmp[i])
 			break;
-	}
-
 	if (i == len)
 		return 0;
 
@@ -489,10 +480,9 @@ retry:
 
 static unsigned char normalize_rev_code(const unsigned char c)
 {
-	if ((c >= 'A') && (c <= 'Z'))
+	if (c >= 'A' && c <= 'Z')
 		return c;
-
-	if ((c >= 'a') && (c <= 'z'))
+	if (c >= 'a' && c <= 'z')
 		return c - 0x20;
 
 	/* by default, return revision 'A' */
@@ -501,190 +491,118 @@ static unsigned char normalize_rev_code(const unsigned char c)
 
 static unsigned char normalize_rev_id(const unsigned char c)
 {
-	if ((c >= '0') && (c <= '9'))
+	if (c >= '0' && c <= '9')
 		return c;
 
-	if (c > '9') {
-		if (((c >= 'A') && (c <= 'F'))
-			|| ((c >= 'a') && (c <= 'f')))
-			return '9';
-	}
+	if (c > '9')
+		if((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))
+			return '9'; /* not an hexadecimal number: normalize to '9' */
 
 	/* by default, return revision '0' */
 	return '0';
 }
 
-struct board_info {
-	unsigned char board_type;
-	unsigned char board_id;
-	unsigned char revision_code;
-	unsigned char revision_id;
-	unsigned char vendor_id;
-};
-
-static int get_board_info(unsigned char *buffer,
-				unsigned char bd_sn,
-				struct board_info *bd_info)
+static int get_board_info(struct one_wire_info *p)
 {
 	int i;
 	char tmp[20];
-	struct one_wire_info one_wire;
-	struct one_wire_info *p = &one_wire;
-	unsigned char *pbuf = buffer;
-
-	char *boardname;
-	char *vendorname;
-	unsigned revcode;
-	unsigned revid;
-
-	p->total_bytes = (unsigned char)*pbuf;
-
-	pbuf = buffer + 1;
-	for (i = 0; i < VENDOR_NAME_LEN; i++)
-		p->vendor_name[i] = *pbuf++;
-
-	pbuf = buffer + 11;
-	for (i = 0; i < VENDOR_COUNTRY_LEN; i++)
-		p->vendor_country[i] = *pbuf++;
-
-	pbuf = buffer + 13;
-	for (i = 0; i < BOARD_NAME_LEN; i++)
-		p->board_name[i] = *pbuf++;
-
-	p->year = *pbuf++;
-	p->week = *pbuf++;
-	p->revision_code = *pbuf++;
-	p->revision_id = *pbuf++;
 
 	memset(tmp, 0, sizeof(tmp));
-
-	for (i = 0; i < BOARD_NAME_LEN; i++) {
-		if (p->board_name[i] == 0x20)
-			break;
-
-		tmp[i] = p->board_name[i];
-	}
-
-	for (i = 0; i < ARRAY_SIZE(board_list); i++) {
+	memcpy(tmp, p->board_name, BOARD_NAME_LEN);
+	tmp[BOARD_NAME_LEN - 1] = '\0';
+	for (i = 0; ; i++) {
+		if (board_list[i].board_name == 0) {
+			dbg_log(1, "No board name [%s] found!\n\r", tmp);
+			return -1;
+		}
 		if (strncmp(board_list[i].board_name, tmp,
-			strlen(board_list[i].board_name)) == 0) {
-			bd_info->board_type = board_list[i].board_type;
-			bd_info->board_id = board_list[i].board_id;
-			bd_info->revision_code
-				= normalize_rev_code(p->revision_code);
-			bd_info->revision_id = normalize_rev_id(p->revision_id);
+			    strlen(board_list[i].board_name)) == 0) {
+			board_type = board_list[i].board_type;
+			board_id = board_list[i].board_id;
+			revision_code = normalize_rev_code(p->revision_code);
+			revision_id = normalize_rev_id(p->revision_id);
 			break;
 		}
 	}
-
-	boardname = board_list[i].board_name;
-	revcode = bd_info->revision_code;
-	revid = bd_info->revision_id;
-
-	if (i == ARRAY_SIZE(board_list)) {
-		return -1;
-	}
+	dbg_log(1, "Board name: %s [%c%c]; ",
+			board_list[i].board_name, revision_code, revision_id);
 
 	memset(tmp, 0, sizeof(tmp));
-	for (i = 0; i < VENDOR_NAME_LEN; i++) {
-		if (p->vendor_name[i] == 0x20)
-			break;
-		tmp[i] = p->vendor_name[i];
-	}
-
-	for (i = 0; i < ARRAY_SIZE(vendor_list); i++) {
+	memcpy(tmp, p->vendor_name, VENDOR_NAME_LEN);
+	tmp[VENDOR_NAME_LEN - 1] = '\0';
+	for (i = 0; ; i++) {
+		if (vendor_list[i].vendor_name == 0) {
+			dbg_log(1, "No vendor name [%s] found!\n\r", tmp);
+			return -1;
+		}
 		if (strncmp(vendor_list[i].vendor_name, tmp,
 			    strlen(vendor_list[i].vendor_name)) == 0) {
-			bd_info->vendor_id = vendor_list[i].vendor_id;
+			vendor_id = vendor_list[i].vendor_id;
 			break;
 		}
 	}
-
-	if (i == ARRAY_SIZE(vendor_list)) {
-		return -1;
-	}
-
-	vendorname = vendor_list[i].vendor_name;
-
-	dbg_log(1, "  #%d", bd_sn);
-	dbg_log(1, "  %s [%c%c]      %s\n\r",
-			boardname, revcode, revid, vendorname);
+	dbg_log(1, "Vendor name: %s\n\r", vendor_list[i].vendor_name);
 
 	return 0;
 }
 
 void load_1wire_info()
 {
-	int i;
-	unsigned int	cnt;
-	unsigned int	size = LEN_ONE_WIRE_INFO;
-	struct board_info	board_info;
-	struct board_info	*bd_info;
-
-	memset(&board_info, 0, sizeof(board_info));
-	bd_info= &board_info;
+	int i, cnt;
+	int size = sizeof(struct one_wire_info);
 
-	dbg_log(1, "1-Wire: Loading 1-Wire information ...\n\r");
+	dbg_log(1, "Loading 1-Wire info...\n\r");
 
 	sn = rev = 0;
 
+	one_wire_hw_init();
 	cnt = enumerate_all_rom();
-	if (!cnt) {
-		dbg_log(1, "WARNING: 1-Wire: No 1-Wire chip found\n\r ");
-		goto err;
-	}
-
-	dbg_log(1, "1-Wire: BoardName | [Revid] | VendorName\n\r");
 
 	for (i = 0; i < cnt; i++) {
 		if (ds24xx_read_memory(i, 0, 0, size, buf) < 0) {
-			dbg_log(1, "WARNING: 1-Wire: Failed to " \
-				"read from 1-Wire chip!\n\r");
+			dbg_log(1, "Failed to read from 1-Wire chip!\n\r");
 			goto err;
 		}
 
-		if (get_board_info(buf,	i, bd_info)) {
-			dbg_log(1, "WARNING: 1-Wire: Failed to " \
-						"get board information\n\r");
+		board_type = board_id = vendor_id = revision_code = revision_id = 0xff;
+		if (get_board_info((struct one_wire_info *)buf) < 0)
 			goto err;
-		}
 
-		switch (bd_info->board_type) {
+		switch (board_type) {
 		case BOARD_TYPE_CPU:
-			sn  |= (bd_info->board_id & 0x1F);
-			sn  |= ((bd_info->vendor_id & 0x1F) << 5);
-			rev |= (bd_info->revision_code - 'A');
-			rev |= (((bd_info->revision_id - '0') & 0x3) << 15);
+			sn  |= (board_id & 0x1F);
+			sn  |= ((vendor_id & 0x1F) << 5);
+			rev |= (revision_code - 'A');
+			rev |= (((revision_id - '0') & 0x3) << 15);
 			break;
-
 		case BOARD_TYPE_DM:
-			sn  |= ((bd_info->board_id & 0x1F) << 10);
-			sn  |= ((bd_info->vendor_id & 0x1F) << 15);
-			rev |= ((bd_info->revision_code - 'A') << 5);
-			rev |= (((bd_info->revision_id - '0') & 0x3) << 18);
+			sn  |= ((board_id & 0x1F) << 10);
+			sn  |= ((vendor_id & 0x1F) << 15);
+			rev |= ((revision_code - 'A') << 5);
+			rev |= (((revision_id - '0') & 0x3) << 18);
 			break;
-
 		case BOARD_TYPE_EK:
-			sn  |= ((bd_info->board_id & 0x1F) << 20);
-			sn  |= ((bd_info->vendor_id & 0x1F) << 25);
-			rev |= ((bd_info->revision_code - 'A') << 10);
-			rev |= (((bd_info->revision_id - '0') & 0x3) << 21);
+			sn  |= ((board_id & 0x1F) << 20);
+			sn  |= ((vendor_id & 0x1F) << 25);
+			rev |= ((revision_code - 'A') << 10);
+			rev |= (((revision_id - '0') & 0x3) << 21);
 			break;
-
 		default:
-			dbg_log(1, "WARNING: 1-Wire: Unknown board type\n\r");
+			dbg_log(1, "Unknown board type!\n\r");
 			goto err;
 		}
 	}
 
+	dbg_log(1, "sn: %x;   rev: %x\n\r", sn, rev);
+
 	/* save to GPBR #2 and #3 */
 	writel(sn, AT91C_BASE_GPBR + 4 * 2);
 	writel(rev, AT91C_BASE_GPBR + 4 * 3);
 
-err:
-	dbg_log(1, "\n\r");
-
 	return;
+err:
+	/* Hang: we can not continue */
+        while (1);
 }
 
 unsigned int get_sys_sn()
@@ -693,7 +611,6 @@ unsigned int get_sys_sn()
 		dbg_log(1, "Error: no system_sn defined, using 0!\n\r");
 		return 0;
 	}
-
 	return sn;
 }
 
@@ -703,7 +620,6 @@ unsigned int get_sys_rev()
 		dbg_log(1, "Error: no system_rev defined, using 0!\n\r");
 		return 0;
 	}
-
 	return rev;
 }
 
diff --git a/driver/flash.c b/driver/flash.c
old mode 100644
new mode 100755
diff --git a/driver/hamming.c b/driver/hamming.c
old mode 100644
new mode 100755
diff --git a/driver/hw_init_hook.c b/driver/hw_init_hook.c
old mode 100644
new mode 100755
diff --git a/driver/load_kernel.c b/driver/load_kernel.c
old mode 100644
new mode 100755
index 8f26ad4..88a6b64
--- a/driver/load_kernel.c
+++ b/driver/load_kernel.c
@@ -33,272 +33,299 @@
 #include "dataflash.h"
 #include "nandflash.h"
 #include "sdcard.h"
-#include "fdt.h"
-#include "onewire_info.h"
 
 #include "debug.h"
 
-#ifdef CONFIG_OF_LIBFDT
-
-static int setup_dt_blob(void *blob)
-{
-	char *bootargs = LINUX_KERNEL_ARG_STRING;
-	char *p;
-	unsigned int mem_bank = OS_MEM_BANK;
-	unsigned int mem_size = OS_MEM_SIZE;
-	int ret;
-
-	if (check_dt_blob_valid(blob)) {
-		dbg_log(1, "DT: the blob is not a valid fdt\n\r");
-		return -1;
-	}
-
-	dbg_log(1, "\n\rUsing device tree in place at %d\n\r",
-						(unsigned int)blob);
-
-	/* set "/chosen" node */
-	for (p = bootargs; *p == ' '; p++)
-		;
-
-	if (*p == '\0')
-		return -1;
-
-	ret = fixup_chosen_node(blob, p);
-	if (ret)
-		return ret;
-
-	ret = fixup_memory_node(blob, &mem_bank, &mem_size);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static void setup_boot_params(void) {}
-
-#else
-static int setup_dt_blob(void *blob)
-{
-	return 0;
-}
+#ifdef CONFIG_AT91SAM9X5EK
+#include "onewire_info.h"
+#endif
 
-#define TAG_FLAG_NONE		0x00000000
-#define TAG_FLAG_CORE		0x54410001
-#define TAG_FLAG_MEM		0x54410002
-#define TAG_FLAG_SERIAL		0x54410006
-#define TAG_FLAG_REVISION	0x54410007
-#define TAG_FLAG_CMDLINE	0x54410009
+/*
+ * The new way of passing information: a list of tagged entries
+ */
 
-#define	TAG_SIZE_HEADER		8
-#define TAG_SIZE_CORE		5
-#define TAG_SIZE_MEM32		4
-#define TAG_SIZE_SERIAL		4
-#define TAG_SIZE_REVISION	3
+/* The list ends with an ATAG_NONE node. */
+#define ATAG_NONE	0x00000000
 
 struct tag_header {
-	unsigned int	size;
-	unsigned int	tag;
+	unsigned int size;
+	unsigned int tag;
 };
 
+/* The list must start with an ATAG_CORE node */
+#define ATAG_CORE	0x54410001
+
 struct tag_core {
-	struct tag_header	header;
-	unsigned int		flags;
-	unsigned int		pagesize;
-	unsigned int		rootdev;
+	unsigned int flags;		/* bit 0 = read-only */
+	unsigned int pagesize;
+	unsigned int rootdev;
 };
 
+/* it is allowed to have multiple ATAG_MEM nodes */
+#define ATAG_MEM	0x54410002
+
 struct tag_mem32 {
-	struct tag_header	header;
-	unsigned int		size;
-	unsigned int		start;
+	unsigned int	size;
+	unsigned int	start;	/* physical start address */
 };
 
-struct tag_serial {
-	struct tag_header	header;
-	unsigned int		low;
-	unsigned int		high;
+/* board serial number. "64 bits should be enough for everybody" */
+#define ATAG_SERIAL	0x54410006
+
+struct tag_serialnr {
+	unsigned int low;
+	unsigned int high;
 };
 
+/* board revision */
+#define ATAG_REVISION	0x54410007
+
 struct tag_revision {
-	struct tag_header	header;
-	unsigned int		version;
+	unsigned int rev;
 };
 
+/* command line: \0 terminated string */
+#define ATAG_CMDLINE	0x54410009
+
 struct tag_cmdline {
-	struct tag_header	header;
-	char			cmdline[1];
+	char	cmdline[1];	/* this is the minimum size */
 };
 
-struct tag_none {
-	struct tag_header	header;
+struct tag {
+	struct tag_header hdr;
+	union {
+		struct tag_core		core;
+		struct tag_mem32	mem;
+		struct tag_serialnr	serialnr;
+		struct tag_revision	revision;
+		struct tag_cmdline	cmdline;
+	} u;
 };
 
-static void setup_commandline_tag(struct tag_cmdline *params,
-						char *commandline)
+#define tag_next(t)	((struct tag *)((unsigned int *)(t) + (t)->hdr.size))
+#define tag_size(type)	((sizeof(struct tag_header) + sizeof(struct type)) >> 2)
+
+#define IH_MAGIC	0x27051956	/* Image Magic Number		*/
+#define IH_NMLEN	32		/* Image Name Length		*/
+
+/*
+ * Legacy format image header,
+ * all data in network byte order (aka natural aka bigendian).
+ */
+typedef struct image_header {
+	unsigned int	ih_magic;	/* Image Header Magic Number	*/
+	unsigned int	ih_hcrc;	/* Image Header CRC Checksum	*/
+	unsigned int	ih_time;	/* Image Creation Timestamp	*/
+	unsigned int	ih_size;	/* Image Data Size		*/
+	unsigned int	ih_load;	/* Data	 Load  Address		*/
+	unsigned int	ih_ep;		/* Entry Point Address		*/
+	unsigned int	ih_dcrc;	/* Image Data CRC Checksum	*/
+	unsigned char	ih_os;		/* Operating System		*/
+	unsigned char	ih_arch;	/* CPU architecture		*/
+	unsigned char	ih_type;	/* Image Type			*/
+	unsigned char	ih_comp;	/* Compression Type		*/
+	unsigned char	ih_name[IH_NMLEN];	/* Image Name		*/
+} image_header_t;
+
+#ifndef CONFIG_LINUX_DT
+static struct tag *params = (struct tag *)(OS_MEM_BANK + 0x100);
+
+static void setup_start_tag (void)
 {
-	char *p;
+	params->hdr.tag = ATAG_CORE;
+	params->hdr.size = tag_size (tag_core);
 
-	if (!commandline)
-		return;
+	params->u.core.flags = 0;
+	params->u.core.pagesize = 0;
+	params->u.core.rootdev = 0;
 
-	for (p = commandline; *p == ' '; p++)
-		;
+	params = tag_next (params);
+}
 
-	if (*p == '\0')
-		return;
+static void setup_memory_tags (void)
+{
+	params->hdr.tag = ATAG_MEM;
+	params->hdr.size = tag_size (tag_mem32);
 
-	params->header.tag = TAG_FLAG_CMDLINE;
-	params->header.size = (TAG_SIZE_HEADER + strlen(p) + 1 + 4) >> 2;
+	params->u.mem.start = OS_MEM_BANK; 
+	params->u.mem.size = OS_MEM_SIZE; 
 
-	strcpy(params->cmdline, p);
+	params = tag_next (params);
+
+#if defined(CONFIG_STAMP9G45) && defined(CONFIG_RAM_512MB)
+	params->hdr.tag = ATAG_MEM;
+	params->hdr.size = tag_size (tag_mem32);
+
+	params->u.mem.start = AT91C_BASE_CS1;
+	params->u.mem.size = 0x10000000;
+
+	params = tag_next (params);
+#endif
 }
 
-static void setup_boot_params(void)
+static void setup_commandline_tag (char *commandline)
 {
-	unsigned int *params = (unsigned int *)(OS_MEM_BANK + 0x100);
+	char *p;
 
-	struct tag_core *coreparam = (struct tag_core *)params;
-	coreparam->header.tag = TAG_FLAG_CORE;
-	coreparam->header.size = TAG_SIZE_CORE;
+	if (!commandline)
+		return;
+
+	/* eat leading white space */
+	for (p = commandline; *p == ' '; p++);
+
+	/* skip non-existent command lines so the kernel will still
+	 * use its default command line.
+	 */
+	if (*p == '\0')
+		return;
 
-	coreparam->flags = 0;
-	coreparam->pagesize = 0;
-	coreparam->rootdev = 0;
+	params->hdr.tag = ATAG_CMDLINE;
+	params->hdr.size =
+		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
 
-	params = (unsigned int *)params + TAG_SIZE_CORE;
+	strcpy (params->u.cmdline.cmdline, p);
 
-	struct tag_mem32 *memparam = (struct tag_mem32 *)params;
-	memparam->header.tag = TAG_FLAG_MEM;
-	memparam->header.size = TAG_SIZE_MEM32;
+	params = tag_next (params);
+}
 
-	memparam->start = OS_MEM_BANK;
-	memparam->size = OS_MEM_SIZE;
+#ifdef CONFIG_AT91SAM9X5EK
+static void setup_serial_tag (void)
+{
+	params->hdr.tag = ATAG_SERIAL;
+	params->hdr.size = tag_size (tag_serialnr);
+	params->u.serialnr.low = get_sys_sn();
+	params->u.serialnr.high= 0;
+	params = tag_next (params);
+}
 
-	params = (unsigned int *)params + TAG_SIZE_MEM32;
+static void setup_revision_tag(void)
+{
+	unsigned int rev = 0;
 
-	struct tag_cmdline *cmdparam = (struct tag_cmdline *)params;
-	setup_commandline_tag(cmdparam, LINUX_KERNEL_ARG_STRING);
+	rev = get_sys_rev();
+	params->hdr.tag = ATAG_REVISION;
+	params->hdr.size = tag_size (tag_revision);
+	params->u.revision.rev = rev;
+	params = tag_next (params);
+}
+#endif /* #ifdef CONFIG_AT91SAM9X5EK */
 
-	params = (unsigned int *)params + cmdparam->header.size;
+static void setup_end_tag (void)
+{
+	params->hdr.tag = ATAG_NONE;
+	params->hdr.size = 0;
+}
 
-#ifdef CONFIG_LOAD_ONE_WIRE
-	struct tag_revision *revparam = (struct tag_revision *)params;
-	revparam->header.tag = TAG_FLAG_REVISION;
-	revparam->header.size = TAG_SIZE_REVISION;
-	revparam->version = get_sys_rev();
+static void setup_boot_tags(void)
+{
+	/* Start tag */
+	setup_start_tag();
 
-	params = (unsigned int *)params + TAG_SIZE_REVISION;
+	/* Mem tag */
+	setup_memory_tags();
 
-	struct tag_serial *serialparam = (struct tag_serial *)params;
-	serialparam->header.tag = TAG_FLAG_SERIAL;
-	serialparam->header.size = TAG_SIZE_SERIAL;
-	serialparam->low = get_sys_sn();
-	serialparam->high = 0;
+	/* Command line tag */
+	setup_commandline_tag(LINUX_KERNEL_ARG_STRING);
 
-	params = (unsigned int *)params + TAG_SIZE_SERIAL;
+#ifdef CONFIG_AT91SAM9X5EK
+	/* System Rev tag */
+	setup_revision_tag();
+	
+	/* Board Serial tag */
+	setup_serial_tag();
 #endif
 
 	/* end tag */
-	struct tag_none * noneparam = (struct tag_none *)params;
-	noneparam->header.tag = TAG_FLAG_NONE;
-	noneparam->header.size = 0;
+	setup_end_tag();
 }
-#endif /* #ifdef CONFIG_OF_LIBFDT */
-
-/* Kernel Image Header */
-#define KERNEL_IMAGE_MAGIC	0x27051956
-
-struct kernel_image_header {
-	unsigned int	magic;
-	unsigned int	header_crc;
-	unsigned int	time;
-	unsigned int	size;
-	unsigned int	load;
-	unsigned int	entry_point;
-	unsigned int	data_crc;
-	unsigned char	os_type;
-	unsigned char	arch;
-	unsigned char	image_type;
-	unsigned char	comp_type;
-	unsigned char	name[32];
-};
+#endif
 
-int load_kernel(struct image_info *image)
+int load_kernel(struct image_info *img_info)
 {
-	struct kernel_image_header *image_header;
+#if !defined(CONFIG_STAMP9G45) && !defined(CONFIG_NANOSG20) && !defined(CONFIG_PICOSG20)
+	image_header_t	*image_header;
 	unsigned int load_addr, image_size;
 	unsigned int magic_number;
-	unsigned int jump_addr = (unsigned int)image->dest;
-	unsigned int r2;
-	unsigned int mach_type;
+#endif
+	unsigned int jump_addr = (unsigned int)img_info->dest;
+#ifdef CONFIG_LINUX_DT
+	struct image_info dt_info;
+#else
+	unsigned int tags_addr = (unsigned int)(OS_MEM_BANK + 0x100);
+	int mach_type = MACH_TYPE;
+#endif
 	int ret;
 
 	void (*kernel_entry)(int zero, int arch, unsigned int params);
 
-#ifdef CONFIG_DATAFLASH
-	ret = load_dataflash(image);
-#endif
-
-#ifdef CONFIG_NANDFLASH
-	ret = load_nandflash(image);
-#endif
-
 #ifdef CONFIG_SDCARD
-	ret = load_sdcard(image);
+	ret = load_sdcard(img_info);
+#elif CONFIG_NANDFLASH
+	ret = load_nandflash(img_info);
 #endif
 	if (ret != 0)
-		return ret;
+		return -1;
 
 #ifdef CONFIG_SCLK
 	slowclk_switch_osc32();
 #endif
 
-	image_header = (struct kernel_image_header *)jump_addr;
-	magic_number = swap_uint32(image_header->magic);
-	dbg_log(1, "\n\rImage magic: %d is found\n\r", magic_number);
-	if (magic_number != KERNEL_IMAGE_MAGIC) {
-		dbg_log(1, "** Bad image magic number found: %d\n\r",
-						magic_number);
+#if defined(CONFIG_STAMP9G45) || defined(CONFIG_NANOSG20) || defined(CONFIG_PICOSG20)
+	kernel_entry = (void (*)(int, int, unsigned int))jump_addr;
+#else
+	/* Check the image header magic */
+	image_header = (image_header_t *)jump_addr;
+	magic_number = ntohl(image_header->ih_magic);
+	dbg_log(1, "\n\rImage magic: %d is found.\n\r", magic_number);
+#if 0
+	if (magic_number != IH_MAGIC) {
+		dbg_log(1, "** Bad image magic number found: %d\n\r", magic_number);
 		return -1;
 	}
-
-	if (image_header->comp_type != 0) {
-		dbg_log(1, "The comp type has not been supported\n\r");
+#endif
+	image_size = ntohl(image_header->ih_size);
+	load_addr = ntohl(image_header->ih_load);
+    
+	dbg_log(1, "Image size: %d, load address: %d\n\r", image_size, load_addr);
+
+#if 0
+	if (image_header->ih_comp != 0) {
+		dbg_log(1, "The compression type has not been supported yet\n\r");
 		return -1;
 	}
+#endif
+	kernel_entry = (void (*)(int, int, unsigned int))ntohl(image_header->ih_ep);
 
-	image_size = swap_uint32(image_header->size);
-	load_addr = swap_uint32(image_header->load);
+	dbg_log(1, "Relocating kernel image, dest: %d, src: %d\n\r",
+		load_addr, jump_addr + sizeof(image_header_t));
 
-	kernel_entry = (void (*)(int, int, unsigned int))
-					swap_uint32(image_header->entry_point);
+	memcpy((void *)load_addr, (void *)(jump_addr + sizeof(image_header_t)), image_size);
 
-	dbg_log(1, "Relocating kernel image, dest: %d, src: %d\n\r",
-		load_addr, jump_addr + sizeof(struct kernel_image_header));
+	dbg_log(1, "... %d bytes data transferred\n\r", image_size);
+#endif
 
-	memcpy((void *)load_addr, (void *)(jump_addr
-			+ sizeof(struct kernel_image_header)), image_size);
+#ifndef CONFIG_LINUX_DT
+	setup_boot_tags();
 
-	dbg_log(1, " ...... %d bytes data transferred\n\r", image_size);
+	dbg_log(1, "\n\rStarting linux kernel ..., machid: %d, tags: %d\n\r\n\r",
+		mach_type, tags_addr);
 
-	if (image->of) {
-		ret = setup_dt_blob((char *)image->of_dest);
-		if (ret)
-			return ret;
+	kernel_entry(0, mach_type, tags_addr);
+#else
+	dt_info.offset = DTIMG_ADDRESS;
+	dt_info.length = DTIMG_SIZE;
+	dt_info.dest = (unsigned char *)DT_ADDRESS;
 
-		mach_type = 0xffffffff;
-		r2 = (unsigned int)image->of_dest;
-	} else {
-		setup_boot_params();
+	ret = load_nandflash(&dt_info);
 
-		mach_type = MACH_TYPE;
-		r2 = (unsigned int)(OS_MEM_BANK + 0x100);
-	}
+	if (ret != 0)
+		return -1;
 
-	dbg_log(1, "\n\rStarting linux kernel ..., machid: %d\n\r\n\r",
-							mach_type);
+	dbg_log(1, "\n\rStarting linux kernel with device tree at: %d\n\r\n\r",
+		dt_info.dest);
 
-	kernel_entry(0, mach_type, r2);
+	kernel_entry(0, 0, (unsigned int)dt_info.dest);
+#endif
 
 	return 0;
 }
diff --git a/driver/mci_media.c b/driver/mci_media.c
deleted file mode 100644
index e8959fa..0000000
--- a/driver/mci_media.c
+++ /dev/null
@@ -1,1367 +0,0 @@
-/* ----------------------------------------------------------------------------
- *         ATMEL Microcontroller Software Support
- * ----------------------------------------------------------------------------
- * Copyright (c) 2012, Atmel Corporation
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the disclaimer below.
- *
- * Atmel's name may not be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
- * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include "common.h"
-#include "string.h"
-#include "hardware.h"
-#include "board.h"
-#include "arch/at91_mci.h"
-#include "mci_media.h"
-#include "timer.h"
-
-#include "debug.h"
-
-#define DEFAULT_SD_BLOCK_LEN		512
-#define CONFIG_SYS_DEFAULT_CLK		400000
-
-static struct sdcard_register	sdcard_register;
-static struct sd_command	sdcard_command;
-static struct sd_card		atmel_sdcard;
-
-static unsigned int	response[4];
-
-static const struct sd_command	sd_command_table[] =  {
-	/* CMD17 */
-	{
-		.cmd		= SD_CMD_READ_SINGLE_BLOCK,
-		.cmdreg		= (17 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64
-					| AT91C_MCI_TRCMD_START
-					| AT91C_MCI_TRDIR_READ
-					| AT91C_MCI_TRTYP_SINGLE),
-	},
-	/* CMD18 */
-	{
-		.cmd		= SD_CMD_READ_MULTIPLE_BLOCK,
-		.cmdreg		= (18 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64
-					| AT91C_MCI_TRCMD_START
-					| AT91C_MCI_TRDIR_READ
-					| AT91C_MCI_TRTYP_MULTIPLE),
-	},
-	/* CMD55 */
-	{
-		.cmd		= SD_CMD_APP_CMD,
-		.cmdreg		= (55 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* ACMD6 */
-	{
-		.cmd		= SD_CMD_APP_SET_BUS_WIDTH,
-		.cmdreg		= (6 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* CMD16 */
-	{
-		.cmd		= SD_CMD_SET_BLOCKLEN,
-		.cmdreg		= (16 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* CMD12 */
-	{
-		.cmd		= SD_CMD_STOP_TRANSMISSION,
-		.cmdreg		= (12 | AT91C_MCI_RSPTYP_R1B
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* CMD13 */
-	{
-		.cmd		= SD_CMD_SEND_STATUS,
-		.cmdreg		= (13 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* CMD0 */
-	{
-		.cmd		= SD_CMD_GO_IDLE_STATE,
-		.cmdreg		= 0,
-		.error_check	= 0,
-	},
-	/* CMD2 */
-	{
-		.cmd		= SD_CMD_ALL_SEND_CID,
-		.cmdreg		= (2 | AT91C_MCI_RSPTYP_136
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* CMD3 */
-	{
-		.cmd		= SD_CMD_SEND_RELATIVE_ADDR,
-		.cmdreg		= (3 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64),
-	},
-#ifdef CONFIG_SDCARD_HS
-	/* CMD6 */
-	{
-		.cmd		= SD_CMD_SWITCH_FUN,
-		.cmdreg		= (6 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64
-					| AT91C_MCI_TRCMD_START
-					| AT91C_MCI_TRDIR_READ),
-	},
-#endif
-	/* CMD7 */
-	{
-		.cmd		= SD_CMD_SELECT_CARD,
-		.cmdreg		= (7 | AT91C_MCI_RSPTYP_R1B
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* CMD8 */
-	{
-		.cmd		= SD_CMD_SEND_IF_COND,
-		.cmdreg		= (8 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* CMD9 */
-	{
-		.cmd		= SD_CMD_SEND_CSD,
-		.cmdreg		= (9 | AT91C_MCI_RSPTYP_136
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* CMD10 */
-	{
-		.cmd		= SD_CMD_SEND_CID,
-		.cmdreg		= (10 | AT91C_MCI_RSPTYP_136
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* ACMD41 */
-	{
-		.cmd		= SD_CMD_APP_SD_SEND_OP_COND,
-		.cmdreg		= (41 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* ACMD51 */
-	{
-		.cmd		= SD_CMD_APP_SEND_SCR,
-		.cmdreg		= (51 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64
-					| AT91C_MCI_TRCMD_START
-					| AT91C_MCI_TRDIR_READ),
-	},
-#ifdef CONFIG_MMC_SUPPORT
-	/* MMC CMD1 */
-	{
-		.cmd		= MMC_CMD_SEND_OP_COND,
-		.cmdreg		= (1 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* MMC CMD6 */
-	{
-		.cmd		= MMC_CMD_SWITCH_FUN,
-		.cmdreg		= (6 | AT91C_MCI_RSPTYP_R1B
-					| AT91C_MCI_MAXLAT_64),
-	},
-	/* MMC CMD8 */
-	{
-		.cmd		= MMC_CMD_SEND_EXT_CSD,
-		.cmdreg		= (8 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64
-					| AT91C_MCI_TRCMD_START
-					| AT91C_MCI_TRDIR_READ),
-	},
-	/* MMC CMD14 */
-	{
-		.cmd		= MMC_CMD_BUSTEST_R,
-		.cmdreg		= (14 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64
-					| AT91C_MCI_TRCMD_START
-					| AT91C_MCI_TRDIR_READ),
-	},
-	/* MMC CMD19 */
-	{
-		.cmd		= MMC_CMD_BUSTEST_W,
-		.cmdreg		= (19 | AT91C_MCI_RSPTYP_48
-					| AT91C_MCI_MAXLAT_64
-					| AT91C_MCI_TRCMD_START
-					| AT91C_MCI_TRDIR_WRITE),
-	},
-#endif /* #ifdef CONFIG_MMC_SUPPORT */
-};
-
-static int init_sd_command(struct sd_command *command)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(sd_command_table); i++) {
-		if (command->cmd == sd_command_table[i].cmd)
-			break;
-	}
-
-	if (i == ARRAY_SIZE(sd_command_table))
-		return -1;
-
-	command->cmdreg = sd_command_table[i].cmdreg;
-
-	if (command->cmd == 0)
-		command->error_check = 0;
-	else {
-		command->error_check = (AT91C_MCI_RINDE
-					| AT91C_MCI_RDIRE
-					| AT91C_MCI_RENDE);
-
-		if ((command->cmd != SD_CMD_APP_SD_SEND_OP_COND)
-			&& (command->cmd != MMC_CMD_SEND_OP_COND))
-			command->error_check |= AT91C_MCI_RCRCE;
-	}
-
-	command->resp = response;
-
-	return 0;
-}
-
-/*
- * Refer to the at91sam9g20 datasheet:
- * Figure 35-9: Command/Response Functional Flow Diagram
- */
-static int sd_send_command(struct sd_command *command)
-{
-	unsigned int status;
-	unsigned int *response = command->resp;
-	int ret;
-
-	ret = init_sd_command(command);
-	if (ret)
-		return ret;
-
-	/* Set the Command Argument Register */
-	mci_writel(MCI_ARGR, command->argu);
-	/* Set the Command Register */
-	mci_writel(MCI_CMDR, command->cmdreg);
-
-	/* Wait for the command ready status flag*/
-	do {
-		status = mci_readl(MCI_SR);
-	} while (!(status & AT91C_MCI_CMDRDY));
-
-	/* Check error bits in the status register */
-	if (status & AT91C_MCI_RTOE) {
-		dbg_log(1, "Cmd: %d Response Time-out\n\r",
-				command->cmd & (~(SD_APP_CMD | MMC_CMD)));
-		return ERROR_TIMEOUT;
-	}
-
-	if (status & command->error_check) {
-		dbg_log(1, "Cmd: %d, error check, status: %d\n\r", \
-			command->cmd & (~(SD_APP_CMD | MMC_CMD)), status);
-		return ERROR_COMM;
-	}
-
-	/*  Read response */
-	*response++ = mci_readl(MCI_RSPR);
-	*response++ = mci_readl(MCI_RSPR1);
-	*response++ = mci_readl(MCI_RSPR2);
-	*response++ = mci_readl(MCI_RSPR3);
-
-	return 0;
-}
-
-static int sd_cmd_go_idle_state(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_GO_IDLE_STATE;
-	command->argu = 0;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int sd_cmd_send_if_cond(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_SEND_IF_COND;
-	command->argu = CHECK_PATTERN;
-	command->argu |= (sdcard->votage_host_support
-				&& OCR_VOLTAGE_27_36_MASK) ? (0x01 << 8) : 0;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	if (((command->resp[0] & CHECK_PATTERN) != CHECK_PATTERN)
-		|| (((command->resp[0] >> 8) & 0x0f) != 0x01))
-		return ERROR_UNUSABLE_CARD;
-	else
-		return 0;
-}
-
-static int sd_cmd_send_app_cmd(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_APP_CMD;
-	command->argu = sdcard->reg->rca << 16;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-/* Host Capacity Support / Card Capacity Status */
-#define OCR_HCR_CCS		(0x01 << 30)
-#define OCR_BUSY_STATUS		(0x01 << 31)
-static int sd_cmd_app_sd_send_op_cmd(struct sd_card *sdcard,
-				unsigned int capacity_support,
-				unsigned int *reponse)
-{
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_APP_SD_SEND_OP_COND;
-	command->argu = sdcard->votage_host_support
-				& OCR_VOLTAGE_27_36_MASK;
-	if (capacity_support)
-		command->argu |= OCR_HCR_CCS;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	*reponse = command->resp[0];
-
-	return 0;
-}
-
-static int sd_check_operational_condition(struct sd_card *sdcard,
-			unsigned int capacity_support)
-{
-	unsigned int response = 0;
-	unsigned int retries = 1000;
-	unsigned int i;
-	int ret;
-
-	/*
-	 * The host repeatedly issues ACMD41 for at least 1 second
-	 * or until the busy bit are set to 1.
-	 */
-	for (i = 0; i < retries; i++) {
-		ret = sd_cmd_send_app_cmd(sdcard);
-		if (ret)
-			return ret;
-
-		ret = sd_cmd_app_sd_send_op_cmd(sdcard,
-				capacity_support, &response);
-		if (ret)
-			return ret;
-
-		if (response & OCR_BUSY_STATUS)
-			break;
-
-		udelay(1000);
-	};
-
-	if (i == retries)
-		return ERROR_UNUSABLE_CARD;
-
-	sdcard->reg->ocr = response;
-
-	return 0;
-}
-
-static int sd_cmd_all_send_cid(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int i;
-	int ret;
-
-	command->cmd = SD_CMD_ALL_SEND_CID;
-	command->argu = 0;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	for (i = 0; i < 4; i++)
-		sdcard->reg->cid[i] = command->resp[i];
-
-	return 0;
-}
-
-static int sd_cmd_send_relative_addr(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_SEND_RELATIVE_ADDR;
-	command->argu = sdcard->reg->rca << 16;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	sdcard->reg->rca = (sdcard->card_type == CARD_TYPE_SD) ?
-					(command->resp[0] >> 16) & 0xffff : 0;
-
-	return 0;
-}
-
-static int sd_cmd_send_status(struct sd_card *sdcard, unsigned int retries)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int i;
-	int ret;
-
-	command->cmd = SD_CMD_SEND_STATUS;
-	command->argu = sdcard->reg->rca << 16;
-
-	for (i = 0; i < retries; i++) {
-		ret = sd_send_command(command);
-		if (ret)
-			return ret;
-
-		if ((command->resp[0] >> 8) & 0x01)
-			break;
-
-		udelay(1000);
-	};
-
-	if (i == retries) {
-		dbg_log(1, "Timeout, wait for card ready\n\r");
-		return ERROR_TIMEOUT;
-	}
-
-	return 0;
-}
-
-static int sd_cmd_select_card(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_SELECT_CARD;
-	command->argu = sdcard->reg->rca << 16;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int sd_cmd_send_csd(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int i;
-	int ret;
-
-	command->cmd = SD_CMD_SEND_CSD;
-	command->argu = sdcard->reg->rca << 16;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	for (i = 0; i < 4; i++)
-		sdcard->reg->csd[i] = *command->resp++;
-
-	return 0;
-}
-
-static int sd_cmd_app_send_scr(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int data[2];
-	unsigned int bytes_to_read = 8;
-	unsigned int block_len = DEFAULT_SD_BLOCK_LEN;
-	unsigned int i;
-	int ret;
-
-	ret = sd_cmd_send_app_cmd(sdcard);
-	if (ret)
-		return ret;
-
-	command->cmd = SD_CMD_APP_SEND_SCR;
-	command->argu = sdcard->reg->rca << 16;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	ret = at91_mci_read_block_data(data, bytes_to_read, block_len);
-	if (ret)
-		return ret;
-
-	for (i = 0; i < 2; i++)
-		sdcard->reg->scr[i] = swap_uint32(data[i]);
-
-	return 0;
-}
-
-static int sd_cmd_app_set_bus_width(struct sd_card *sdcard,
-				unsigned int bus_width)
-{
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_APP_SET_BUS_WIDTH;
-	command->argu = (bus_width == 4) ? 0x02 : 0;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int sd_set_bus_width(struct sd_card *sdcard,
-				unsigned int bus_width)
-{
-	int ret;
-
-	ret = sd_cmd_send_app_cmd(sdcard);
-	if (ret)
-		return ret;
-
-	ret = sd_cmd_app_set_bus_width(sdcard, bus_width);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-#ifdef CONFIG_SDCARD_HS
-
-/* SD SWITCH */
-#define SD_SWITCH_MODE_CHECK	0
-#define SD_SWITCH_MODE_SET	1
-
-#define SD_SWITCH_GRP_ACCESS_MODE	1
-#define SD_SWITCH_GRP_CMD_SYS		2
-#define SD_SWITCH_GRP_DRV_STRENGTH	3
-#define SD_SWITCH_GRP_CUR_LIMIT		4
-
-#define SD_SWITCH_FUNC_SDR12		0x00
-#define SD_SWITCH_FUNC_HS_SDR25		0x01
-#define	SD_SWITCH_FUNC_SDR50		0x02
-#define SD_SWITCH_FUNC_SDR104		0x03
-#define SD_SWITCH_FUNC_DDR50		0x04
-
-static int sd_cmd_switch_fun(struct sd_card *sdcard,
-				unsigned int mode,
-				unsigned int group,
-				unsigned int func,
-				unsigned int *status)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int bytes_to_read = 64;
-	unsigned int block_len = DEFAULT_SD_BLOCK_LEN;
-	int ret;
-
-	command->cmd = SD_CMD_SWITCH_FUN;
-	command->argu = (mode << 31) | 0xffffff;
-	command->argu &= ~(0xf << ((group - 1) * 4));
-	command->argu |= func << ((group - 1) * 4);
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	ret = at91_mci_read_block_data(status, bytes_to_read, block_len);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-/*
- * Refer to Physical Layer Specification Version 3.1
- * 4.3.10.6 Switch Function Flow example
- * 4.3.10.7 Example of Checking
- */
-static int switch_check_hs_busy_status_supported(struct sd_card *sdcard,
-						unsigned char *support)
-{
-	unsigned int switch_func_status[16];
-	unsigned int status;
-	unsigned int version;
-	unsigned int retries = 6;
-	unsigned int i;
-	int ret;
-
-	for (i = 0; i < retries; i++) {
-		/* Mode 0 operation: check function */
-		ret = sd_cmd_switch_fun(sdcard,
-					SD_SWITCH_MODE_CHECK,
-					SD_SWITCH_GRP_ACCESS_MODE,
-					SD_SWITCH_FUNC_HS_SDR25,
-					switch_func_status);
-		if (ret)
-			return ret;
-
-		/* Check Data Structure version
-		 * 0x00 - bits 511:376 are defined
-		 * 0x01 - bits 511:272 are defined
-		 */
-		version = swap_uint32(switch_func_status[4]);
-		if (((version >> 16) & 0xff) == 0x00)
-			break;
-
-		/* Check Busy Status of function */
-		status = swap_uint32(switch_func_status[7]);
-		if (!((status >> 17) & 0x01))
-			break;
-	};
-
-	if (i == retries)
-		return -1;
-
-	/* Check function supported */
-	status = swap_uint32(switch_func_status[3]);
-	*support = ((status >> 17) & 0x01) ? 1 : 0;
-
-	return 0;
-}
-
-static int sd_switch_func_high_speed(struct sd_card *sdcard)
-{
-	unsigned int switch_func_status[16];
-	unsigned int status;
-	unsigned char support = 0;
-	int ret;
-
-	ret = switch_check_hs_busy_status_supported(sdcard, &support);
-	if (ret)
-		return ret;
-
-	if (!support) {
-		dbg_log(1, "SD: Not support hs function switch\n\r");
-		return 0;
-	}
-
-	/* Mode 1 operation: set functioin */
-	ret = sd_cmd_switch_fun(sdcard,
-				SD_SWITCH_MODE_SET,
-				SD_SWITCH_GRP_ACCESS_MODE,
-				SD_SWITCH_FUNC_HS_SDR25,
-				switch_func_status);
-	if (ret)
-		return ret;
-
-	/* Check Switched function */
-	status = swap_uint32(switch_func_status[4]);
-	if ((status >> 24) & 0x01) {
-		sdcard->highspeed_card = 1;
-		return 0;
-	} else
-		return -1;
-}
-#endif	/* #ifdef CONFIG_SDCARD_HS */
-
-static int sd_card_set_bus_width(struct sd_card *sdcard)
-{
-	unsigned int bus_width;
-	int ret;
-
-	bus_width = (sdcard->bus_width_support & 0x04) ? 4 : 1;
-
-	ret = sd_set_bus_width(sdcard, bus_width);
-	if (ret)
-		return ret;
-
-	ret = at91_mci_set_bus_width(bus_width);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-/*-----------------------------------------------------------------*/
-#ifdef CONFIG_MMC_SUPPORT
-
-static int mmc_cmd_send_op_cond(struct sd_card *sdcard,
-				unsigned int ocr)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int volage_mask = (~(ocr & 0x01 << 0x17)) << 15;
-	int ret;
-
-	command->cmd = MMC_CMD_SEND_OP_COND;
-	command->argu = (sdcard->votage_host_support & volage_mask)
-				| (ocr & ((~(0x1 << 2)) << 30));
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int mmc_verify_operating_condition(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int ocr;
-	unsigned int retries = 1000;
-	unsigned int i;
-	int ret;
-
-	/* Query the card and determine the voltage type of the card */
-	ret = mmc_cmd_send_op_cond(sdcard, 0);
-	if (ret)
-		return ret;
-
-	ocr = command->resp[0];
-
-	for (i = 0; i < retries; i++) {
-		ret = mmc_cmd_send_op_cond(sdcard, ocr);
-		if (ret)
-			return ret;
-
-		if (command->resp[0]  & (0x01 << 31))
-			break;
-
-		udelay(1000);
-	};
-
-	if (i == retries)
-		return ERROR_UNUSABLE_CARD;
-
-	sdcard->reg->ocr = command->resp[0];
-
-	return 0;
-}
-
-static int mmc_cmd_switch_fun(struct sd_card *sdcard,
-				unsigned char access_mode,
-				unsigned char index,
-				unsigned char value)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int retries = 1000;
-	int ret;
-
-	command->cmd = MMC_CMD_SWITCH_FUN;
-	command->argu = (access_mode << 24)
-			| (index << 16)
-			| (value << 8);
-
-	ret = sd_send_command(command);
-
-	sd_cmd_send_status(sdcard, retries);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int mmc_cmd_send_ext_csd(struct sd_card *sdcard, char *ext_csd)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int *data = (unsigned int *)ext_csd;
-	unsigned int block_len = DEFAULT_SD_BLOCK_LEN;
-	int ret;
-
-	command->cmd = MMC_CMD_SEND_EXT_CSD;
-	command->argu = 0;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	ret = at91_mci_read_block_data(data, block_len, block_len);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-/* EXT_CSD access mode */
-#define MMC_EXT_CSD_ACCESS_CMD_SET	0x00
-#define MMC_EXT_CSD_ACCESS_SET_BITS	0x01
-#define MMC_EXT_CSD_ACCESS_CLEAR_BITS	0x02
-#define MMC_EXT_CSD_ACCESS_WRITE_BYTE	0x03
-
-#define EXT_CSD_BYTE_BUS_WIDTH		183
-#define EXT_CSD_BYTE_HS_TIMING		185
-#define EXT_CSD_BYTE_POWER_CLASS	187
-#define EXT_CSD_BYTE_CMD_SET_REV	189
-#define EXT_CSD_BYTE_CMD_SET		191
-#define EXT_CSD_BYTE_EXT_CSD_REV	192
-#define EXT_CSD_BYTE_CSD_STRUCTURE	194
-#define EXT_CSD_BYTE_CARD_TYPE		196
-
-static int mmc_switch_high_speed(struct sd_card *sdcard)
-{
-	char ext_csd[DEFAULT_SD_BLOCK_LEN];
-	char cardtype;
-	int ret;
-
-	ret = mmc_cmd_send_ext_csd(sdcard, ext_csd);
-	if (ret)
-		return ret;
-
-	cardtype = ext_csd[EXT_CSD_BYTE_CARD_TYPE] & 0x03;
-
-	ret = mmc_cmd_switch_fun(sdcard,
-			MMC_EXT_CSD_ACCESS_WRITE_BYTE,
-			EXT_CSD_BYTE_HS_TIMING,
-			1);
-	if (ret)
-		return ret;
-
-	ret = mmc_cmd_send_ext_csd(sdcard, ext_csd);
-	if (ret)
-		return ret;
-
-	if (!ext_csd[EXT_CSD_BYTE_HS_TIMING])
-		return -1;
-
-	sdcard->highspeed_card = (cardtype & 0x02) ? 1 : 0;
-
-	return 0;
-}
-
-static int mmc_cmd_bustest_w(struct sd_card *sdcard,
-				unsigned int buswidth,
-				unsigned char *data)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int bytes_to_write;
-	unsigned int block_len = DEFAULT_SD_BLOCK_LEN;
-	int ret;
-
-	bytes_to_write = (buswidth == 8) ? 8 : 4;
-
-	command->cmd = MMC_CMD_BUSTEST_W;
-	command->argu = 0;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	ret = at91_mci_write_block_data((unsigned int *)data,
-						bytes_to_write,
-						block_len);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int mmc_cmd_bustest_r(struct sd_card *sdcard,
-				unsigned int buswidth,
-				unsigned char *data)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int bytes_to_read;
-	unsigned int block_len = DEFAULT_SD_BLOCK_LEN;
-	int ret;
-
-	bytes_to_read = (buswidth == 8) ? 8 : 4;
-
-	command->cmd = MMC_CMD_BUSTEST_R;
-	command->argu = 0;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	ret = at91_mci_read_block_data((unsigned int *)data,
-						bytes_to_read,
-						block_len);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-#define MMC_BUS_WIDTH_8		2
-#define MMC_BUS_WIDTH_4		1
-#define MMC_BUS_WIDTH_1		0
-
-static int mmc_bus_width_select(struct sd_card *sdcard, unsigned int buswidth)
-{
-	unsigned char busw;
-	int ret;
-
-	busw = (buswidth == 8) ? MMC_BUS_WIDTH_8 : MMC_BUS_WIDTH_4;
-
-	ret = mmc_cmd_switch_fun(sdcard,
-			MMC_EXT_CSD_ACCESS_WRITE_BYTE,
-			EXT_CSD_BYTE_BUS_WIDTH,
-			busw);
-	if (ret)
-		return ret;
-
-	ret = at91_mci_set_bus_width(buswidth);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int mmc_detect_buswidth(struct sd_card *sdcard)
-{
-	unsigned char data_8bits[8] = {0x55, 0xaa, 0, 0, 0, 0, 0, 0};
-	unsigned char data_4bits[4] = {0x5a, 0, 0, 0};
-	unsigned char read_data[8];
-	unsigned char *pdata_w;
-
-	unsigned int busw;
-	unsigned int len;
-	unsigned int i;
-	int ret;
-
-	for (busw = 8, len = 2; busw != 0; busw -= 4, len--) {
-		pdata_w = (busw == 8) ? data_8bits : data_4bits;
-
-		ret = mmc_bus_width_select(sdcard, busw);
-		if (ret)
-			return ret;
-
-		ret = mmc_cmd_bustest_w(sdcard, busw, pdata_w);
-		if (ret)
-			return ret;
-
-		ret = mmc_cmd_bustest_r(sdcard, busw, read_data);
-		if (ret)
-			return ret;
-
-		for (i = 0; i < len; i++) {
-			if ((pdata_w[i] ^ read_data[i]) != 0xff)
-				break;
-		}
-
-		if (i == len) {
-			dbg_log(1, "MMC: %d-bit bus width detected\n\r", busw);
-			break;
-		}
-
-	}
-
-	return 0;
-
-}
-#endif /* #ifdef CONFIG_MMC_SUPPORT */
-
-/*-----------------------------------------------------------------*/
-
-/*
- * Refer to Physical Layer Specification Version 3.1
- * Figure 4-1: SD Memory Card State Diagram (card identification mode)
- * Figure 4-2: Card Initialization and Indentification Flow (SD mode)
- */
-static int sdcard_identification(struct sd_card *sdcard)
-{
-	int ret;
-
-	udelay(3000);
-
-	ret = sd_cmd_go_idle_state(sdcard);
-	if (ret)
-		return ret;
-
-	udelay(2000);
-
-#ifdef CONFIG_MMC_SUPPORT
-	ret = mmc_verify_operating_condition(sdcard);
-	if (ret == 0) {
-		sdcard->card_type = CARD_TYPE_MMC;
-
-	} else if (ret == ERROR_TIMEOUT) {
-#endif
-		ret = sd_cmd_send_if_cond(sdcard);
-		if (ret == 0) {
-			/* Ver 2.00 or later SD Memory Card */
-			ret = sd_check_operational_condition(sdcard, 1);
-			if (ret == ERROR_UNUSABLE_CARD) {
-				dbg_log(1, "Unusable Card\n\r");
-				return -1;
-			} else if (ret)
-				return ret;
-		} else if (ret == ERROR_TIMEOUT) {
-			ret = sd_check_operational_condition(sdcard, 0);
-			if (ret == ERROR_UNUSABLE_CARD) {
-				dbg_log(1, "Unusable Card\n\r");
-				return -1;
-			} else if (ret)
-				return ret;
-		}
-
-		sdcard->card_type = CARD_TYPE_SD;
-
-#ifdef CONFIG_MMC_SUPPORT
-	} else if (ret == ERROR_UNUSABLE_CARD) {
-		/*
-		 * Non-compatible voltage range
-		 * or checkpattern not correct
-		 */
-		dbg_log(1, "Unusable Card\n\r");
-		return -1;
-	} else
-		return ret;
-#endif
-
-	sdcard->highcapacity_card = (sdcard->reg->ocr & OCR_HCR_CCS) ? 1 : 0;
-
-	if (sdcard->card_type == CARD_TYPE_SD) {
-		dbg_log(1, "SD: Card Capacity: ");
-		if (sdcard->highcapacity_card)
-			dbg_log(1, "High or Extended\n\r");
-		else
-			dbg_log(1, "Standard\n\r");
-	}
-
-	/*
-	 * Card that is unidentified (which is in Ready State)
-	 * sends its CID number
-	 */
-	ret = sd_cmd_all_send_cid(sdcard);
-	if (ret)
-		return ret;
-
-	/* Asks the card to pubish a new relative card address (RCA) */
-	ret = sd_cmd_send_relative_addr(sdcard);
-	if (ret)
-		return ret;
-
-	/*
-	 * The host issues SEND_CSD(CMD9) to obtain
-	 * the Card Specific Data (CSD Register),
-	 */
-	ret = sd_cmd_send_csd(sdcard);
-	if (ret)
-		return ret;
-
-	sdcard->read_bl_len = DEFAULT_SD_BLOCK_LEN;
-
-	return 0;
-}
-
-static int sd_initialization(struct sd_card *sdcard)
-{
-	int ret;
-
-	/*
-	 * CMD7 is used to select one card and put it into
-	 * the Transfer State
-	 */
-	ret = sd_cmd_select_card(sdcard);
-	if (ret)
-		return ret;
-
-	/*
-	 * In Transfer State, send SEND_SCR(ACMD51)
-	 * to read the SD Configuration Register (SCR)
-	 */
-	ret = sd_cmd_app_send_scr(sdcard);
-	if (ret)
-		return ret;
-
-	sdcard->bus_width_support = (sdcard->reg->scr[0] >> 16) & 0x0f;
-
-#ifdef CONFIG_SDCARD_HS
-	unsigned int version;
-	version = (sdcard->reg->scr[0] >> 24) & 0x0f;
-	dbg_log(1, "SD: Specification Version ");
-	if (version == 0) {
-		sdcard->sd_spec_version = SD_VERSION_1_0;
-		dbg_log(1, "1.0 and 1.01\n\r");
-	} else if (version == 1) {
-		sdcard->sd_spec_version = SD_VERSION_1_10;
-		dbg_log(1, "1.10\n\r");
-	} else if (version == 2) {
-		if ((sdcard->reg->scr[0] >> 15) & 0x01) {
-			sdcard->sd_spec_version = SD_VERSION_3;
-			dbg_log(1, "3.0X\n\r");
-		} else {
-			sdcard->sd_spec_version = SD_VERSION_2;
-			dbg_log(1, "2.00\n\r");
-		}
-	} else {
-		sdcard->sd_spec_version = SD_VERSION_1_0;
-		dbg_log(1, "1.0 and 1.01\n\r");
-	}
-
-	if (sdcard->highspeed_host) {
-		if (sdcard->sd_spec_version != SD_VERSION_1_0) {
-			ret = sd_switch_func_high_speed(sdcard);
-			if (ret)
-				return ret;
-		}
-	}
-	if (sdcard->highspeed_card)
-		/* for SAM9G25-CM by COGENT, it cann't support 50M */
-		at91_mci_set_clock(40000000);
-	else
-#endif /* #ifdef CONFIG_SDCARD_HS */
-
-		at91_mci_set_clock(25000000);
-
-	/* Change the bus mode */
-	ret = sd_card_set_bus_width(sdcard);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-#ifdef CONFIG_MMC_SUPPORT
-static int mmc_initialization(struct sd_card *sdcard)
-{
-	unsigned int version;
-	int ret;
-
-	version = (sdcard->reg->csd[0] >> 26) & 0xf;
-	dbg_log(1, "MMC: Specification Version ");
-	if (version == 0) {
-		sdcard->sd_spec_version = MMC_VERSION_1_2;
-		dbg_log(1, "1.2\n\r");
-	} else if (version == 1) {
-		sdcard->sd_spec_version = MMC_VERSION_1_4;
-		dbg_log(1, "1.4\n\r");
-	} else if (version == 2) {
-		sdcard->sd_spec_version = MMC_VERSION_2_2;
-		dbg_log(1, "2.2\n\r");
-	} else if (version == 3) {
-		sdcard->sd_spec_version = MMC_VERSION_3;
-		dbg_log(1, "3.0\n\r");
-	} else if (version == 4) {
-		sdcard->sd_spec_version = MMC_VERSION_4;
-		dbg_log(1, "4.1 - 4.2\n\r");
-	} else {
-		sdcard->sd_spec_version = MMC_VERSION_1_2;
-		dbg_log(1, "1.2\n\r");
-	}
-
-	/*
-	 * CMD7 is used to select one card and put it into
-	 * the Transfer State
-	 */
-	ret = sd_cmd_select_card(sdcard);
-	if (ret)
-		return ret;
-
-	if (sdcard->sd_spec_version >= MMC_VERSION_4) {
-		ret = mmc_detect_buswidth(sdcard);
-		if (ret)
-			return ret;
-	}
-
-	if (sdcard->highspeed_host) {
-		if (sdcard->sd_spec_version >= MMC_VERSION_4) {
-			ret = mmc_switch_high_speed(sdcard);
-			if (ret)
-				return ret;
-		}
-	}
-
-	if (sdcard->highspeed_card)
-		at91_mci_set_clock(52000000);
-	else
-		at91_mci_set_clock(26000000);
-
-	return 0;
-}
-#endif /* #ifdef CONFIG_MMC_SUPPORT */
-
-static void init_sdcard_struct(struct sd_card *sdcard)
-{
-	memset((char *)sdcard, 0, sizeof(struct sd_card));
-	memset((char *)&sdcard_register, 0, sizeof(struct sdcard_register));
-	memset((char *)&sdcard_command, 0, sizeof(struct sd_command));
-
-	sdcard->reg = &sdcard_register;
-	sdcard->command = &sdcard_command;
-
-	sdcard->votage_host_support = SD_OCR_VDD_32_33 | SD_OCR_VDD_33_34;
-
-#ifdef CONFIG_SDCARD_HS
-	sdcard->highspeed_host = 1;
-#endif
-}
-
-/*--------------------------------------------------------------------------*/
-
-int sdcard_initialize(void)
-{
-	struct sd_card *sdcard = &atmel_sdcard;
-	int ret;
-
-	ret = at91_mci_init(CONFIG_SYS_DEFAULT_CLK, DEFAULT_SD_BLOCK_LEN);
-	if (ret)
-		return ret;
-
-	init_sdcard_struct(sdcard);
-
-	/* Card Indentification Mode */
-	ret = sdcard_identification(sdcard);
-	if (ret)
-		return ret;
-
-	if (sdcard->card_type == CARD_TYPE_SD)
-		ret = sd_initialization(sdcard);
-#ifdef CONFIG_MMC_SUPPORT
-	else
-		ret = mmc_initialization(sdcard);
-#endif
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-/*------------------------------------------------------------------- */
-
-static int sd_cmd_set_blocklen(struct sd_card *sdcard,
-					unsigned int block_len)
-{
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_SET_BLOCKLEN;
-	command->argu = block_len;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int sd_cmd_stop_transmission(struct sd_card *sdcard)
-{
-	struct sd_command *command = sdcard->command;
-	unsigned int retries = 1000;
-	int ret;
-
-	command->cmd = SD_CMD_STOP_TRANSMISSION;
-	command->argu = 0;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return ret;
-
-	sd_cmd_send_status(sdcard, retries);
-
-	return 0;
-}
-
-static int sd_cmd_read_multiple_block(struct sd_card *sdcard,
-				void *buf,
-				unsigned int start,
-				unsigned int block_count)
-{
-	unsigned int block_len = sdcard->read_bl_len;
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_READ_MULTIPLE_BLOCK;
-	command->argu = (sdcard->highcapacity_card) ? start : start * block_len;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return 0;
-
-	ret = at91_mci_read_blocks(buf, block_count, block_len);
-	if (ret)
-		return 0;
-
-	return block_count;
-}
-
-static int sd_cmd_read_single_block(struct sd_card *sdcard,
-				void *buf,
-				unsigned int start)
-{
-	unsigned int block_len = sdcard->read_bl_len;
-	struct sd_command *command = sdcard->command;
-	int ret;
-
-	command->cmd = SD_CMD_READ_SINGLE_BLOCK;
-	command->argu = (sdcard->highcapacity_card) ? start : start * block_len;
-
-	ret = sd_send_command(command);
-	if (ret)
-		return 0;
-
-	ret = at91_mci_read_block_data(buf, block_len, block_len);
-	if (ret)
-		return 0;
-
-	return 1;
-}
-
-#define SUPPORT_MAX_BLOCKS	65535
-unsigned int sdcard_block_read(unsigned int start,
-				unsigned int block_count,
-				void *buf)
-{
-	struct sd_card *sdcard = &atmel_sdcard;
-	unsigned int blocks_todo = block_count;
-	unsigned int blocks;
-	unsigned int block_len = sdcard->read_bl_len;
-	unsigned int blocks_read;
-	int ret;
-
-	/*
-	 * Refer to the at91sam9g20 datasheet:
-	 * Figure 35-10. Read Function Flow Diagram
-	*/
-
-	/* Send SET_BLOCKLEN command */
-	ret = sd_cmd_set_blocklen(sdcard, block_len);
-	if (ret)
-		return 0;
-
-	for (blocks_todo = block_count; blocks_todo > 0; ) {
-		blocks = (blocks_todo > SUPPORT_MAX_BLOCKS) ?
-					SUPPORT_MAX_BLOCKS : blocks_todo;
-
-		/*
-		 * Set the block length (in bytes)
-		 * Set the block count
-		 */
-		at91_mci_set_blkr(block_count, block_len);
-
-		if (blocks > 1) {
-			blocks_read = sd_cmd_read_multiple_block(sdcard,
-							buf, start, blocks);
-
-			ret = sd_cmd_stop_transmission(sdcard);
-			if (ret)
-				return ret;
-		} else {
-			blocks_read = sd_cmd_read_single_block(sdcard,
-							buf, start);
-		}
-
-		if (blocks_read != blocks)
-			return 0;
-
-		blocks_todo -= blocks;
-		start += blocks;
-		buf += blocks * block_len;
-	}
-
-	return block_count;
-}
diff --git a/driver/nandflash.c b/driver/nandflash.c
old mode 100644
new mode 100755
index 567a1ab..c685920
--- a/driver/nandflash.c
+++ b/driver/nandflash.c
@@ -36,26 +36,15 @@
 
 #include "nand.h"
 #include "hamming.h"
-#include "timer.h"
+#include "nand_ids.h"
+#include "string.h"
+#ifdef CONFIG_ENABLE_SW_ECC_BCH
+#include <stdlib.h>
+#include <bch/bch.h>
+#endif /* #ifdef CONFIG_ENABLE_SW_ECC_BCH */
 
 #define ECC_CORRECT_ERROR  0xfe
 
-static struct nand_chip nand_ids[] = {
-	/* Samsung K9F2G08U0M 256MB */
-	{0xecda, 0x800, 0x20000, 0x800, 0x40, 0x0},
-	/* Samsung K9F2G08U0A 256MB */
-	{0xecaa, 0x800, 0x20000, 0x800, 0x40, 0x0},
-	/* Micron MT29F2G16AAB 256MB */
-	{0x2cca, 0x800, 0x20000, 0x800, 0x40, 0x1},
-	/* Micron MT29F2G08AAC 256MB  */
-	{0x2cda, 0x800, 0x20000, 0x800, 0x40, 0x0},
-	/* Micron MT29F2G08ABD 256MB */
-	{0x2caa, 0x800, 0x20000, 0x800, 0x40, 0x0},
-	/* Mircon MT29H8G08ACAH1 1GB */
-	{0x2c38, 0x800, 0x80000, 0x1000, 0xe0, 0x0},
-	{0,}
-};
-
 #undef CONFIG_USE_PMECC
 #if defined(CPU_HAS_PMECC) && !defined(CONFIG_ENABLE_SW_ECC)
 #define CONFIG_USE_PMECC
@@ -64,6 +53,15 @@ static struct nand_chip nand_ids[] = {
 #ifdef CONFIG_USE_PMECC
 
 #define TT_MAX			25
+/* ECC offset in spare area */
+#define ECC_START_ADDR		48
+#define ECC_END_ADDR		63
+
+#if defined(AT91SAM9X5) || defined(AT91SAM9N12) || defined (AT91SAMA5D3X)
+#define PMECC_ALGO_FCT_ADDR		0x00100008
+#define LOOKUP_TABLE_ALPHA_TO		0x10C000;
+#define LOOKUP_TABLE_INDEX_OF		0x108000;
+#endif
 
 /* The PMECC descripter structure */
 struct _PMECC_paramDesc_struct {
@@ -98,6 +96,15 @@ struct _PMECC_paramDesc_struct {
 
 } PMECC_paramDesc;
 
+/* ECC detection/coreection */
+typedef int (*PMECC_CorrectionAlgo_Rom_Func) (unsigned long pPMECC,
+			unsigned long pPMERRLOC,
+			struct _PMECC_paramDesc_struct *PMECC_desc,
+			unsigned int PMECC_status,
+			void *pageBuffer);
+
+PMECC_CorrectionAlgo_Rom_Func pmecc_correction_algo;
+
 static int pmecc_readl(unsigned int reg)
 {
 	return(readl(AT91C_BASE_PMECC + reg));
@@ -107,136 +114,99 @@ static void pmecc_writel(unsigned int value, unsigned reg)
 {
 	writel(value, (AT91C_BASE_PMECC + reg));
 }
-
-static int pmecclor_readl(unsigned int reg)
-{
-	return readl(AT91C_BASE_PMERRLOC + reg);
-}
-
-static void pmecclor_writel(unsigned int value, unsigned reg)
-{
-	writel(value, (AT91C_BASE_PMERRLOC + reg));
-}
-
-/*
- * Return 1 means valid pmecc error bits & sector size. otherwise return 0;
- */
-static int is_valid_pmecc_params()
-{
-	int ret = 1;
-	switch (PMECC_ERROR_CORR_BITS) {
-	case 2:
-	case 4:
-	case 8:
-	case 12:
-	case 24:
-		break;
-	default:
-		dbg_log(DEBUG_INFO, "Invalid Pmecc error bits: %d. Should " \
-			"be 2, 4, 8, 12 or 24.\r\n", PMECC_ERROR_CORR_BITS);
-		ret = 0;
-	}
-
-	if (PMECC_SECTOR_SIZE != 512 && PMECC_SECTOR_SIZE != 1024) {
-		dbg_log(DEBUG_INFO, "Invalid Pmecc sector size: %d. Should " \
-				"be 512 or 1024.\r\n", PMECC_SECTOR_SIZE);
-		ret = 0;
-	}
-
-	return ret;
-}
+#endif /* #ifdef CONFIG_USE_PMECC */
 
 /*
- * Return number of ecc bytes per sector according to sector size and
- * correction capability
- *
- * Following table shows what at91 PMECC supported:
- * Correction Capability	Sector_512_bytes	Sector_1024_bytes
- * =====================	================	=================
- *                2-bits                 4-bytes                  4-bytes
- *                4-bits                 7-bytes                  7-bytes
- *                8-bits                13-bytes                 14-bytes
- *               12-bits                20-bytes                 21-bytes
- *               24-bits                39-bytes                 42-bytes
- */
-static int get_pmecc_bytes()
-{
-	int i;
-	int error_corr_bits[] =		{2, 4, 8,  12, 24};
-	int ecc_bytes_sec_512[] =	{4, 7, 13, 20, 39};
-	int ecc_bytes_sec_1024[] =	{4, 7, 14, 21, 42};
-
-	int ecc_bytes = 0;
-	for (i = 0; i < 5; i++) {
-		if (error_corr_bits[i] == PMECC_ERROR_CORR_BITS) {
-			/* find out the index */
-			ecc_bytes = (PMECC_SECTOR_SIZE == 512) ?
-				ecc_bytes_sec_512[i] : ecc_bytes_sec_1024[i];
-			break;
-		}
-	}
-
-	return ecc_bytes;	/* 0 indicate not found */
-}
+* ooblayout 
+*/
+/* ooblayout for 256 byte pages. */
+struct nand_ooblayout ooblayout_256 = {
+	/* bad block marker is at position */
+	5,
+	/* 3 ecc bytes */
+	3,
+	/* ecc byte positions */
+	{0, 1, 2},
+	/* 4 extra bytes */
+	4,
+	/* extra byte positions */
+	{3, 4, 6, 7}
+};
 
-#endif /* #ifdef CONFIG_USE_PMECC */
+/* ooblayout for 512 byte pages */
+struct nand_ooblayout ooblayout_512 = {
+	/* bad block marker is at position */
+	5,
+	/* 6 ecc bytes */
+	6,
+	/* ecc byte positions */
+	{0, 1, 2, 3, 6, 7},
+	/* 8 extra bytes */
+	8,
+	/* extra bytes positions */
+	{8, 9, 10, 11, 12, 13, 14, 15}
+};
 
-/* ooblayout */
-static struct nand_ooblayout nand_oob_layout;
+/* ooblayout for 2048 byte pages */
+struct nand_ooblayout ooblayout_2048 = {
+	/* Bad block marker is at position */
+	0,
+	/* 24 ecc bytes */
+	24,
+	/* ecc byte positions */
+	{40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
+	 58, 59, 60, 61, 62, 63},
+	/* 38 extra bytes */
+	38,
+	/* extra byte positions */
+	{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
+	 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39}
+};
 
 static struct nand_chip nand_chip_default;
 
+static struct nand_onfi_params onfi_params;
+
 /*
  * NAND Commands
  */
+static unsigned char *IO_ADDR_R =
+		(unsigned char *)(unsigned long)CONFIG_SYS_NAND_BASE;
+static unsigned char *IO_ADDR_W =
+		(unsigned char *)(unsigned long)CONFIG_SYS_NAND_BASE;
 
 /* 8 bits devices */
 static void nand_command(unsigned char cmd)
 {
-	volatile unsigned long ioaddr = (unsigned long)CONFIG_SYS_NAND_BASE
-						| CONFIG_SYS_NAND_MASK_CLE;
-
-	writeb(cmd, ioaddr);
+	writeb(cmd, ((unsigned long)IO_ADDR_W | CONFIG_SYS_NAND_MASK_CLE));
 }
 
 static void nand_address(unsigned char addr)
 {
-	volatile unsigned long ioaddr = (unsigned long)CONFIG_SYS_NAND_BASE
-						| CONFIG_SYS_NAND_MASK_ALE;
-
-	writeb(addr, ioaddr);
+	writeb(addr, ((unsigned long)IO_ADDR_W | CONFIG_SYS_NAND_MASK_ALE));
 }
 
 static unsigned char read_byte(void)
 {
-	return(readb((unsigned long)CONFIG_SYS_NAND_BASE));
-}
-
-static void write_byte(unsigned char data)
-{
-	writeb(data, (unsigned long)CONFIG_SYS_NAND_BASE);
+	return(readb((unsigned long)IO_ADDR_R));
 }
 
+#if 0
 /* 16 bits devices */
 static void nand_command16(unsigned short cmd)
 {
-	volatile unsigned long ioaddr = (unsigned long)CONFIG_SYS_NAND_BASE
-						| CONFIG_SYS_NAND_MASK_CLE;
-
-	writew(cmd, ioaddr);
+	writew(cmd, (unsigned long)IO_ADDR_W | CONFIG_SYS_NAND_MASK_CLE);
 }
 
 static void nand_address16(unsigned short addr)
 {
-	volatile unsigned long ioaddr = (unsigned long)CONFIG_SYS_NAND_BASE
-						| CONFIG_SYS_NAND_MASK_ALE;
-
-	writew(addr, ioaddr);
+	writew(addr, (unsigned long)IO_ADDR_W | CONFIG_SYS_NAND_MASK_ALE);
 }
+#endif
 
 static unsigned short read_word(void)
 {
-	return(readw((unsigned long)CONFIG_SYS_NAND_BASE));
+	return(readw((unsigned long)IO_ADDR_R));
 }
 
 static void nand_wait_ready(void)
@@ -244,8 +214,7 @@ static void nand_wait_ready(void)
 	unsigned int timeout = 10000;
 
 	nand_command(CMD_STATUS);
-	while ((!(read_byte() & STATUS_READY)) && timeout--)
-		;
+	while((!(read_byte() & STATUS_READY)) && timeout--);
 }
 
 static void nand_cs_enable(void)
@@ -262,89 +231,7 @@ static void nand_cs_disable(void)
 #endif
 }
 
-static void config_nand_ooblayout(struct nand_ooblayout *layout, struct nand_chip *chip)
-{
-	unsigned int i;
-	unsigned int oobsize = 0;
-
-	switch (chip->pagesize) {
-	case 256:
-		layout->badblockpos = 5;
-		layout->eccbytes = 3;
-		layout->oobavail_offset = 6;
-		oobsize = chip->oobsize;
-		break;
-
-	case 512:
-		layout->badblockpos = 5;
-		layout->eccbytes = 6;
-		layout->oobavail_offset = 6;
-		oobsize = chip->oobsize;
-		break;
-
-	case 2048:
-		layout->badblockpos = 0;
-		oobsize = chip->oobsize;
-#ifdef CONFIG_USE_PMECC
-		layout->eccbytes = chip->pagesize / PMECC_SECTOR_SIZE
-			* get_pmecc_bytes();
-#else
-		layout->eccbytes = 24;
-#endif
-		layout->oobavail_offset = 1;
-		break;
-
-	case 4096:
-		layout->badblockpos = 0;
-#ifdef CONFIG_USE_PMECC
-		layout->eccbytes = chip->pagesize / PMECC_SECTOR_SIZE
-			* get_pmecc_bytes();
-		oobsize = chip->oobsize;
-#else
-		layout->eccbytes = 48;
-		oobsize = 128;
-#endif
-		layout->oobavail_offset = 1;
-		break;
-
-	default:
-		break;
-	}
-
-	for (i = 0; i < layout->eccbytes; i++)
-		layout->eccpos[i] = oobsize - layout->eccbytes + i;
-
-	layout->oobavailbytes = oobsize - layout->eccbytes
-					- layout->oobavail_offset;
-}
-
-static int nand_disable_internal_ecc(unsigned char manfid,
-				unsigned char devicemodel,
-				unsigned char ecc_bits)
-{
-	if (((manfid & 0x2c) == 0x2c)	/* Micron */
-		&& (ecc_bits == 0x04)
-		&& ((devicemodel == '1') 	/* 1G */
-		|| (devicemodel == '2')		/* 2G*/
-		|| (devicemodel == '4'))) {	/* 4G */
-
-		nand_cs_enable();
-		nand_command(CMD_SET_FEATURE);
-		nand_address(0x90);
-
-		write_byte(0x00);
-		write_byte(0x00);
-		write_byte(0x00);
-		write_byte(0x00);
-		nand_cs_disable();
-	}
-	return 0;
-
-}
-
-static unsigned short onfi_crc16(unsigned short crc,
-				unsigned char const *p,
-				unsigned int len)
+static unsigned short onfi_crc16(unsigned short crc, unsigned char const *p, unsigned int len)
 {
 	int i;
 
@@ -357,29 +244,14 @@ static unsigned short onfi_crc16(unsigned short crc,
 	return crc;
 }
 
-#define ONFI_PARAMS_SIZE		256
-
-#define PARAMS_OFFSET_BUSWIDTH		6
-#define PARAMS_OFFSET_MODEL		49
-#define PARAMS_OFFSET_JEDEC_ID		64
-#define PARAMS_OFFSET_PAGESIZE		80
-#define PARAMS_OFFSET_OOBSIZE		84
-#define PARAMS_OFFSET_BLOCKSIZE		92
-#define PARAMS_OFFSET_NBBLOCKS		96
-#define PARAMS_OFFSET_ECC_BITS		112
-#define PARAMS_OFFSET_CRC		254
-
-#define ONFI_CRC_BASE			0x4F4E
-
+/* Check if the NAND chip is ONFI compliant, returns 0 if it is, -1 otherwise */
 static int nandflash_detect_onfi(struct nand_chip *chip)
 {
+	struct nand_onfi_params *p = &onfi_params;
 	unsigned char onfi_ind[4];
-	unsigned char onfi_params[ONFI_PARAMS_SIZE];
-	unsigned char *p = onfi_params;
-	unsigned char *param;
 	int i, j;
-	unsigned short crc;
-	unsigned char jedec_id, model, ecc_bits;
+	unsigned int onfi_version;
+	unsigned char *param;
 
 	nand_cs_enable();
 	nand_command(CMD_READID);
@@ -395,14 +267,15 @@ static int nandflash_detect_onfi(struct nand_chip *chip)
 		|| (onfi_ind[1] != 'N')
 		|| (onfi_ind[2] != 'F')
 		|| (onfi_ind[3] != 'I')) {
-		dbg_log(1, "NAND: ONFI not supported\n\r");
+		dbg_log(1, "Nand: ONFI not supported\n\r");
 		return -1;
 	}
 
-	dbg_log(1, "NAND: ONFI flash detected\n\r");
+	dbg_log(1, "ONFI flash detected\n\r");
 
 	nand_cs_enable();
 
+	/* read the nand ONFI parameter */
 	nand_command(CMD_READ_ONFI);
 	nand_address(0x00);
 	
@@ -410,104 +283,190 @@ static int nandflash_detect_onfi(struct nand_chip *chip)
 	nand_command(CMD_READ_1);
 	
 	for (i = 0; i < 3; i++) {
-		param = onfi_params;
-		/* Read the onfi parameter table */
-		for (j = 0; j < ONFI_PARAMS_SIZE; j++)
+		param = (unsigned char *)p;
+		/* Read the parameter table */
+		for (j = 0; j < sizeof(onfi_params); j++)
 			*param++ = read_byte();
 
-		crc = *(unsigned short *)(p + PARAMS_OFFSET_CRC);
-		if (onfi_crc16(ONFI_CRC_BASE, (unsigned char *)p, 254) == crc)
+		if (onfi_crc16(ONFI_CRC_BASE, (unsigned char *)p, 254) == p->crc) {
+			dbg_log(1, "ONFI param page %d valid\n\r", i);
 			break;
+		}
 	}
 
 	nand_cs_disable();
 
 	if (i == 3) {
-		dbg_log(1, "NAND: ONFI para CRC error!\n\r");
+		dbg_log(1, "ONFI para CRC error!\n\r");
 		return -1;
 	}
 
-	chip->numblocks = *(unsigned short *)(p + PARAMS_OFFSET_NBBLOCKS);
-	chip->pagesize	= *(unsigned short *)(p + PARAMS_OFFSET_PAGESIZE);
-	chip->blocksize = *(unsigned int  *)(p + PARAMS_OFFSET_BLOCKSIZE)
-							* chip->pagesize;
-	chip->oobsize	= *(unsigned char *)(p + PARAMS_OFFSET_OOBSIZE);
-	chip->buswidth	= (*(unsigned char *)(p + PARAMS_OFFSET_BUSWIDTH))
-								& 0x01;
+	/* check version */
+	if (p->revision & (1 << 5))
+		onfi_version = 23;
+	else if (p->revision & (1 << 4))
+		onfi_version = 22;
+	else if (p->revision & (1 << 3))
+		onfi_version = 21;
+	else if (p->revision & (1 << 2))
+		onfi_version = 20;
+	else if (p->revision & (1 << 1))
+		onfi_version = 10;
+	else
+		onfi_version = 0;
+
+	if (!onfi_version) {
+		dbg_log(1, "%s: unsupported ONFI version: %d\n\r", __func__, p->revision);
+		return -1;
+	}
 
-	jedec_id = *(unsigned char *)(p + PARAMS_OFFSET_JEDEC_ID);
-	model	 = *(unsigned char *)(p + PARAMS_OFFSET_MODEL);
-	ecc_bits = *(unsigned char *)(p + PARAMS_OFFSET_ECC_BITS);
+	chip->numblocks = p->blocks_per_lun;
+	chip->pagesize 	= p->byte_per_page;
+	chip->blocksize = p->pages_per_block * chip->pagesize;
+	chip->oobsize 	= p->spare_bytes_per_page;
+	chip->buswidth	= p->features & 0x01;
 
-	nand_disable_internal_ecc(jedec_id, model, ecc_bits);
+	/* some flashes lie about their buswidth, these platforms always use 8 bit */
+#if defined(CONFIG_STAMP9G20) || defined(CONFIG_STAMP9G45) || defined(CONFIG_NANOSG20) || defined(CONFIG_PICOSG20)
+	chip->buswidth	= 0;
+#endif
 
+	switch (chip->pagesize) {
+	case 256: chip->ecclayout = &ooblayout_256; break;
+	case 512: chip->ecclayout = &ooblayout_512; break;
+	case 2048: chip->ecclayout = &ooblayout_2048; break;
+	case 4096: break;
+	default:
+		dbg_log(1, "Not supported page size: %d\n\r", chip->pagesize);
+		return -1;
+	}
 	return 0;
 }
 
 static int nandflash_detect_non_onfi(struct nand_chip *chip)
 {
-	int manf_id, dev_id;
-	unsigned int chipid;
-	unsigned int i;
+	int manf_id, dev_id, cellinfo, extid, tmp_manf, tmp_dev;
+	struct nandflash_dev *type;
 
 	nand_cs_enable();
 
-	/* Reading device ID */
+	/* Send the command for reading device ID */
 	nand_command(CMD_READID);
 	nand_address(0x00);
 
+	/* Read manufacturer and device IDs */
 	manf_id  = read_byte();
 	dev_id   = read_byte();
+	cellinfo = read_byte();
+	extid    = read_byte();
+
+	/*
+	 * Try again to make sure, as some systems the bus-hold or other
+	 * interface concerns can cause random data which looks like a
+	 * possibly credible NAND flash to appear. If the two results do
+	 * not match, ignore the device completely.
+	 */
 
-	chipid = (manf_id << 8) | dev_id;
+	nand_command(CMD_READID);
+	nand_address(0x00);
 
-	for (i = 0; i < ARRAY_SIZE(nand_ids); i++) {
-		if (chipid == nand_ids[i].chip_id)
-			break;
-	}
+	/* Read manufacturer and device IDs */
+	tmp_manf = read_byte();
+	tmp_dev  = read_byte();
 
-	if (i == ARRAY_SIZE(nand_ids)) {
-		dbg_log(1, "NAND: Not found Manufacturer ID: %d," \
-			"Chip ID: 0x%d\n\r", manf_id, dev_id);
+	nand_cs_disable();
 
+	if (tmp_manf != manf_id || tmp_dev != dev_id) {
+		dbg_log(1, "%s: second ID read did not match "
+		       "%d, %d against %d, %d\n\r", __func__,
+		       manf_id, dev_id, tmp_manf, tmp_dev);
 		return -1;
 	}
 
-	dbg_log(1, "NAND: Manufacturer ID: %d Chip ID: %d\n\r",
-						manf_id, dev_id);
+	cellinfo = cellinfo;
 
-	chip->pagesize	= nand_ids[i].pagesize;
-	chip->blocksize = nand_ids[i].blocksize;
-	chip->oobsize	= nand_ids[i].oobsize;
-	chip->buswidth	= nand_ids[i].buswidth;
-	chip->numblocks = nand_ids[i].numblocks;
+	type = (struct nandflash_dev *)&nandflash_ids[0];
+	
+	for (; type->name != NULL; type++)
+		if (dev_id == type->id)
+			break;
+	
+	if (type->name == NULL){
+		if (manf_id != 0x00 && manf_id != 0xff 
+			&& dev_id != 0x00 && dev_id != 0xff)
+			dbg_log(1, "unknown NAND device: Manufacturer ID: %d", 
+				"Chip ID: 0x%d\n\r", manf_id, dev_id);
+		return -1;
+	}
+	
+	dbg_log(1, "NAND device: %s, Manufacturer ID: %d Chip ID: %d\n\r",
+			type->name, manf_id, dev_id);
+
+	/* Newer devices have all the information in additional id bytes */
+	if (type->pagesize == 0){
+		/* Calc pagesize */
+		chip->pagesize = 1024 << (extid & 0x3);
+		extid >>= 2;
+		/* Calc oobsize */
+		chip->oobsize = (8 << (extid & 0x01)) * (chip->pagesize >> 9);
+		extid >>= 2;
+		/* Calc blocksize. Blocksize is multiples of 64KiB */
+		chip->blocksize = (64 * 1024) << (extid & 0x03);
+		extid >>= 2;
+		/* Get buswidth information */
+		chip->buswidth = (extid & 0x01) ? 1 : 0;
+	} else {
+		/* Old devices have chip data hardcoded in the device id table */
+		chip->pagesize 	= type->pagesize;
+		chip->blocksize = type->erasesize;
+		chip->oobsize 	= chip->pagesize / 32;
+		chip->buswidth 	= (((type->options & NAND_BUSWIDTH_16) 
+						== NAND_BUSWIDTH_16) ? 1: 0); 
+	}
+
+	switch (chip->pagesize) {
+	case 256: chip->ecclayout = &ooblayout_256; break;
+	case 512: chip->ecclayout = &ooblayout_512; break;
+	case 2048:chip->ecclayout = &ooblayout_2048; break;
+	case 4096: break;
+	default:
+		dbg_log(1, "Not supported page size: %d\n\r", chip->pagesize);
+		return -1;
+	}
 
 	return 0;
+
+	
 }
 
 static void nand_info_init(struct nand_info *nand, struct nand_chip *chip)
 {
+	unsigned int pagesize, i = 0;
+
 	/* number of blocks in device */
 	nand->numblocks = chip->numblocks;
 	/* number of data bytes in a block */
 	nand->blocksize = chip->blocksize;
 	/* number of bytes in page area */
 	nand->pagesize = chip->pagesize;
-	/* number of pages in block */
-	nand->pages_block = nand->blocksize / nand->pagesize;
-	/* number of pages in device */
-	nand->pages_device = nand->numblocks * nand->pages_block;
 	/* number of bytes in oob area */
 	nand->oobsize = chip->oobsize;
 	/* Total number of bytes in a sector */
 	nand->sectorsize = nand->pagesize + nand->oobsize;
-	/* the layout of the spare area */
-	config_nand_ooblayout(&nand_oob_layout, chip);
-	nand->ecclayout = &nand_oob_layout;
-	/* data bus width (8/16 bits) */
-	nand->buswidth = chip->buswidth;
+	nand->ecclayout = chip->ecclayout;
+	nand->buswidth = chip->buswidth;	/* Data Bus Width (8/16 bits) */
+
+	pagesize = nand->pagesize - 1;
+	nand->page_shift = 0;
+	while (pagesize >> i) {
+		nand->page_shift++;
+		i++;
+	}
+  
 	if (nand->buswidth)
-		nand->ecclayout->badblockpos *= 2;
+		nand->badblockpos = 2 * nand->ecclayout->badblockpos;
+	else
+		nand->badblockpos = nand->ecclayout->badblockpos;
 }
 
 static void nandflash_reset(void)
@@ -532,7 +491,7 @@ static int nandflash_get_type(struct nand_info *nand)
 	ret = nandflash_detect_onfi(chip);
 	if (ret == -1) {
 		if (nandflash_detect_non_onfi(chip)) {
-			dbg_log(1, "NAND: Not find support device!\n\r");
+			dbg_log(1, "Not Find Support NAND Device!\n\r");
 			return -1;
 		}
 	}
@@ -547,106 +506,52 @@ static int nandflash_get_type(struct nand_info *nand)
 	return 0;
 }
 
-#ifdef CONFIG_USE_PMECC
-
-static int init_pmecc_descripter(struct _PMECC_paramDesc_struct *pmecc_params,
-				struct nand_info *nand)
+static void send_large_block_address(unsigned int addr)
 {
-	if ((nand->pagesize == 2048) || (nand->pagesize == 4096)) {
-		/* Sector Size */
-		pmecc_params->sectorSize = (PMECC_SECTOR_SIZE == 512) ?
-			AT91C_PMECC_SECTORSZ_512 : AT91C_PMECC_SECTORSZ_1024;
-
-		pmecc_params->nandWR = AT91C_PMECC_NANDWR_0;
-		pmecc_params->spareEna = AT91C_PMECC_SPAREENA_DIS;
-		pmecc_params->modeAuto = AT91C_PMECC_AUTO_DIS;
-
-		pmecc_params->spareSize = nand->oobsize;
-		pmecc_params->eccSizeByte = nand->ecclayout->eccbytes;
-		pmecc_params->eccStartAddress = nand->ecclayout->eccpos[0];
-		pmecc_params->eccEndAddress
-		= nand->ecclayout->eccpos[nand->ecclayout->eccbytes - 1];
+	nand_address((addr >> 0) & 0xFF);
+	nand_address((addr >> 8) & 0xFF);
+}
 
-		/* At 133Mhz, this field must be programmed with 2 */
-		pmecc_params->clkCtrl = 2;
+static void send_sector_address(unsigned int addr)
+{
+	send_large_block_address(addr);
+	nand_address((addr >> 16) & 0xFF);
+}
 
+#ifdef CONFIG_USE_PMECC
+static int init_pmecc_descripter(struct _PMECC_paramDesc_struct *pmecc_params, unsigned int pagesize)
+{
+	switch (pagesize) {
+	case 2048:
+		pmecc_params->errBitNbrCapability = AT91C_PMECC_BCH_ERR2; /* Error Correct Capability */
+		pmecc_params->sectorSize = AT91C_PMECC_SECTORSZ_512; /* Sector Size */
+		pmecc_params->pageSize = AT91C_PMECC_PAGESIZE_4SEC; /* Number of Sectors in the Page */
+		pmecc_params->nandWR = AT91C_PMECC_NANDWR_0;	/* NAND read access */
+		pmecc_params->spareEna = AT91C_PMECC_SPAREENA_DIS; /* for NAND read access,the spare area is skipped  */
+		pmecc_params->modeAuto = AT91C_PMECC_AUTO_DIS;	/* the spare area is not protected */
+
+		pmecc_params->spareSize = 64;	/* Spare Area Size */
+		pmecc_params->eccStartAddress = ECC_START_ADDR;	/* ECC Area Start Address */
+		pmecc_params->eccEndAddress = ECC_END_ADDR;	/* ECC Area End Address */
+		pmecc_params->eccSizeByte = 16;
+		pmecc_params->clkCtrl = 2;	/* At 133Mhz, this field must be programmed with 2 */
 		pmecc_params->interrupt = 0;
-		pmecc_params->tt = PMECC_ERROR_CORR_BITS;
+		pmecc_params->tt = 2;
 		pmecc_params->mm = 13;
 		pmecc_params->nn = (1 << pmecc_params->mm) - 1;
+		pmecc_params->alpha_to = (short *)LOOKUP_TABLE_ALPHA_TO;
+		pmecc_params->index_of = (short *)LOOKUP_TABLE_INDEX_OF;
+		break;
 
-		if (PMECC_SECTOR_SIZE == 512) {
-			pmecc_params->alpha_to = (short *)(AT91C_BASE_ROM
-						+ CONFIG_LOOKUP_TABLE_ALPHA_OFFSET);
-			pmecc_params->index_of = (short *)(AT91C_BASE_ROM
-						+ CONFIG_LOOKUP_TABLE_INDEX_OFFSET);
-		} else {
-			pmecc_params->alpha_to = (short *)(AT91C_BASE_ROM
-						+ CONFIG_LOOKUP_TABLE_ALPHA_OFFSET_1024);
-			pmecc_params->index_of = (short *)(AT91C_BASE_ROM
-						+ CONFIG_LOOKUP_TABLE_INDEX_OFFSET_1024);
-		}
-
-		/* Error Correct Capability */
-		switch (PMECC_ERROR_CORR_BITS) {
-		case 2:
-			pmecc_params->errBitNbrCapability
-						= AT91C_PMECC_BCH_ERR2;
-			break;
-		case 4:
-			pmecc_params->errBitNbrCapability
-						= AT91C_PMECC_BCH_ERR4;
-			break;
-		case 8:
-			pmecc_params->errBitNbrCapability
-						= AT91C_PMECC_BCH_ERR8;
-			break;
-		case 12:
-			pmecc_params->errBitNbrCapability
-						= AT91C_PMECC_BCH_ERR12;
-			break;
-		case 24:
-			pmecc_params->errBitNbrCapability
-						= AT91C_PMECC_BCH_ERR24;
-			break;
-		default:
-			dbg_log(1, "PMECC: Invalid error correctable " \
-				"bits: %d\n\r",	PMECC_ERROR_CORR_BITS);
-			return -1;
-		}
-
-		/* Number of Sectors in the Page */
-		switch (nand->pagesize / PMECC_SECTOR_SIZE) {
-		case 1:
-			pmecc_params->pageSize = AT91C_PMECC_PAGESIZE_1SEC;
-			break;
-		case 2:
-			pmecc_params->pageSize = AT91C_PMECC_PAGESIZE_2SEC;
-			break;
-		case 4:
-			pmecc_params->pageSize = AT91C_PMECC_PAGESIZE_4SEC;
-			break;
-		case 8:
-			pmecc_params->pageSize = AT91C_PMECC_PAGESIZE_8SEC;
-			break;
-		default:
-			dbg_log(1, "PMECC: Not supported sector size: %d\n\r",
-				nand->pagesize / PMECC_SECTOR_SIZE);
-			return -1;
-		}
-
-		dbg_log(DEBUG_LOUD, "PMECC: page_size: %u, oob_size: %u, " \
-					"pmecc_cap: %u, sector_size: %u\r\n",
-			nand->pagesize, nand->oobsize, pmecc_params->tt,
-			pmecc_params->sectorSize
-				== AT91C_PMECC_SECTORSZ_512 ? 512 : 1024);
-
-		return 0;
-	} else {
-		dbg_log(1, "PMECC: Not supported page size: %d\n\r",
-							nand->pagesize);
+	case 512:
+	case 1024:
+	case 4096:
+		/* TODO */
+	default:
+		dbg_log(1, "Not supported page size: %d\n\r", pagesize);
 		return -1;
 	}
+	return 0;
 } 
 
 static int init_pmecc_core(struct _PMECC_paramDesc_struct *pmecc_params)
@@ -672,13 +577,12 @@ static int init_pmecc_core(struct _PMECC_paramDesc_struct *pmecc_params)
 	return 0;
 }
 
-static int init_pmecc(struct nand_info *nand)
+static int init_pmecc(unsigned int pagesize)
 {
-	/* sanity check for the pmecc sector size and error bits */
-	if (!is_valid_pmecc_params())
-		return -1;
+	pmecc_correction_algo = (PMECC_CorrectionAlgo_Rom_Func)
+			(*(unsigned int *)PMECC_ALGO_FCT_ADDR);
 
-	if (init_pmecc_descripter(&PMECC_paramDesc, nand) != 0)
+	if (init_pmecc_descripter(&PMECC_paramDesc, pagesize) != 0)
 		return -1;
 
 	init_pmecc_core(&PMECC_paramDesc);
@@ -687,537 +591,136 @@ static int init_pmecc(struct nand_info *nand)
 }
 #endif /* #ifdef CONFIG_USE_PMECC */
 
-static void write_column_address(struct nand_info *nand,
-				unsigned int column_address)
-{
-	volatile unsigned int page_size = nand->pagesize;
+#ifdef CONFIG_ENABLE_SW_ECC_BCH
+void *_sbrk(int increment);
+#define malloc(s)      _sbrk(s)
+#define free(p)
 
-	if (nand->buswidth)
-		column_address >>= 1;
+static int bch_algo_needs_init = 1;
 
-	while (page_size > 2) {
-		if (nand->buswidth)
-			nand_address16(column_address & 0xff);
-		else
-			nand_address(column_address & 0xff);
-
-		page_size >>= 8;
-		column_address >>= 8;
-	}
-}
-
-static void write_row_address(struct nand_info *nand,
-				unsigned int row_address)
+static void bch_build_scheme(struct nand_info *ecc,
+                              unsigned int eccbytes)
 {
-	volatile unsigned int num_pages = nand->pages_device;
-
-	while(num_pages) {
-		if (nand->buswidth)
-			nand_address16(row_address & 0xff);
-		else
-			nand_address(row_address & 0xff);
-
-		num_pages >>= 8;
-		row_address >>= 8;
-	}
+	unsigned int pagesize, sparesize, extrasize, subpagenum, i;
+	struct nand_ooblayout *scheme;
+
+	pagesize = ecc->pagesize;
+	sparesize = ecc->oobsize;
+	/* adjust number of eccbytes to cover all subpages */
+	subpagenum = pagesize / SW_ECC_BCH_BLOCKSIZE;
+	eccbytes *= subpagenum;
+	extrasize = sparesize - eccbytes - 2;
+	scheme = ecc->ecclayout;
+	/* simply overwrite the old spare scheme */
+	scheme->eccbytes = eccbytes;
+	/* ecc bytes are aligned at the end of spare area */
+	for(i=0; i<eccbytes; i++)
+		scheme->eccpos[i] = sparesize - eccbytes + i;
+	scheme->oobavailbytes = extrasize;
+	for(i=0; i<extrasize; i++)
+		scheme->oobavailpos[i] = sparesize - eccbytes - extrasize + i;
 }
 
-#ifdef CONFIG_USE_PMECC
-static int check_pmecc_ecc_data(struct nand_info *nand,
-				unsigned char *buffer)
+static int bch_algo_init(struct nand_info *ecc)
 {
-	unsigned int i;
-	unsigned char *ecc_data = buffer + nand->pagesize
-				+ nand->ecclayout->eccpos[0];
+	int m, t;
+	unsigned int eccsize, eccbytes, sparesize, pagesize, i;
+	unsigned char *erased_page;
 
-	for (i = 0; i < nand->ecclayout->eccbytes; i++)
-		if (*ecc_data++ != 0xff)
-			break;
+	dbg_log(1, "ECC_ALGO_BCH, %d bit correction\n\r", SW_ECC_BCH_BITS);
 
-	if (i >= nand->ecclayout->eccbytes)
-		return -1;
-	else
+	if(bch_algo_needs_init == 0)
 		return 0;
-}
-
-/*
- * \brief Build the pseudo syndromes table
- * \param pPmeccDescriptor Pointer to a PMECC_paramDesc instance.
- * \param sector Targetted sector.
- */
-
-static void GenSyn(unsigned long pPMECC,
-		struct _PMECC_paramDesc_struct *pPmeccDescriptor,
-		unsigned int sector)
-{
-	short *pRemainer;
-	unsigned int index;
-
-	pRemainer = (short *) (pPMECC + PMECC_REM + (sector * 0x40));
 
-	for (index = 0; index < pPmeccDescriptor->tt; index++)
-		/* Fill odd syndromes */
-		pPmeccDescriptor->partialSyn[1 +  (2 * index)]
-						= pRemainer[index];
-}
-
-/**
- * \brief The substitute function evaluates the polynomial remainder,
- * with different values of the field primitive elements.
- * \param pPmeccDescriptor Pointer to a PMECC_paramDesc instance.
- */
-static int substitute(struct _PMECC_paramDesc_struct *pPmeccDescriptor)
-{
-	int i, j;
-	short *si;
-	short *pPartialSyn = pPmeccDescriptor->partialSyn;
-	short *alpha_to = pPmeccDescriptor->alpha_to;
-	short *index_of = pPmeccDescriptor->index_of;
-
-	/*
-	 * si[] is a table that holds the current syndrome value,
-	 * an element of that table belongs to the field.
-	 */
-	si = pPmeccDescriptor->si;
-
-	for (i = 1; i < 2 * TT_MAX; i++)
-		si[i] = 0;
-
-	/* Computation 2t syndromes based on S(x) */
-	/* Odd syndromes */
-	for (i = 1; i <= 2 * pPmeccDescriptor->tt - 1; i = i + 2) {
-		si[i] = 0;
-		for (j = 0; j < pPmeccDescriptor->mm; j++) {
-			if (pPartialSyn[i] & ((unsigned short)0x1 << j))
-				si[i] = alpha_to[(i * j)] ^ si[i];
-		}
-	}
-	/* Even syndrome = (Odd syndrome) ** 2 */
-	for (i = 2; i <= 2 * pPmeccDescriptor->tt; i = i + 2) {
-		j = i / 2;
-		if (si[j] == 0)
-			si[i] = 0;
-		else
-			si[i] = alpha_to[(2 * index_of[si[j]])
-				% (unsigned int)pPmeccDescriptor->nn];
-	}
-
-	return 0;
-}
-
-/*
- * \brief The substitute function finding the value of the error
- * location polynomial.
- * \param pPmeccDescriptor Pointer to a PMECC_paramDesc instance.
- */
-static unsigned int get_sigma(struct _PMECC_paramDesc_struct *pPmeccDescriptor)
-{
-	unsigned int dmu_0_count;
-	int i, j, k;
-	short *lmu = pPmeccDescriptor->lmu;
-	short *si = pPmeccDescriptor->si;
-	short tt = pPmeccDescriptor->tt;
-
-	/* mu  */
-	int mu[TT_MAX+1];
-
-	/* discrepancy */
-	int dmu[TT_MAX+1];
-
-	/* delta order   */
-	int delta[TT_MAX+1];
-
-	/* index of largest delta */
-	int ro;
-	int largest;
-	int diff;
-
-	dmu_0_count = 0;
-
-	/* First Row  */
-
-	/* Mu */
-	mu[0]  = -1;
-	/* Actually -1/2 */
-	/* Sigma(x) set to 1 */
-
-	for (i = 0; i < (2 * TT_MAX + 1); i++)
-		pPmeccDescriptor->smu[0][i] = 0;
-
-	pPmeccDescriptor->smu[0][0] = 1;
-
-	/* discrepancy set to 1 */
-	dmu[0] = 1;
-
-	/* polynom order set to 0 */
-	lmu[0] = 0;
-
-	/* delta set to -1 */
-	delta[0]  = (mu[0] * 2 - lmu[0]) >> 1;
-
-	/*                     */
-	/*     Second Row      */
-	/*                     */
-
-	/* Mu */
-	mu[1]  = 0;
-
-	/* Sigma(x) set to 1 */
-	for (i = 0; i < (2 * TT_MAX + 1); i++)
-		pPmeccDescriptor->smu[1][i] = 0;
-
-	pPmeccDescriptor->smu[1][0] = 1;
-
-	/* discrepancy set to S1 */
-	dmu[1] = si[1];
-
-	/* polynom order set to 0 */
-	lmu[1] = 0;
-
-	/* delta set to 0 */
-	delta[1]  = (mu[1] * 2 - lmu[1]) >> 1;
-
-	/* Init the Sigma(x) last row */
-	for (i = 0; i < (2 * TT_MAX + 1); i++)
-		pPmeccDescriptor->smu[tt + 1][i] = 0;
-
-	for (i = 1; i <= tt; i++) {
-		mu[i+1] = i << 1;
-		/* Compute Sigma (Mu+1)             */
-		/* And L(mu)                        */
-		/* check if discrepancy is set to 0 */
-		if (dmu[i] == 0) {
-			dmu_0_count++;
-			if ((tt - (lmu[i] >> 1) - 1) & 0x1) {
-				if (dmu_0_count
-					== ((tt - (lmu[i] >> 1) - 1) / 2) + 2) {
-					for (j = 0; j <= (lmu[i] >> 1) + 1; j++)
-						pPmeccDescriptor->smu[tt+1][j]
-						= pPmeccDescriptor->smu[i][j];
-
-					lmu[tt + 1] = lmu[i];
-					return 0;
-				}
-			} else {
-				if (dmu_0_count
-					== ((tt - (lmu[i] >> 1) - 1) / 2) + 1) {
-					for (j = 0; j <= (lmu[i] >> 1) + 1; j++)
-						pPmeccDescriptor->smu[tt + 1][j]
-						= pPmeccDescriptor->smu[i][j];
-
-					lmu[tt + 1] = lmu[i];
-					return 0;
-				}
-			}
-
-			/* copy polynom */
-			for (j = 0; j <= lmu[i] >> 1; j++)
-				pPmeccDescriptor->smu[i + 1][j]
-						= pPmeccDescriptor->smu[i][j];
-
-			/* copy previous polynom order to the next */
-			lmu[i + 1] = lmu[i];
-		} else {
-			ro = 0;
-			largest = -1;
-			/* find largest delta with dmu != 0 */
-			for (j = 0; j < i; j++) {
-				if (dmu[j]) {
-					if (delta[j] > largest) {
-						largest = delta[j];
-						ro = j;
-					}
-				}
-			}
-
-			/* compute difference */
-			diff = (mu[i] - mu[ro]);
-
-			/* Compute degree of the new smu polynomial */
-			if ((lmu[i]>>1) > ((lmu[ro]>>1) + diff))
-				lmu[i + 1] = lmu[i];
-			else
-				lmu[i + 1] = ((lmu[ro]>>1) + diff) * 2;
-
-			/* Init smu[i+1] with 0 */
-			for (k = 0; k < (2 * TT_MAX+1); k++)
-				pPmeccDescriptor->smu[i+1][k] = 0;
-
-			/* Compute smu[i+1] */
-			for (k = 0; k <= lmu[ro]>>1; k++)
-				if (pPmeccDescriptor->smu[ro][k] && dmu[i])
-					 pPmeccDescriptor->smu[i + 1][k + diff] = pPmeccDescriptor->alpha_to[(pPmeccDescriptor->index_of[dmu[i]]
-									+ (pPmeccDescriptor->nn	- pPmeccDescriptor->index_of[dmu[ro]])
-									+ pPmeccDescriptor->index_of[pPmeccDescriptor->smu[ro][k]]) % (unsigned int)pPmeccDescriptor->nn];
-
-			for (k = 0; k <= lmu[i]>>1; k++)
-				pPmeccDescriptor->smu[i+1][k] ^= pPmeccDescriptor->smu[i][k];
-		}
-
-		/*************************************************/
-		/*                                               */
-		/*      End Compute Sigma (Mu+1)                 */
-		/*      And L(mu)                                */
-		/*************************************************/
-		/* In either case compute delta */
-		delta[i + 1]  = (mu[i + 1] * 2 - lmu[i + 1]) >> 1;
-
-		/* Do not compute discrepancy for the last iteration */
-		if (i < tt) {
-			for (k = 0 ; k <= (lmu[i + 1] >> 1); k++) {
-				if (k == 0)
-					dmu[i + 1] = si[2 * (i - 1) + 3];
-				/*
-				 * check if one operand of the multiplier
-				 * is null, its index is -1
-				 */
-				else if (pPmeccDescriptor->smu[i+1][k] && si[2 * (i - 1) + 3 - k])
-					dmu[i + 1] = pPmeccDescriptor->alpha_to[(pPmeccDescriptor->index_of[pPmeccDescriptor->smu[i + 1][k]]
-							+ pPmeccDescriptor->index_of[si[2 * (i - 1) + 3 - k]]) % (unsigned int)pPmeccDescriptor->nn] ^ dmu[i + 1];
-			}
-		}
-	}
-	return 0;
-}
-
-/*
- * \brief Init the PMECC Error Location peripheral and start the error
- *        location processing
- * \param pPmeccDescriptor Pointer to a PMECC_paramDesc instance.
- * \param SectorSizeInBits Size of the sector in bits.
- * \return Number of errors
- */
-static int ErrorLocation(unsigned long pPMERRLOC,
-		struct _PMECC_paramDesc_struct *pPmeccDescriptor,
-		unsigned int SectorSizeInBits)
-{
-	unsigned int alphax;
-	unsigned int *pSigma;
-	unsigned int errorNumber;
-	unsigned int NbrOfRoots;
-
-	/* Disable PMECC Error Location IP */
-	pmecclor_writel(0xFFFFFFFF, PMERRLOC_ELDIS);
-
-	errorNumber = 0;
-	alphax = 0;
-
-	pSigma = (unsigned int *) (pPMERRLOC + PMERRLOC_SIGMA0);
-
-	for (alphax = 0;
-		alphax <= pPmeccDescriptor->lmu[pPmeccDescriptor->tt + 1] >> 1;
-		alphax++) {
-		*pSigma++ = pPmeccDescriptor->smu[pPmeccDescriptor->tt + 1][alphax];
-		errorNumber++;
-	}
-
-	pmecclor_writel(((errorNumber - 1) << 16)
-			| pmecclor_readl(PMERRLOC_ELCFG), PMERRLOC_ELCFG);
-	/* Enable error location process */
-	pmecclor_writel(SectorSizeInBits, PMERRLOC_ELEN);
-
-	while ((pmecclor_readl(PMERRLOC_ELISR) & PMERRLOC_ELISR_DONE) == 0);
-
-	NbrOfRoots = (pmecclor_readl(PMERRLOC_ELISR)
-				& PMERRLOC_ELISR_ERR_CNT) >> 8;
-	/* Number of roots == degree of smu hence <= tt */
-	if (NbrOfRoots == pPmeccDescriptor->lmu[pPmeccDescriptor->tt + 1] >> 1)
-		return errorNumber - 1;
+	/* initialise BCH algorithm according to linux kernel 3.7 */
+	eccsize = SW_ECC_BCH_BLOCKSIZE;
+	pagesize = ecc->pagesize;
+	sparesize = ecc->oobsize;
+	m = fls(1+8*eccsize);
+	t = SW_ECC_BCH_BITS;
+	eccbytes = DIV_ROUND_UP((m * t), 8);
+	ecc->bch.eccbytes = eccbytes;
+	ecc->bch.eccsteps = pagesize / eccsize;
+	if(eccbytes > (sparesize - 2))
+		return -1;
 
-	/* Number of roots not match the degree of smu ==> unable to correct error */
-	return -1;
-}
+	/* build new spare scheme for BCH */
+	bch_build_scheme(ecc, eccbytes);
 
-/*
- * \brief Correct errors indicated in the PMECCEL error location registers.
- * \param sectorBaseAddress Base address of the sector.
- * \param ExtraBytes Number of extra bytes of the sector.
- * (encoded Spare Area, only for the last sector)
- * \param ErrorNbr Number of error to correct
- * \return Number of errors
- */
-static unsigned int ErrorCorrection(unsigned long pPMERRLOC,
-			struct _PMECC_paramDesc_struct *pPmeccDescriptor,
-			unsigned int sectorBaseAddress,
-			unsigned int eccBaseAddress,
-			unsigned int ExtraBytes,
-			unsigned int ErrorNbr)
-{
-	unsigned int *pErrPos;
-	unsigned int bytePos;
-	unsigned int bitPos;
-	unsigned int sectorSize = PMECC_SECTOR_SIZE;
-
-	pErrPos = (unsigned int *)(pPMERRLOC + PMERRLOC_EL0);
-
-	while (ErrorNbr) {
-		bytePos = (*pErrPos - 1) / 8;
-		bitPos = (*pErrPos - 1) % 8;
-		unsigned char *errByte;
-
-		if (bytePos < sectorSize) {
-			/* If error is located in the data area(not in ECC) */
-			errByte = (unsigned char *)(sectorBaseAddress + bytePos);
-			dbg_log(1, "Correct error bit @[#Byte %u,Bit# %u] " \
-				"%u -> %u\n\r",
-				(unsigned int)bytePos,
-				(unsigned int)bitPos,
-				*errByte,
-				*errByte ^ (1 << bitPos));
-			*errByte ^= (1 << bitPos);
-		} else {
-			/* error is located in oob area */
-			errByte = (unsigned char *)(eccBaseAddress
-					+ (bytePos - sectorSize));
-			dbg_log(1, "Correct error bit in OOB @[#Byte %u,Bit# %u]" \
-				" %u -> %u\n\r",
-				(unsigned int)bytePos - sectorSize,
-				(unsigned int)bitPos,
-				(*errByte),
-				*errByte ^ (1 << bitPos));
-			*errByte ^= (1 << bitPos);
-		}
-
-		pErrPos++;
-		ErrorNbr--;
-	}
+	/* init BCH */
+	ecc->bch.bchc = init_bch(m, SW_ECC_BCH_BITS, 0);
+	if(ecc->bch.bchc == NULL)
+		return -2;
+	ecc->bch.errloc = malloc(eccbytes);
+	ecc->bch.ecc = malloc(t * sizeof(ecc->bch.errloc[0]));
+	ecc->bch.eccmask = malloc(t * sizeof(ecc->bch.errloc[0]));
+	if((ecc->bch.errloc == NULL) || (ecc->bch.ecc == NULL) ||
+	   (ecc->bch.eccmask == NULL))
+		return -3;
+
+	/* calculate inverted ecc for an erased page */
+	erased_page = malloc(eccsize);
+	if(erased_page == NULL)
+		return -4;
+	memset(erased_page, 0xFF, eccsize);
+	memset(ecc->bch.eccmask, 0, eccbytes);
+	encode_bch(ecc->bch.bchc, erased_page, eccsize, ecc->bch.eccmask);
+	free(erased_page);
+	for(i=0; i<eccsize; i++)
+		ecc->bch.eccmask[i] ^= 0xFF;
+
+	bch_algo_needs_init = 0;
 	return 0;
 }
 
-/**
- * \brief Launch error detection functions and correct corrupted bits.
- * \param pPmeccDescriptor Pointer to a PMECC_paramDesc instance.
- * \param pmeccStatus Value of the PMECC status register.
- * \param pageBuffer Base address of the buffer
- * 	containing the page to be corrected.
- * \param ErrorNbr Number of error to correct
- * \return 0 if all errors have been corrected, 1 if too many errors detected
- */
-unsigned int PMECC_CorrectionAlgo(unsigned long pPMECC,
-		unsigned long pPMERRLOC,
-		struct _PMECC_paramDesc_struct *pPmeccDescriptor,
-		unsigned int pmeccStatus,
-		void *pageBuffer)
+static void bch_calc(const struct nand_info *ecc,
+                      const unsigned char *buf,
+                      unsigned char *code)
 {
-	unsigned int sectorNumber = 0;
-	unsigned int sectorBaseAddress, eccBaseAddr;
-	volatile int errorNbr;
-	unsigned int sector_num_per_page, page_size_byte, ecc_byte_per_sector;
-
-	/* Set the sector size (512 or 1024 bytes) */
-	pmecclor_writel((pPmeccDescriptor->sectorSize >> 4), PMERRLOC_ELCFG);
-
-	sector_num_per_page = pPmeccDescriptor->eccSizeByte / get_pmecc_bytes();
-	page_size_byte = sector_num_per_page * PMECC_SECTOR_SIZE;
-	ecc_byte_per_sector = get_pmecc_bytes();
-
-	while (sectorNumber < sector_num_per_page) {
-
-		errorNbr = 0;
-		if (pmeccStatus & 0x1) {
-
-			sectorBaseAddress = (unsigned int)pageBuffer
-					+ (sectorNumber * PMECC_SECTOR_SIZE);
-			eccBaseAddr = (unsigned int)pageBuffer
-					+ page_size_byte
-					+ pmecc_readl(PMECC_SADDR)
-					+ (sectorNumber * ecc_byte_per_sector);
-
-			GenSyn(pPMECC, pPmeccDescriptor, sectorNumber);
-
-			substitute(pPmeccDescriptor);
-
-			get_sigma(pPmeccDescriptor);
-			errorNbr = ErrorLocation(pPMERRLOC,
-					pPmeccDescriptor,
-					(((pPmeccDescriptor->sectorSize >> 4) + 1) * 512 * 8)
-					+ (pPmeccDescriptor->tt
-						* (13 + (pPmeccDescriptor->sectorSize >> 4))));
-
-			if (errorNbr == -1)
-				return 1;	/* uncorrectable errors */
-			else
-				ErrorCorrection(pPMERRLOC,
-						pPmeccDescriptor,
-						sectorBaseAddress,
-						eccBaseAddr,
-						ecc_byte_per_sector,
-						errorNbr);
-		}
-		sectorNumber++;
-		pmeccStatus = pmeccStatus >> 1;
-	}
+	unsigned int eccsize, eccbytes, i;
 
-	return 0;
-}
+	eccsize = SW_ECC_BCH_BLOCKSIZE;
+	eccbytes = ecc->bch.eccbytes;
+	memset(code, 0, eccbytes);
+	encode_bch(ecc->bch.bchc, buf, eccsize, code);
 
-void buf_dump(unsigned char *buf, int offset, int len)
-{
-	int i = 0;
-	for (i = 0; i < len; i++) {
-		if (i % 16 == 0)
-			dbg_log(DEBUG_LOUD, "\r\n");
-		dbg_log(DEBUG_LOUD, "%u ", buf[offset + i]);
-	}
-}
-
-void page_dump(unsigned char *buf, int page_size, int oob_size)
-{
-	dbg_log(DEBUG_LOUD, "Dump Error Page: Data:\r\n");
-	buf_dump(buf, 0, page_size);
-	dbg_log(DEBUG_LOUD, "\r\nOOB:\r\n");
-	buf_dump(buf, page_size, oob_size);
-	dbg_log(DEBUG_LOUD, "\r\n");
+	/* apply mask so that an erased page is a valid codeword */
+	/* taken from linux kernel 3.7 */
+	for(i=0; i<eccbytes; i++)
+		code[i] ^= ecc->bch.eccmask[i];
 }
 
-static int pmecc_process(struct nand_info *nand, unsigned char *buffer)
+static int bch_correct(const struct nand_info *ecc,
+                        unsigned char *buf,
+                        unsigned char *read_ecc,
+                        unsigned char *calc_ecc)
 {
-	int ret = 0;
-	int result;
-	unsigned int erris;
-
-	/* waiting for PMECC ready */
-	while (pmecc_readl(PMECC_SR) & AT91C_PMECC_BUSY);
-
-	/* read corrupted bit status */
-	erris = pmecc_readl(PMECC_ISR);
-	if (erris) {
-		if (check_pmecc_ecc_data(nand, buffer) == -1){
-			return 0;
-		}
-
-		/* erris means which sector has errors. for example:
-		 * if erris is 0x9 (0b1001)
-		 *                    ^  ^
-		 * the bit 1 indicate the position of error sectors.
-		 * If we have 4 sectors, then that means the first
-		 * and last sector has errors.
-		 */
-		dbg_log(1, "PMECC: sector bits = %d, bit 1 means " \
-			"corrupted sector, Now correcting...\n\r", erris);
-		result = PMECC_CorrectionAlgo(AT91C_BASE_PMECC,
-					AT91C_BASE_PMERRLOC,
-					&PMECC_paramDesc,
-					erris,
-					buffer);
-
-		if (result != 0) {
-			dbg_log(1, "PMECC: failed to " \
-					"correct corrupted bits!\n\r");
-			ret =  ECC_CORRECT_ERROR;
-
-			/* dump the whole page for test */
-			page_dump(buffer, nand->pagesize, nand->oobsize);
+	unsigned int eccsize, eccbytes, i;
+	int count;
+
+	eccsize = SW_ECC_BCH_BLOCKSIZE;
+	eccbytes = ecc->bch.eccbytes;
+
+	count = decode_bch(ecc->bch.bchc, NULL, eccsize, read_ecc, calc_ecc,
+	                   NULL, ecc->bch.errloc);
+	if (count > 0) {
+		for (i = 0; i < count; i++) {
+			if (ecc->bch.errloc[i] < (eccsize*8))
+				/* error is located in data, correct it */
+				buf[ecc->bch.errloc[i] >> 3] ^= (1 << (ecc->bch.errloc[i] & 7));
+			/* else error in ecc, no action needed */
 		}
+	} else if (count < 0) {
+		count = -1;
 	}
 
-	return ret;
+	return count;
 }
-#endif /* #ifdef CONFIG_USE_PMECC */
+#endif /* #ifdef CONFIG_ENABLE_SW_ECC_BCH */
 
 #ifdef NANDFLASH_SMALL_BLOCKS
 static int nand_read_sector(struct nand_info *nand, 
-			unsigned int row_address,
+			unsigned int sectoraddr,
 			unsigned char *buffer,
 			unsigned int zone_flag)
 {
@@ -1248,28 +751,27 @@ static int nand_read_sector(struct nand_info *nand,
 	nand_cs_enable();
 
 	/* Write specific command, Read from start */
-	if (nand->buswidth)
+	if (nand->buswidth) /* 16 bits */
 		nand_command16(command);
 	else
 		nand_command(command);
 
+	sectoraddr >>= nand->page_shift;
+
 	if (nand->buswidth) {
 		nand_address16(0x00);
-		nand_address16((row_address >> 0) & 0xff);
-		nand_address16((row_address >> 8) & 0xff);
-		nand_address16((row_address >> 16) & 0xff);
+		nand_address16((sectoraddr >> 0) & 0xFF);
+		nand_address16((sectoraddr >> 8) & 0xFF);
+		nand_address16((sectoraddr >> 16) & 0xFF);
 	} else {
 		nand_address(0x00);
-		nand_address((row_address >> 0) & 0xff);
-		nand_address((row_address >> 8) & 0xff);
-		nand_address((row_address >> 16) & 0xff);
+		nand_address((sectoraddr >> 0) & 0xFF);
+		nand_address((sectoraddr >> 8) & 0xFF);
+		nand_address((sectoraddr >> 16) & 0xFF);
 	}
 
 	nand_wait_ready();
-	if (nand->buswidth)
-		nand_command16(CMD_READ_A0);
-	else
-		nand_command(CMD_READ_A0);
+	nand_command(CMD_READ_C);
 
 	/* Read loop */
 	if (nand->buswidth) {
@@ -1289,14 +791,15 @@ static int nand_read_sector(struct nand_info *nand,
 				buffer++;
 			}
 
-			nand_command(CMD_READ_A1);
+			command = CMD_READ_A1;
+			nand_command(command);
 			nand_address(0x00);
-			nand_address((row_address >> 0) & 0xff);
-			nand_address((row_address >> 8) & 0xff);
-			nand_address((row_address >> 16) & 0xff);
+			nand_address((sectoraddr >> 0) & 0xFF);
+			nand_address((sectoraddr >> 8) & 0xFF);
+			nand_address((sectoraddr >> 16) & 0xFF);
 
 			nand_wait_ready();
-			nand_command(CMD_READ_A0);
+			nand_command(CMD_READ_C);
 
 			for (i = 0; i < (readbytes / 2); i++) {
 				*buffer = read_byte();
@@ -1312,44 +815,48 @@ static int nand_read_sector(struct nand_info *nand,
 
 #else /* large blocks */
 static int nand_read_sector(struct nand_info *nand,
-				unsigned int row_address,
+				unsigned int sectoraddr,
 				unsigned char *buffer, 
 				unsigned int zone_flag)
 {
 	unsigned int readbytes, i;
-	unsigned int column_address;
+	unsigned int address;
 	int ret = 0;
-	unsigned char *pbuf = buffer;
 
 #ifdef CONFIG_USE_PMECC
+	int result;
+	unsigned int erris;
+	unsigned char *pbuf = buffer;
 	unsigned int usepmecc = 0;
 
-	if ((zone_flag & ZONE_DATA) == ZONE_DATA) {
+	pmecc_writel(AT91C_PMECC_RST, PMECC_CTRL);
+	pmecc_writel(AT91C_PMECC_DISABLE, PMECC_CTRL);
+
+	if (zone_flag == ZONE_DATA) {
 		usepmecc = 1;
 		zone_flag = ZONE_DATA | ZONE_INFO;
 
-		pmecc_writel(AT91C_PMECC_RST, PMECC_CTRL);
-		pmecc_writel((pmecc_readl(PMECC_CFG) | AT91C_PMECC_AUTO_ENA),
-				PMECC_CFG);
 		pmecc_writel(AT91C_PMECC_ENABLE, PMECC_CTRL);
+		pmecc_writel(AT91C_PMECC_DATA, PMECC_CTRL);
 	}
 #endif	/* #ifdef CONFIG_USE_PMECC */
 
+	address = 0x00;
 	switch (zone_flag) {
 	case ZONE_DATA:
 		readbytes = nand->pagesize;
-		column_address = 0x00;
 		break;
 
 	case ZONE_INFO:
 		readbytes = nand->oobsize;
-		pbuf += nand->pagesize;
-		column_address = nand->pagesize;
+		buffer += nand->pagesize;
+		address = nand->pagesize;
+		if (nand->buswidth)
+			address = address / 2;	/* Div 2 is because we address in word and not in byte */
 		break;
 
 	case ZONE_DATA | ZONE_INFO:
 		readbytes = nand->sectorsize;
-		column_address = 0x00;
 		break;
 
 	default:
@@ -1358,45 +865,48 @@ static int nand_read_sector(struct nand_info *nand,
 
 	nand_cs_enable();
 
-	if (nand->buswidth)
-		nand_command16(CMD_READ_1);
-	else
-		nand_command(CMD_READ_1);
+	nand_command(CMD_READ_1);
 
-	write_column_address(nand, column_address);
-	write_row_address(nand, row_address);
+	send_large_block_address(address);
+	sectoraddr >>= nand->page_shift;
+	send_sector_address(sectoraddr);
 
-	if (nand->buswidth)
-		nand_command16(CMD_READ_2);
-	else
-		nand_command(CMD_READ_2);
+	nand_command(CMD_READ_2);
 
 	nand_wait_ready();
-	if (nand->buswidth)
-		nand_command16(CMD_READ_1);
-	else
-		nand_command(CMD_READ_1);
+	nand_command(CMD_READ_1);
 
-#ifdef CONFIG_USE_PMECC
-	if (usepmecc == 1) {
-		pmecc_writel(AT91C_PMECC_RST, PMECC_CTRL);
-		pmecc_writel(AT91C_PMECC_ENABLE | AT91C_PMECC_DATA, PMECC_CTRL);
-	}
-#endif
 	/* Read loop */
 	if (nand->buswidth) {
 		for (i = 0; i < readbytes / 2; i++) {
-			*((short *)pbuf) = read_word();
-			pbuf += 2;
+			*((short *)buffer) = read_word();
+			buffer += 2;
 		}
 	} else {
 		for (i = 0; i < readbytes; i++)
-			*pbuf++ = read_byte();
+			*buffer++ = read_byte();
 
 #ifdef CONFIG_USE_PMECC
-		if (usepmecc == 1)
-			ret = pmecc_process(nand, buffer);
-#endif
+		if (usepmecc == 1) {
+			while (pmecc_readl(PMECC_SR) & AT91C_PMECC_BUSY)
+				udelay(1);
+
+			erris = pmecc_readl(PMECC_ISR);
+			if (erris) {
+				dbg_log(1, "PMECC: sector bits %d corrupted, Now correcting...\n\r", erris);
+				result = (*pmecc_correction_algo)(AT91C_BASE_PMECC,
+							AT91C_BASE_PMERRLOC,
+							&PMECC_paramDesc,
+							erris,
+							pbuf);
+
+				if (result != 0) {
+					dbg_log(1, "PMECC failed to correct!\n\r");
+					ret =  ECC_CORRECT_ERROR;
+				}
+			}
+		}
+#endif /* #ifdef CONFIG_USE_PMECC */
 	}
 
 	nand_cs_disable();
@@ -1409,17 +919,13 @@ static int nand_check_badblock(struct nand_info *nand,
 				unsigned int block,
 				unsigned char *buffer)
 {
-	unsigned int page;
-	unsigned int row_address = block * nand->pages_block;
+	unsigned int i = 0;
+	unsigned int sectoraddr = block * nand->blocksize;
 
-	/*
-	 * Read the first page and second page oob zone
-	 * to detect if block is bad
-	 */
-	for (page = 0; page < 2; page++) {
-		nand_read_sector(nand, row_address + page, buffer, ZONE_INFO);
-		if (*(buffer + nand->pagesize + nand->ecclayout->badblockpos)
-			!= 0xff)
+	/* Read the first page and second page oob zone to detect if block is bad */
+	for (i = 0; i < 2; i++) {
+		nand_read_sector(nand, sectoraddr + i * nand->pagesize, buffer, ZONE_INFO);
+		if (*(buffer + nand->pagesize + nand->badblockpos) != 0xFF)
 			return -1;
 	}
 
@@ -1444,182 +950,191 @@ static int nand_read_page(struct nand_info *nand,
 				unsigned int zone_flag,
 				unsigned char *buffer)
 {
-	unsigned int row_address = block * nand->pages_block + page;
+	unsigned int sectoraddr = block * nand->blocksize + page * nand->pagesize;
+
+	if (nand_check_badblock(nand, block, buffer)) {
+		dbg_log(1, "Bad block: #%d\n\r", block);
+		return -1;
+	}
 
 #ifndef CONFIG_ENABLE_SW_ECC
-	return nand_read_sector(nand, row_address, buffer, ZONE_DATA);
+	return nand_read_sector(nand, sectoraddr, buffer, ZONE_DATA);
 #else
 
 	int retval;
-	unsigned char hamming[48], error;
+	unsigned char hamming[MAX_ECC_BYTES], error;
+
+	retval = nand_read_sector(nand, sectoraddr, buffer,ZONE_DATA | ZONE_INFO);
 
-	retval = nand_read_sector(nand, row_address, buffer,
-				ZONE_DATA | ZONE_INFO);
 	if (retval)
 		return -1;
 
 	nand_read_ecc(nand->ecclayout, buffer + nand->pagesize, hamming);
 
+#ifndef CONFIG_ENABLE_SW_ECC_BCH
 	error = Hamming_Verify256x(buffer, nand->pagesize, hamming);
 	if (error && (error != Hamming_ERROR_SINGLEBIT)) {
-		dbg_log(1, "NAND: Hamming ECC error!\n\r");
+		dbg_log(1, "Hamming ECC error!\n\r");
 		return ECC_CORRECT_ERROR;
 	}
+#else
+	unsigned char calc_ecc[MAX_ECC_BYTES];
+	unsigned int step;
+
+	error = 0;
+	for(step=0; (step<nand->bch.eccsteps) && (error == 0); step++)
+	{
+		unsigned char *d;
+		unsigned char *e;
+		unsigned char *h;
+
+		d = &buffer[step * SW_ECC_BCH_BLOCKSIZE];
+		e = &calc_ecc[step * nand->bch.eccbytes];
+		h = &hamming[step * nand->bch.eccbytes];
+		bch_calc(nand, d, e);
+		/* hamming is the BCH code read from spare buffer */
+		if(bch_correct(nand, d, h, e) < 0)
+		{
+			dbg_log(1, "BCH ECC error!\n\r");
+			return ECC_CORRECT_ERROR;
+		}
+	}
+#endif /* #ifndef CONFIG_ENABLE_SW_ECC_BCH */
 
 	return 0;
 #endif /* #ifndef CONFIG_ENABLE_SW_ECC */
 }
 
 #ifdef CONFIG_NANDFLASH_RECOVERY
-static int nand_erase_block0(struct nand_info *nand)
+static int nand_erase_block0(void)
 {
-	unsigned int row_address = 0;
+	unsigned int block = 0;
 	unsigned int timeout = 10000;
 	unsigned int status;
+	int ret;
 
 	nand_cs_enable();
 
 	nand_command(CMD_ERASE_1);
-	write_row_address(nand, row_address);
+	send_sector_address(block);
 	nand_command(CMD_ERASE_2);
 
-	udelay(2000);
-
 	nand_command(CMD_STATUS);
-	while ((!((status = read_byte()) & STATUS_READY)) && --timeout)
-		;
-
-	nand_cs_disable();
-
-	if (status & STATUS_ERROR)
-		return -1;
+	do {
+		status = read_byte();
+		if (status & STATUS_ERROR){
+			ret = -1;
+			goto err;
+		}
+		if (status & STATUS_READY) {
+			ret = 0;
+			break;
+		}
+	} while (timeout--);
 
 	if (timeout == 0)
-		return -2;
+		ret = -2;
 
-	return 0;
+	nand_cs_disable();
+	return ret;
+
+err:
+	nand_cs_disable();
+	return ret;
 }
 
-static int nandflash_recovery(struct nand_info *nand)
+static int nandflash_recovery(void)
 {
-	int ret = -1;
-
 	/*
 	 * If Recovery Button is pressed during boot sequence,
 	 * erase nandflash block0
 	*/
-	dbg_log(1, "NAND: Press the recovery button (%s) to recovery\n\r",
-			RECOVERY_BUTTON_NAME);
-
 	if ((pio_get_value(CONFIG_SYS_RECOVERY_BUTTON_PIN)) == 0) {
-		dbg_log(1, "NAND: The recovery button (%s) has been "\
-				"pressed\n\r", RECOVERY_BUTTON_NAME);
-		dbg_log(1, "NAND: The block 0 is erasing ...\n\r");
+		dbg_log(1, "Nand: The recovery button (%s) has been pressed\n\r", RECOVERY_BUTTON_NAME);
+		dbg_log(1, "Nand: The block 0 is erasing ...\n\r");
 
-		ret = nand_erase_block0(nand);
-		if (ret)
-			dbg_log(1, "NAND: The erasing failed\n\r");
-		else
-			dbg_log(1, "NAND: The erasing is done\n\r");
-	}
+		nand_erase_block0();
 
-	return ret;
-}
-#endif /* #ifdef CONFIG_NANDFLASH_RECOVERY */
-
-static int nand_loadimage(struct nand_info *nand,
-				unsigned int offset,
-				unsigned int length,
-				unsigned char *dest)
-{
-	unsigned char *buffer = dest;
-	unsigned int readsize;
-	unsigned int block;
-	unsigned int page, start_page, end_page;
-	unsigned int numpages;
-	int ret;
-
-	block = offset / nand->blocksize;
-	start_page = (offset % nand->blocksize) / nand->pagesize;
-	while (length > 0) {
-		/* read a buffer corresponding to a block */
-		if (length < nand->blocksize)
-			readsize = length;
-		else
-			readsize = nand->blocksize;
-
-		/* adjust the number of pages to read */
-		numpages = readsize / nand->pagesize;
-		if (readsize % nand->pagesize)
-			numpages++;
-
-		end_page = start_page + numpages;
-
-		/* check the bad block */
-		while (1) {
-			if (nand_check_badblock(nand,
-					block, buffer) != 0) {
-				block++; /* skip this block */
-				dbg_log(1, "NAND: Bad block:" \
-					" #%d\n\r", block);
-			} else
-				break;
-		}
-
-		/* read pages of a block */
-		for (page = start_page; page < end_page; page++) {
-			ret = nand_read_page(nand, block, page,
-						ZONE_DATA, buffer);
-			if (ret == ECC_CORRECT_ERROR)
-				return -1;
-			else
-				buffer += nand->pagesize;
-		}
-		length -= readsize;
-
-		block++;
-		start_page = 0;
+		dbg_log(1, "Nand: The erasing is done\n\r");
+		return 0;
 	}
-
-	return 0;
+	return 1;
 }
+#endif /* #ifdef CONFIG_NANDFLASH_RECOVERY */
 
-int load_nandflash(struct image_info *image)
+int load_nandflash(struct image_info *img_info)
 {
 	struct nand_info nand;
-	int ret;
+	unsigned int offset = img_info->offset;
+	unsigned int size = img_info->length;
+	unsigned char *buffer = img_info->dest;
 
+	unsigned int block, length, readsize, numpage, page;
+	int ret;
+	
 	nandflash_hw_init();
 
-	if (nandflash_get_type(&nand))
-		return -1;
-
 #ifdef CONFIG_NANDFLASH_RECOVERY
-	if (nandflash_recovery(&nand) == 0)
+	if (nandflash_recovery() == 0)
 		return -2;
 #endif
 
+	if (nandflash_get_type(&nand))
+		return -1;
+
 #ifdef CONFIG_USE_PMECC
-	if (init_pmecc(&nand))
+	if (init_pmecc(nand.pagesize))
 		return -1;
 #endif
 
-	dbg_log(1, "NAND: Image: Copy %d bytes from %d to %d\r\n",
-			image->length, image->offset, image->dest);
+#ifdef CONFIG_ENABLE_SW_ECC_BCH
+	if(bch_algo_init(&nand) != 0)
+		return -1;
+#endif /* #ifdef CONFIG_ENABLE_SW_ECC_BCH */
+
+	dbg_log(1, "Nand: Copy %d bytes from %d to %d\r\n", size, offset, buffer);
+
+	/* fixup size for unaligned images */
+	if(offset % nand.blocksize)
+		size += nand.blocksize - (offset % nand.blocksize);
 
-	ret = nand_loadimage(&nand, image->offset, image->length, image->dest);
-	if (ret)
-		return ret;
+	block = offset / nand.blocksize;
+	length = size;
+	while (length > 0) {
+		/* read a buffer corresponding to a block in the origin file */
+		if (length < nand.blocksize) 
+			readsize = length;
+		else
+			readsize = nand.blocksize;
+
+		/* Adjust the number of sectors to read */
+		numpage = readsize / nand.pagesize;
+		if (readsize % nand.pagesize)
+			numpage++;
+
+		/* Loop until a valid block has been read */
+		while (1) {
+			for (page = 0; page < numpage; page++) {
+				ret = nand_read_page(&nand, block, page, ZONE_DATA, buffer);
+				if (ret == ECC_CORRECT_ERROR)
+					return -1;
+				else if (ret == -1) /* skip this block */
+					break;
+				else
+					buffer += nand.pagesize;
+			}
+			block++;
 
-	if (image->of) {
-		dbg_log(1, "NAND: dt blob: Copy %d bytes from %d to %d\r\n",
-			image->of_length, image->of_offset, image->of_dest);
+			if (page >= numpage)
+				break;
+		}
+		length -= readsize;
+	}
 
-		ret = nand_loadimage(&nand, image->of_offset,
-					image->of_length, image->of_dest);
-		if (ret)
-			return ret;
+	/* fixup position for unaligned images */
+	if(img_info->offset % nand.blocksize) {
+		memcpy(img_info->dest, img_info->dest + (img_info->offset % nand.blocksize), img_info->length);
 	}
 
 	return 0;
- }
+}
diff --git a/driver/nandflash_9260.c b/driver/nandflash_9260.c
old mode 100644
new mode 100755
index a2c732c..3173387
--- a/driver/nandflash_9260.c
+++ b/driver/nandflash_9260.c
@@ -33,68 +33,74 @@
 #include "debug.h"
 #include "nand.h"
 #include "hamming.h"
-#include "timer.h"
 
 #define ECC_CORRECT_ERROR  0xfe
 
+/* ooblayout for 2048 byte pages */
+static struct nand_ooblayout ooblayout_2048 = {
+	/* Bad block marker is at position */
+	0,
+	/* 24 ecc bytes */
+	24,
+	/* ecc byte positions */
+	{40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
+	52, 53, 54, 55, 56, 57,
+	 58, 59, 60, 61, 62, 63},
+	/* 38 extra bytes */
+	38,
+	/* extra byte positions */
+	{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
+	 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
+	 34, 35, 36, 37, 38, 39}
+};
+
 static struct nand_chip nand_ids[] = {
-	{0xecda, 0x800, 0x20000, 0x800, 0x40, 0x0},	/* Samsung K9F2G08U0M 256MB */
-	{0xecaa, 0x800, 0x20000, 0x800, 0x40, 0x0},	/* Samsung K9F2G08U0A 256MB */
-	{0x2cca, 0x800, 0x20000, 0x800, 0x40, 0x1},	/* Micron MT29F2G16AAB 256MB */
-	{0x2cda, 0x800, 0x20000, 0x800, 0x40, 0x0},	/* Micron MT29F2G08AAC 256MB  */
-	{0x2caa, 0x800, 0x20000, 0x800, 0x40, 0x0},	/* Micron MT29F2G08ABD 256MB */
-	{0x2c38, 0x800, 0x80000, 0x1000, 0xe0, 0x0},	/* Mircon MT29H8G08ACAH1 1GB */
+	{0xecda, 0x800, 0x20000, 0x800, 0x40, 0x0, &ooblayout_2048},
+	{0x2cca, 0x800, 0x20000, 0x800, 0x40, 0x1, &ooblayout_2048},
+	{0x2cda, 0x800, 0x20000, 0x800, 0x40, 0x0, &ooblayout_2048},
 	{0,}
 };
 
-static struct nand_ooblayout nand_oob_layout;
-
 /*
  * NAND Commands
  */
+static unsigned char *IO_ADDR_R =
+		(unsigned char *)(unsigned long)CONFIG_SYS_NAND_BASE;
+static unsigned char *IO_ADDR_W =
+		(unsigned char *)(unsigned long)CONFIG_SYS_NAND_BASE;
 
 /* 8 bits devices */
 static void nand_command(unsigned char cmd)
 {
-	volatile unsigned long ioaddr = (unsigned long)CONFIG_SYS_NAND_BASE
-						| CONFIG_SYS_NAND_MASK_CLE;
-
-	writeb(cmd, ioaddr);
+	writeb(cmd, ((unsigned long)IO_ADDR_W | CONFIG_SYS_NAND_MASK_CLE));
 }
 
 static void nand_address(unsigned char addr)
 {
-	volatile unsigned long ioaddr = (unsigned long)CONFIG_SYS_NAND_BASE
-						| CONFIG_SYS_NAND_MASK_ALE;
-
-	writeb(addr, ioaddr);
+	writeb(addr, ((unsigned long)IO_ADDR_W | CONFIG_SYS_NAND_MASK_ALE));
 }
 
 static unsigned char read_byte(void)
 {
-	return readb((unsigned long)CONFIG_SYS_NAND_BASE);
+	return readb((unsigned long)IO_ADDR_R);
 }
 
+#if 0
 /* 16 bits devices */
 static void nand_command16(unsigned short cmd)
 {
-	volatile unsigned long ioaddr = (unsigned long)CONFIG_SYS_NAND_BASE
-						| CONFIG_SYS_NAND_MASK_CLE;
-
-	writew(cmd, ioaddr);
+	writew(cmd, (unsigned long)IO_ADDR_W | CONFIG_SYS_NAND_MASK_CLE);
 }
 
 static void nand_address16(unsigned short addr)
 {
-	volatile unsigned long ioaddr = (unsigned long)CONFIG_SYS_NAND_BASE
-						| CONFIG_SYS_NAND_MASK_ALE;
-
-	writew(addr, ioaddr);
+	writew(addr, (unsigned long)IO_ADDR_W | CONFIG_SYS_NAND_MASK_ALE);
 }
+#endif
 
 static unsigned short read_word(void)
 {
-	return readw((unsigned long)CONFIG_SYS_NAND_BASE);
+	return readw((unsigned long)IO_ADDR_R);
 }
 
 static void nand_wait_ready(void)
@@ -115,68 +121,34 @@ static void nand_cs_disable(void)
 	pio_set_value(CONFIG_SYS_NAND_ENABLE_PIN, 1);
 }
 
-static void config_nand_ooblayout(struct nand_ooblayout *layout, struct nand_chip *chip)
-{
-	unsigned int i;
-
-	switch (chip->pagesize) {
-	case 256:
-		layout->badblockpos = 5;
-		layout->eccbytes = 3;
-		layout->oobavail_offset = 6;
-		break;
-
-	case 512:
-		layout->badblockpos = 5;
-		layout->eccbytes = 6;
-		layout->oobavail_offset = 6;
-		break;
-
-	case 2048:
-		layout->badblockpos = 0;
-		layout->eccbytes = 24;
-		layout->oobavail_offset = 1;
-		break;
-
-	case 4096:
-		layout->badblockpos = 0;
-		layout->eccbytes = 48;
-		layout->oobavail_offset = 1;
-		break;
-
-	default:
-		break;
-	}
-
-	for (i = 0; i < layout->eccbytes; i++)
-		layout->eccpos[i] = chip->oobsize - layout->eccbytes + i;
-
-	layout->oobavailbytes = chip->oobsize - layout->eccbytes - layout->oobavail_offset;
-}
-
 static void nand_info_init(struct nand_info *nand, struct nand_chip *chip)
 {
+	unsigned int pagesize, i = 0;
+
 	/* number of blocks in device */
 	nand->numblocks = chip->numblocks;
 	/* number of data bytes in a block */
 	nand->blocksize = chip->blocksize;
 	/* number of bytes in page area */
 	nand->pagesize = chip->pagesize;
-	/* number of pages in block */
-	nand->pages_block = nand->blocksize / nand->pagesize;
-	/* number of pages in device */
-	nand->pages_device = nand->numblocks * nand->pages_block;
 	/* number of bytes in oob area */
 	nand->oobsize = chip->oobsize;
 	/* Total number of bytes in a sector */
 	nand->sectorsize = nand->pagesize + nand->oobsize;
-	/* the layout of the spare area */
-	config_nand_ooblayout(&nand_oob_layout, chip);
-	nand->ecclayout = &nand_oob_layout;
-	/* data bus width (8/16 bits) */
-	nand->buswidth = chip->buswidth;
+	nand->ecclayout = chip->ecclayout;
+	nand->buswidth = chip->buswidth;	/* Data Bus Width */
+
+	pagesize = nand->pagesize - 1;
+	nand->page_shift = 0;
+	while (pagesize >> i) {
+		nand->page_shift++;
+		i++;
+	}
+
 	if (nand->buswidth)
-		nand->ecclayout->badblockpos *= 2;
+		nand->badblockpos = 2 * nand->ecclayout->badblockpos;
+	else
+		nand->badblockpos = nand->ecclayout->badblockpos;
 }
 
 static void nandflash_reset(void)
@@ -240,43 +212,21 @@ static int nandflash_get_type(struct nand_info *nand)
 	return 0;
 }
 
-static void write_column_address(struct nand_info *nand,
-					unsigned int column_address)
+static void send_large_block_address(unsigned int addr)
 {
-	volatile unsigned int page_size = nand->pagesize;
-
-	if (nand->buswidth)
-		column_address >>= 1;
-
-	while (page_size > 2) {
-		if (nand->buswidth)
-			nand_address16(column_address & 0xff);
-		else
-			nand_address(column_address & 0xff);
-
-		page_size >>= 8;
-		column_address >>= 8;
-	}
+	nand_address((addr >> 0) & 0xFF);
+	nand_address((addr >> 8) & 0xFF);
 }
 
-static void write_row_address(struct nand_info *nand, unsigned int row_address)
+static void send_sector_address(unsigned int addr)
 {
-	volatile unsigned int num_pages = nand->pages_device;
-
-	while(num_pages) {
-		if (nand->buswidth)
-			nand_address16(row_address & 0xff);
-		else
-			nand_address(row_address & 0xff);
-
-		num_pages >>= 8;
-		row_address >>= 8;
-	}
+	send_large_block_address(addr);
+	nand_address((addr >> 16) & 0xFF);
 }
 
 #ifdef NANDFLASH_SMALL_BLOCKS
 static int nand_read_sector(struct nand_info *nand,
-			unsigned int row_address,
+			unsigned int sectoraddr,
 			unsigned char *buffer,
 			unsigned int zone_flag)
 {
@@ -312,20 +262,22 @@ static int nand_read_sector(struct nand_info *nand,
 	else
 		nand_command(command);
 
+	sectoraddr >>= nand->page_shift;
+
 	if (nand->buswidth) {
 		nand_address16(0x00);
-		nand_address16((row_address >> 0) & 0xff);
-		nand_address16((row_address >> 8) & 0xff);
-		nand_address16((row_address >> 16) & 0xff);
+		nand_address16((sectoraddr >> 0) & 0xFF);
+		nand_address16((sectoraddr >> 8) & 0xFF);
+		nand_address16((sectoraddr >> 16) & 0xFF);
 	} else {
 		nand_address(0x00);
-		nand_address((row_address >> 0) & 0xff);
-		nand_address((row_address >> 8) & 0xff);
-		nand_address((row_address >> 16) & 0xff);
+		nand_address((sectoraddr >> 0) & 0xFF);
+		nand_address((sectoraddr >> 8) & 0xFF);
+		nand_address((sectoraddr >> 16) & 0xFF);
 	}
 
 	nand_wait_ready();
-	nand_command(CMD_READ_A0);
+	nand_command(CMD_READ_C);
 
 	if (nand->buswidth) {
 		for (i = 0; i < readbytes / 2; i++) {
@@ -346,12 +298,12 @@ static int nand_read_sector(struct nand_info *nand,
 
 			nand_command(CMD_READ_A1);
 			nand_address(0x00);
-			nand_address((row_address >> 0) & 0xff);
-			nand_address((row_address >> 8) & 0xff);
-			nand_address((row_address >> 16) & 0xff);
+			nand_address((sectoraddr >> 0) & 0xFF);
+			nand_address((sectoraddr >> 8) & 0xFF);
+			nand_address((sectoraddr >> 16) & 0xFF);
 
 			nand_wait_ready();
-			nand_command(CMD_READ_A0);
+			nand_command(CMD_READ_C);
 
 			for (i = 0; i < (readbytes / 2); i++) {
 				*buffer = read_byte();
@@ -367,15 +319,15 @@ static int nand_read_sector(struct nand_info *nand,
 
 #else /* large blocks */
 static int nand_read_sector(struct nand_info *nand,
-			unsigned int row_address,
+			unsigned int sectoraddr,
 			unsigned char *buffer,
 			unsigned int zone_flag)
 {
 	unsigned int readbytes, i;
-	unsigned int column_address;
+	unsigned int address;
 	int ret = 0;
 
-	column_address = 0x00;
+	address = 0x00;
 	switch (zone_flag) {
 	case ZONE_DATA:
 		readbytes = nand->pagesize;
@@ -384,7 +336,9 @@ static int nand_read_sector(struct nand_info *nand,
 	case ZONE_INFO:
 		readbytes = nand->oobsize;
 		buffer += nand->pagesize;
-		column_address = nand->pagesize;
+		address = nand->pagesize;
+		if (nand->buswidth)
+			address = address / 2;
 		break;
 
 	case ZONE_DATA | ZONE_INFO:
@@ -397,24 +351,16 @@ static int nand_read_sector(struct nand_info *nand,
 
 	nand_cs_enable();
 
-	if (nand->buswidth)
-		nand_command16(CMD_READ_1);
-	else
-		nand_command(CMD_READ_1);
+	nand_command(CMD_READ_1);
 
-	write_column_address(nand, column_address);
-	write_row_address(nand, row_address);
+	send_large_block_address(address);
+	sectoraddr >>= nand->page_shift;
+	send_sector_address(sectoraddr);
 
-	if (nand->buswidth)
-		nand_command16(CMD_READ_2);
-	else
-		nand_command(CMD_READ_2);
+	nand_command(CMD_READ_2);
 
 	nand_wait_ready();
-	if (nand->buswidth)
-		nand_command16(CMD_READ_1);
-	else
-		nand_command(CMD_READ_1);
+	nand_command(CMD_READ_1);
 
 	/* Read loop */
 	if (nand->buswidth)
@@ -436,13 +382,14 @@ static int nand_check_badblock(struct nand_info *nand,
 				unsigned int block,
 				unsigned char *buffer)
 {
-	unsigned int page;
-	unsigned int row_address = block * nand->pages_block;
-
-	/* Read the first page and second page oob zone to detect if block is bad */
-	for (page = 0; page < 2; page++) {
-		nand_read_sector(nand, row_address + page, buffer, ZONE_INFO);
-		if (*(buffer + nand->pagesize + nand->ecclayout->badblockpos) != 0xff)
+	unsigned int i = 0;
+	unsigned int sectoraddr = block * nand->blocksize;
+
+	/* Read the first page and second page oob zone to detect bad block */
+	for (i = 0; i < 2; i++) {
+		nand_read_sector(nand, sectoraddr + i * nand->pagesize,
+		buffer, ZONE_INFO);
+		if (*(buffer + nand->pagesize + nand->badblockpos) != 0xFF)
 			return -1;
 	}
 
@@ -468,9 +415,15 @@ static int nand_read_page(struct nand_info *nand,
 	int retval;
 	unsigned char hamming[48];
 	unsigned char error;
-	unsigned int row_address = block * nand->pages_block + page;
+	unsigned int sectoraddr = block * nand->blocksize + page * nand->pagesize;
+
+	if (nand_check_badblock(nand, block, buffer)) {
+		dbg_log(1, "Bad block: #%d\n\r", block);
+		return -1;
+	}
+
+	retval = nand_read_sector(nand, sectoraddr, buffer, ZONE_DATA | ZONE_INFO);
 
-	retval = nand_read_sector(nand, row_address, buffer, ZONE_DATA | ZONE_INFO);
 	if (retval)
 		return -1;
 
@@ -486,42 +439,44 @@ static int nand_read_page(struct nand_info *nand,
 }
 
 #ifdef CONFIG_NANDFLASH_RECOVERY
-static int nand_erase_block0(struct nand_info *nand)
+static int nand_erase_block0(void)
 {
-	unsigned int row_address = 0;
+	unsigned int block = 0;
 
 	nand_cs_enable();
 
 	nand_command(CMD_ERASE_1);
-	write_row_address(nand, row_address);
+	send_sector_address(block);
 	nand_command(CMD_ERASE_2);
 
-	udelay(2000);
-
 	nand_wait_ready();
 
+	nand_command(CMD_STATUS);
+	if (read_byte() & STATUS_ERROR)
+		return -1;
+
 	nand_cs_disable();
 
 	return 0;
 }
 
-static int nandflash_recovery(struct nand_info *nand)
+static int nandflash_recovery(void)
 {
-	int ret = -1;
-
 	/*
 	 * If Recovery Button is pressed during boot sequence,
 	 * erase nandflash block0
 	*/
 	if ((pio_get_value(CONFIG_SYS_RECOVERY_BUTTON_PIN)) == 0) {
 		dbg_log(1, "Nand: The recovery button (%s) is pressed\n\r",
-				RECOVERY_BUTTON_NAME);
+		RECOVERY_BUTTON_NAME);
 		dbg_log(1, "Nand: The block 0 is erasing ...\n\r");
 
-		ret = nand_erase_block0(nand);
-	}
+		nand_erase_block0();
 
-	return ret;
+		dbg_log(1, "Nand: The erasing is done\n\r");
+		return 0;
+	}
+	return 1;
 }
 #endif /* #ifdef CONFIG_NANDFLASH_RECOVERY */
 
@@ -532,62 +487,52 @@ int load_nandflash(struct image_info *img_info)
 	unsigned int size = img_info->length;
 	unsigned char *buffer = img_info->dest;
 
-	unsigned int length, readsize;
-	unsigned int block;
-	unsigned int page, start_page, end_page, numpages;
+	unsigned int block, length, readsize, numpage, page;
 	int ret;
 
 	nandflash_hw_init();
 
-	if (nandflash_get_type(&nand))
-		return -1;
-
 #ifdef CONFIG_NANDFLASH_RECOVERY
-	if (nandflash_recovery(&nand) == 0)
+	if (nandflash_recovery() == 0)
 		return -2;
 #endif
 
+	if (nandflash_get_type(&nand))
+		return -1;
+
 	dbg_log(1, "Nand: Copy %d bytes from %d to %d\r\n", size, offset, buffer);
 
 	block = offset / nand.blocksize;
-	start_page = (offset % nand.blocksize) / nand.pagesize;
-
 	length = size;
 	while (length > 0) {
-		/* read a buffer corresponding to a block */
+		/* read a buffer corresponding to a block in the origin file */
 		if (length < nand.blocksize)
 			readsize = length;
 		else
 			readsize = nand.blocksize;
 
-		/* adjust the number of pages to read */
-		numpages = readsize / nand.pagesize;
+		/* Adjust the number of sectors to read */
+		numpage = readsize / nand.pagesize;
 		if (readsize % nand.pagesize)
-			numpages++;
+			numpage++;
 
-		end_page = start_page + numpages;
-
-		/* check the bad block */
+		/* Loop until a valid block has been read */
 		while (1) {
-			if (nand_check_badblock(&nand, block, buffer) != 0) {
-				block++; /* skip this block */
-				dbg_log(1, "Bad block: #%d\n\r", block);
-			} else
-				break;
-		}
+			for (page = 0; page < numpage; page++) {
+				ret = nand_read_page(&nand, block, page, ZONE_DATA, buffer);
+				if (ret == ECC_CORRECT_ERROR)
+					return -1;
+				else if (ret == -1) /* skip this block */
+					break;
+				else
+					buffer += nand.pagesize;
+			}
+			block++;
 
-		/* read pages of a block */
-		for (page = start_page; page < end_page; page++) {
-			ret = nand_read_page(&nand, block, page, ZONE_DATA, buffer);
-			if (ret == ECC_CORRECT_ERROR)
-				return -1;
-			else
-				buffer += nand.pagesize;
+			if (page >= numpage)
+				break;
 		}
 		length -= readsize;
-
-		block++;
-		start_page = 0;
 	}
 
 	return 0;
diff --git a/driver/pmc.c b/driver/pmc.c
old mode 100644
new mode 100755
diff --git a/driver/sdcard.c b/driver/sdcard.c
old mode 100644
new mode 100755
index 2ea1975..9a8b47d
--- a/driver/sdcard.c
+++ b/driver/sdcard.c
@@ -35,93 +35,45 @@
 
 #define CHUNK_SIZE	0x40000
 
-static int sdcard_loadimage(char *filename, BYTE *dest)
+int load_sdcard(struct image_info *img_info)
 {
+	FATFS	fs;
 	FIL 	file;
-	UINT	byte_to_read = CHUNK_SIZE;
-	UINT	byte_read;
 	FRESULT	fret;
-	int	ret;
+	
+	BYTE *pdata = img_info->dest;
+	UINT byte_to_read = CHUNK_SIZE;
+	UINT byte_read;
+	char *filename = img_info->filename;
+
+	at91_mci0_hw_init();
+
+	dbg_log(1, "Reading file %s from SD Card to %d\n\r", filename, pdata);
+	
+	fret = f_mount(0, &fs);
+	if (fret != FR_OK) {
+		dbg_log(1, "*** FATFS: f_mount error **\n\r");
+		return -1;
+	}
 
 	fret = f_open(&file, filename, FA_OPEN_EXISTING | FA_READ);
 	if (fret != FR_OK) {
 		dbg_log(1, "*** FATFS: f_open, filename: [%s]: error\n\r", filename);
-		ret = -1;
-		goto open_fail;
+		return -1 ;
 	}
 
 	do {
 		byte_read = 0;
-		fret = f_read(&file, (void *)(dest), byte_to_read, &byte_read);
-		dest += byte_to_read;
+		fret = f_read(&file, (void *)(pdata), byte_to_read, &byte_read);
+		pdata += byte_to_read;
 	} while (byte_read >= byte_to_read);
 
 	if (fret != FR_OK) {
 		dbg_log(1, "*** FATFS: f_read: error\n\r");
-		 ret = -1;
-		goto read_fail;
+		 return -1;
 	}
-	ret = 0;
 
-read_fail:
 	fret = f_close(&file);
 
-open_fail:
-	return ret;
-
-}
-
-int load_sdcard(struct image_info *image)
-{
-	FATFS	fs;
-	FRESULT	fret;
-	int	ret;
-
-	at91_mci0_hw_init();
-
-	/* mount fs */
-	fret = f_mount(0, &fs);
-	if (fret != FR_OK) {
-		dbg_log(1, "*** FATFS: f_mount mount error **\n\r");
-		return -1;
-	}
-
-	dbg_log(1, "SD/MMC: Image: Read file %s to %d\n\r",
-					image->filename, image->dest);
-
-	ret = sdcard_loadimage(image->filename, image->dest);
-	if (ret)
-		return ret;
-
-	/* umount fs */
-	fret = f_mount(0, NULL);
-	if (fret != FR_OK) {
-		dbg_log(1, "*** FATFS: f_mount umount error **\n\r");
-		return -1;
-	}
-
-	if (image->of) {
-		/* mount fs */
-		fret = f_mount(0, &fs);
-		if (fret != FR_OK) {
-			dbg_log(1, "*** FATFS: f_mount error **\n\r");
-			return -1;
-		}
-
-		dbg_log(1, "SD/MMC: dt blob: Read file %s to %d\n\r",
-				image->of_filename, image->of_dest);
-
-		ret = sdcard_loadimage(image->of_filename, image->of_dest);
-		if (ret)
-			return ret;
-
-		/* umount fs */
-		fret = f_mount(0, NULL);
-		if (fret != FR_OK) {
-			dbg_log(1, "*** FATFS: f_mount umount error **\n\r");
-			return -1;
-		}
-	}
-
 	return 0;
 }
diff --git a/driver/sddrc.c b/driver/sddrc.c
new file mode 100755
index 0000000..5472eb2
--- /dev/null
+++ b/driver/sddrc.c
@@ -0,0 +1,151 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2007, Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Copyright (c) 2007 Lead Tech Design <www.leadtechdesign.com>
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaiimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "../include/sddrc.h"
+#include "../include/part.h"
+#include "../include/main.h"
+
+static inline void write_sddrc(unsigned int offset, const unsigned int value)
+{
+    writel(value, offset + AT91C_BASE_SDDRC);
+}
+
+static inline unsigned int read_sddrc(unsigned int offset)
+{
+    return readl(offset + AT91C_BASE_SDDRC);
+}
+
+int sddrc_init(unsigned int sdramc_cr, unsigned int sdramc_tr)
+{
+    volatile unsigned int i;
+
+    /*
+     * Performs the hardware initialization 
+     */
+    sddrc_hw_init();
+
+    /*
+     * 32 bit mode, SDRAM type 
+     */
+    write_sddrc(SDDRC_MDR, 0x00000000);
+
+    /*
+     * CFG Control Register 
+     */
+    write_sddrc(SDDRC_CR, sdramc_cr);
+
+    /*
+     * inhibit low power 
+     */
+    write_sddrc(SDDRC_LPR, 0x00000000);
+
+    /*
+     * sleep 
+     */
+    for (i = 0; i < 1000; i++) ;
+
+    /*
+     * nop 
+     */
+    write_sddrc(SDDRC_MR, AT91C_MODE_NOP_CMD);
+    writel(0x00000000, AT91C_SDRAM);
+
+    /*
+     * nop 
+     */
+    write_sddrc(SDDRC_MR, AT91C_MODE_NOP_CMD);
+    writel(0x00000000, AT91C_SDRAM);
+
+    /*
+     * nop 
+     */
+    write_sddrc(SDDRC_MR, AT91C_MODE_NOP_CMD);
+    writel(0x00000000, AT91C_SDRAM);
+
+    /*
+     * precharge all banks 
+     */
+    write_sddrc(SDDRC_MR, AT91C_MODE_PRCGALL_CMD);
+    writel(0x00000000, AT91C_SDRAM);
+
+    /*
+     * sleep 
+     */
+    for (i = 0; i < 1000; i++) ;
+
+    /*
+     * auto refresh 
+     */
+    write_sddrc(SDDRC_MR, AT91C_MODE_RFSH_CMD);
+    writel(0x00000000, AT91C_SDRAM);
+
+    /*
+     * sleep 
+     */
+    for (i = 0; i < 1000; i++) ;
+
+    /*
+     * auto refresh 
+     */
+    write_sddrc(SDDRC_MR, AT91C_MODE_RFSH_CMD);
+    writel(0x00000000, AT91C_SDRAM);
+
+    /*
+     * sleep 
+     */
+    for (i = 0; i < 1000; i++) ;
+
+    /*
+     * lmr 
+     */
+    write_sddrc(SDDRC_MR, AT91C_MODE_LMR_CMD);
+    writel(0x5a5a5b5b, AT91C_SDRAM + 20);
+
+    /*
+     * auto refresh 
+     */
+    write_sddrc(SDDRC_MR, AT91C_MODE_NORMAL_CMD);
+    writel(0x00000000, AT91C_SDRAM);
+
+    /*
+     * refresh timer 
+     */
+    write_sddrc(SDDRC_RTR, sdramc_tr);
+
+    /*
+     * disable high speed 
+     */
+    write_sddrc(SDDRC_HS, 0x00000000);
+
+    /*
+     * sleep 
+     */
+    for (i = 0; i < 1000; i++) ;
+
+    return 0;
+}
diff --git a/driver/sdramc.c b/driver/sdramc.c
old mode 100644
new mode 100755
diff --git a/driver/serial_flash.c b/driver/serial_flash.c
new file mode 100755
index 0000000..30fb9c5
--- /dev/null
+++ b/driver/serial_flash.c
@@ -0,0 +1,797 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#include "common.h"
+#include "hardware.h"
+#include "board.h"
+#include "spi.h"
+#include "arch/at91_pio.h"
+#include "gpio.h"
+#include "string.h"
+
+#include "debug.h"
+
+/* Common commands */
+#define CMD_AT45_READ_STATUS		0xd7
+#define CMD_AT45_ERASE_PAGE		0x81
+#define CMD_READ_ID			0x9f
+
+#define CMD_READ_ARRAY_SLOW		0x03
+#define CMD_READ_ARRAY_FAST		0x0b
+#define CMD_READ_ARRAY_LEGACY		0xe8
+
+/* AT45-specific commands */
+#define CMD_AT45_READ_STATUS		0xd7
+
+/* AT45 status register bits */
+#define AT45_STATUS_P2_PAGE_SIZE	(1 << 0)
+#define AT45_STATUS_READY		(1 << 7)
+
+/* AT25-specific commands */
+#define CMD_AT25_READ_STATUS		0x05
+#define CMD_AT25_WRITE_STATUS		0x01
+
+#define CMD_AT25_BYTE_PAGE_PROGRAM	0x02
+#define CMD_AT25_ERASE_BLOCK_4K		0x20
+#define CMD_AT25_ERASE_BLOCK_32K	0x52
+#define CMD_AT25_ERASE_BLOCK_64K	0xD8
+
+#define CMD_AT25_WRITE_ENABLE	0x06
+#define CMD_AT25_WRITE_DISABLE	0x04
+
+/* AT25 status register bits */
+#define AT25_STATUS_READYBUSY		(1 << 0)
+#define AT25_STATUS_READYBUSY_READY	(0 << 0)
+#define AT25_STATUS_READYBUSY_BUSY	(1 << 0)
+#define AT25_ERASE_PROGRAM_ERROR	(1 << 5)
+#define AT25_STATUS_SWP			(3 << 2)
+#define AT25_STATUS_SWP_PROTECTALL	(3 << 2)
+#define AT25_STATUS_SWP_PROTECTSOME	(1 << 2)
+#define AT25_STATUS_SWP_PROTECTNONE	(0 << 2)
+#define AT25_STATUS_SPRL		(1 << 7)
+#define AT25_STATUS_SPRL_UNLOCKED	(0 << 7)
+#define AT25_STATUS_SPRL_LOCKED		(1 << 7)
+
+#define BLOCK_SIZE_4K		(4 * 1024)
+
+#define SPI_FLASH_PAGE_ERASE_TIMEOUT	5000
+
+/* DataFlash family IDs, as obtained from the second idcode byte */
+#define DF_FAMILY_AT26F			0x00
+#define DF_FAMILY_AT45			0x01
+#define DF_FAMILY_AT26DF		0x02	/* AT25DF and AT26DF */
+
+/* struct definiton */
+struct serial_flash_params {
+	unsigned char	idcode1;
+	/* Log2 of page size in power-of-two mode */
+	unsigned char	l2_page_size;
+	unsigned char	pages_per_block;
+	unsigned char	blocks_per_sector;
+	unsigned char	nr_sectors;
+	const char	*name;
+};
+
+typedef int (*serial_flash_read)(unsigned int offset, unsigned int len, void *buf);
+typedef int (*serial_flash_erase)(unsigned int offset, unsigned int len);
+
+static serial_flash_read  sf_read;
+static serial_flash_erase sf_erase;
+
+static struct serial_flash_params 	atmel_sf_params;
+
+static const struct serial_flash_params atmel_flash_table[] = {
+	{
+		.idcode1		= 0x22,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 16,
+		.nr_sectors		= 4,
+		.name			= "AT45DB011D",
+	},
+	{
+		.idcode1		= 0x23,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 16,
+		.nr_sectors		= 8,
+		.name			= "AT45DB021D",
+	},
+	{
+		.idcode1		= 0x24,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 8,
+		.name			= "AT45DB041D",
+	},
+	{
+		.idcode1		= 0x25,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 16,
+		.name			= "AT45DB081D",
+	},
+	{
+		.idcode1		= 0x26,
+		.l2_page_size		= 9,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 16,
+		.name			= "AT45DB161D",
+	},
+	{
+		.idcode1		= 0x27,
+		.l2_page_size		= 9,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 64,
+		.nr_sectors		= 64,
+		.name			= "AT45DB321D",
+	},
+	{
+		.idcode1		= 0x28,
+		.l2_page_size		= 10,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 32,
+		.name			= "AT45DB642D",
+	},
+	{
+		.idcode1		= 0x47,
+		.l2_page_size		= 8,	/* 256 bytes per page */
+		.pages_per_block	= 16,	/* 4k bytes per block */
+		.blocks_per_sector	= 16,	/* 64k bytes per sector*/
+		.nr_sectors		= 64,	/* 64 sectors */
+		.name			= "AT25DF321",
+	},
+};
+
+static int sf_read_write(const unsigned char *cmd, 
+			unsigned int cmd_len,
+			const unsigned char *data_out, 
+			unsigned char *data_in,
+			unsigned int data_len)
+{
+	unsigned long flags = SPI_XFER_BEGIN;
+	int ret;
+
+	if (data_len == 0)
+		flags |= SPI_XFER_END;
+
+	/* command */
+	ret = spi_xfer(cmd_len, cmd, NULL, flags);
+	if (ret) 
+		dbg_log(1, "SF: Failed to send command (%d bytes): %d\n\r", cmd_len, ret);
+	else if (data_len != 0) { /* data */
+		ret = spi_xfer(data_len, data_out, data_in, SPI_XFER_END);
+		if (ret)
+			dbg_log(1, "SF: Failed to transfer %d bytes of data: %d\n\r", data_len, ret);
+	}
+
+	return ret;
+}
+
+static int sf_cmd(unsigned char cmd, void *response, unsigned int len)
+{
+	return sf_read_write(&cmd, 1, NULL, response, len);
+}
+
+static int sf_cmd_read(const unsigned char *cmd, unsigned int cmd_len,
+			void *data, unsigned int data_len)
+{
+	int ret;
+
+	at91_spi_enable();
+	ret = sf_read_write(cmd, cmd_len, NULL, data, data_len);
+	at91_spi_disable();
+
+	return ret;
+}
+
+static int sf_cmd_write(const unsigned char *cmd,
+		unsigned int cmd_len,
+		const void *data,
+		unsigned int data_len)
+{
+	int ret;
+
+	at91_spi_enable();
+	ret = sf_read_write(cmd, cmd_len, data, NULL, data_len);
+	at91_spi_disable();
+
+	return ret;
+}
+
+static int sf_cmd_read_fast(unsigned int offset, unsigned int len, void *buf)
+{
+	unsigned char cmd[5];
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = offset >> 16;
+	cmd[2] = offset >> 8;
+	cmd[3] = offset >> 0;
+	cmd[4] = 0x00;
+
+	return sf_cmd_read(cmd, sizeof(cmd), buf, len);
+}
+
+/*
+ * Assemble the address part of a command for AT45 devices in
+ * non-power-of-two page size mode.
+ */
+static void at45_build_address(	unsigned char *cmd, unsigned int offset)
+{
+	const struct serial_flash_params *sf_params = &atmel_sf_params;
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	unsigned int page_shift;
+
+	/*
+	 * The "extra" space per page is the power-of-two page size
+	 * divided by 32.
+	 */
+	page_shift = sf_params->l2_page_size;
+	page_size = (1 << page_shift) + (1 << (page_shift - 5));
+	page_shift++;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	cmd[0] = page_addr >> (16 - page_shift);
+	cmd[1] = page_addr << (page_shift - 8) | (byte_addr >> 8);
+	cmd[2] = byte_addr;
+}
+
+static int dataflash_read_fast_at45(unsigned int offset, 
+				unsigned int len, void *buf)
+{
+	unsigned char cmd[5];
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	at45_build_address(cmd + 1, offset);
+	cmd[4] = 0x00;
+
+	return sf_cmd_read(cmd, sizeof(cmd), buf, len);
+}
+
+static int sf_cmd_read_id(unsigned char *idcode, unsigned int idcode_len)
+{
+	int ret;
+
+	/* Read the ID codes */
+	ret = sf_cmd(CMD_READ_ID, idcode, idcode_len);
+	if (ret)
+		return -1;
+
+#ifdef CONFIG_DEBUG
+	unsigned int i;
+	unsigned char *p = idcode;
+
+	dbg_log(1, "SF: Got idcodes:");
+	for (i = 0; i < idcode_len; i++)
+		dbg_log(1, "%d ", *p++);
+	dbg_log(1, "\n\r");
+#endif
+	return 0;
+}
+
+static int sf_cmd_read_status_at45(unsigned char *page_256)
+{
+	unsigned char status;
+	int ret;
+
+	ret = sf_cmd(CMD_AT45_READ_STATUS, &status, 1);
+	if (ret)
+		return -1;
+
+	dbg_log(1, "SF: AT45 status register: %d\n\r", status);
+
+	if ((status & AT45_STATUS_P2_PAGE_SIZE))
+		*page_256 = 1;
+	else
+		*page_256 = 0;
+	
+	return 0;
+}
+
+static int at45_wait_ready(unsigned long timeout)
+{
+	int ret;
+	unsigned char status;
+
+	at91_spi_enable();
+
+	do {
+		ret = sf_cmd(CMD_AT45_READ_STATUS, &status, 1);
+		if (ret)
+			goto err;
+
+		if (status & AT45_STATUS_READY)
+			break;
+
+	} while (--timeout);
+
+	if (!(status & AT45_STATUS_READY)) {
+		ret = -1;
+		goto err;
+	}
+
+	at91_spi_disable();
+
+	return 0;
+
+err:
+	at91_spi_disable();
+
+	return ret;
+}
+
+static int dataflash_erase_p2(unsigned int offset, unsigned int len)
+{
+	const struct serial_flash_params *sf_params = &atmel_sf_params;
+	unsigned long page_size;
+
+	unsigned int actual;
+	int ret;
+	unsigned char cmd[4];
+
+	/*
+	 * TODO: This function currently uses page erase only. We can
+	 * probably speed things up by using block and/or sector erase
+	 * when possible.
+	 */
+	page_size = (1 << sf_params->l2_page_size);
+
+	if (offset % page_size || len % page_size) {
+		dbg_log(1, "SF: Erase offset/length not multiple of page size\n\r");
+		return -1;
+	}
+
+	cmd[0] = CMD_AT45_ERASE_PAGE;
+	cmd[3] = 0x00;
+
+	for (actual = 0; actual < len; actual += page_size) {
+		cmd[1] = offset >> 16;
+		cmd[2] = offset >> 8;
+
+		ret = sf_cmd_write(cmd, 4, NULL, 0);
+		if (ret < 0) {
+			dbg_log(1, "SF: AT45 page erase failed\n\r");
+			return ret;
+		}
+
+		ret = at45_wait_ready(SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			dbg_log(1, "SF: AT45 page erase timed out\n\r");
+			return ret;
+		}
+
+		offset += page_size;
+	}
+
+	dbg_log(1, "SF: AT45: Successfully erased %d bytes @ %d\n\r", len, offset);
+
+	return 0;
+}
+
+static int dataflash_erase_at45(unsigned int offset, unsigned int len)
+{
+	const struct serial_flash_params *sf_params = &atmel_sf_params;
+	unsigned long page_addr;
+	unsigned long page_size;
+	unsigned int page_shift;
+	unsigned int actual;
+	unsigned int length;
+	int ret;
+	unsigned char cmd[4];
+
+	len = len;
+
+	/*
+	 * TODO: This function currently uses page erase only. We can
+	 * probably speed things up by using block and/or sector erase
+	 * when possible.
+	 */
+	page_shift = sf_params->l2_page_size;
+	page_size = (1 << page_shift) + (1 << (page_shift - 5));
+	page_shift++;
+	page_addr = offset / page_size;
+
+	length = page_size;
+	if (offset % page_size || length % page_size) {
+		dbg_log(1, "SF: Erase offset/length not multiple of page size\n\r");
+		return -1;
+	}
+
+	cmd[0] = CMD_AT45_ERASE_PAGE;
+	cmd[3] = 0x00;
+
+	for (actual = 0; actual < length; actual += page_size) {
+		cmd[1] = page_addr >> (16 - page_shift);
+		cmd[2] = page_addr << (page_shift - 8);
+
+		ret = sf_cmd_write(cmd, 4, NULL, 0);
+		if (ret < 0) {
+			dbg_log(1, "SF: AT45 page erase failed\n\r");
+			return ret;
+		}
+
+		ret = at45_wait_ready(SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			dbg_log(1, "SF: AT45 page erase timed out\n\r");
+			return ret;
+		}
+
+		page_addr++;
+	}
+
+	dbg_log(1, "SF: AT45: Successfully erased %d bytes @ %d\n\r", length, offset);
+
+	return 0;
+}
+
+static int at25_read_status(void)
+{
+	int ret;
+	unsigned char cmd = CMD_AT25_READ_STATUS;
+	unsigned char status;
+
+	ret = sf_cmd_read(&cmd, 1, &status, 1);
+
+	if (ret < 0) {
+		dbg_log(1, "SF: Error occured when read AT25 status\n");
+		return ret;
+	} else
+		return status;
+}
+
+static int at25_wait_ready(unsigned long timeout)
+{
+	int ret;
+	unsigned char status;
+
+	do {
+		ret = at25_read_status();
+		if (ret < 0)
+			return -1;
+		else
+			status = ret;
+
+		if ((status & AT25_STATUS_READYBUSY)
+				== AT25_STATUS_READYBUSY_READY)
+			break;
+	} while (--timeout);
+
+	if ((status & AT25_STATUS_READYBUSY) == AT25_STATUS_READYBUSY_READY)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+static int at25_write_status(unsigned char data)
+{
+	unsigned char cmd = CMD_AT25_WRITE_STATUS;
+
+	return sf_cmd_write(&cmd, 1, &data, 1);
+}
+
+static int at25_write_enable(int is_enable)
+{
+	int ret;
+	unsigned char cmd;
+
+	if (is_enable)
+		cmd = CMD_AT25_WRITE_ENABLE;
+	else
+		cmd = CMD_AT25_WRITE_DISABLE;
+
+	at91_spi_enable();
+
+	ret = spi_xfer(1, &cmd, NULL, SPI_XFER_BEGIN);
+	if (ret) {
+		ret = -1;
+		goto out;
+	}
+
+	/* Deactivate CS */
+	spi_xfer(0, NULL, NULL, SPI_XFER_END);
+
+out:
+	at91_spi_disable();
+	return 0;
+}
+
+static int at25_unprotect(void)
+{
+	int ret;
+	unsigned char status;
+
+	ret = at25_read_status();
+	if (ret < 0) {
+		dbg_log(1, "SF: Read AT25 status failed\n\r");
+		return ret;
+	} else
+		status = ret;
+
+	if ((status & AT25_STATUS_SWP) == AT25_STATUS_SWP_PROTECTNONE) {
+		/* Protection already disabled */
+		return 0;
+	}
+
+	/* Check if sector protection registers are locked */
+	if ((status & AT25_STATUS_SPRL) == AT25_STATUS_SPRL_LOCKED) {
+		/* Unprotect sector protection registers. */
+		at25_write_enable(1);
+		at25_write_status(0);
+	}
+
+	/* Perform a global unprotect command */
+	at25_write_enable(1);
+	at25_write_status(0);
+
+	/* Check the new status */
+	status = at25_read_status();
+	if (ret < 0)
+		return -1;
+
+	if ((status & (AT25_STATUS_SPRL | AT25_STATUS_SWP)) != 0) {
+		dbg_log(1, "SF: Unprotect AT25 failed\n\r");
+		return -1;
+	} else
+		return 0;
+}
+
+static int dataflash_erase_block_at25(unsigned int offset)
+{
+	/* Using 4k block erase. */
+	unsigned int addr = offset;
+	int ret;
+	unsigned char cmd[4];
+
+	if (offset % BLOCK_SIZE_4K != 0)
+		return -1;
+
+	ret = at25_write_enable(1);
+	if (ret < 0) {
+		dbg_log(1, "SF: Enable write AT25 failed\n\r");
+		return ret;
+	}
+
+	cmd[0] = CMD_AT25_ERASE_BLOCK_4K;
+	cmd[1] = addr >> 16;
+	cmd[2] = addr >> 8;
+	cmd[3] = addr;
+	ret = sf_cmd_write(cmd, 4, NULL, 0);
+	if (ret < 0) {
+		dbg_log(1, "SF: AT25 4k block erase failed\n\r");
+		return ret;
+	}
+
+	ret = at25_wait_ready(SPI_FLASH_PAGE_ERASE_TIMEOUT);
+	if (ret < 0) {
+		dbg_log(1,"SF: AT25 4k block erase timed out\n\r");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dataflash_erase_at25(unsigned int offset, unsigned int len)
+{
+	int ret;
+	unsigned int addr;
+
+	/*
+	 * TODO: This function currently uses 4k block erase only. We can
+	 * probably speed things up by using 32k/64k block erase or chip
+	 * erase when possible.
+	 */
+
+	if (offset % BLOCK_SIZE_4K || len % BLOCK_SIZE_4K) {
+		dbg_log(1, "SF: Erase offset/length not multiple of block size\n\r");
+		return -1;
+	}
+
+	ret = at25_unprotect();
+	if (ret < 0)
+		return ret;
+
+	/* Use 4k block erase. */
+	for (addr = offset; addr < offset + len; addr += BLOCK_SIZE_4K) {
+		if (offset % BLOCK_SIZE_4K != 0)
+			addr = (addr >> 12) << 12;	/* 4k size align. */
+
+		ret = dataflash_erase_block_at25(addr);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+#define IDCODE_LEN	5
+#define MANU_ID_ATMEL	0x1F
+
+static int atmel_sf_probe(unsigned int clock, unsigned int spi_mode)
+{
+	const struct serial_flash_params *sf_params = &atmel_sf_params;
+	const struct serial_flash_params *params;
+	unsigned char idcode[IDCODE_LEN];
+	unsigned char manu_id;
+	unsigned int family;
+	unsigned int i;
+	int ret;
+	unsigned char page_256;
+
+	ret = at91_spi_init(clock, spi_mode);
+	if (ret) {
+		dbg_log(1, "SF: Failed to init SPI bus\n\r");
+		return -1;
+	}
+
+	ret = at91_spi_enable();
+	if (ret) {
+		dbg_log(1, "SF: Failed to enable SPI bus\n\r");
+		return -1;
+	}
+
+	/* Read the ID codes */
+	ret = sf_cmd_read_id(idcode, sizeof(idcode));
+	if (ret)
+		goto err;
+	
+	manu_id = idcode[0];
+	if (manu_id == MANU_ID_ATMEL){ /* Manufacturer ID:0x1F = Atmel */
+		for (i = 0; i < ARRAY_SIZE(atmel_flash_table); i++) {
+			params = &atmel_flash_table[i];
+			if (params->idcode1 == idcode[1])	/* Device ID */
+				break;
+		}
+
+		if (i == ARRAY_SIZE(atmel_flash_table)) {
+			dbg_log(1, "SF: Unsupported SerialFlash ID %02x\n", idcode[1]);
+			goto err;
+		}
+
+		memcpy((unsigned char *)sf_params, (unsigned char *)params,
+					sizeof (struct serial_flash_params));
+
+		family = idcode[1] >> 5;	/* Family Code */
+
+		switch (family) {
+		case DF_FAMILY_AT45:
+			/*
+			 * AT45 chips have configurable page size. The status
+		 	 * register indicates which configuration is active.
+		 	 */
+			ret = sf_cmd_read_status_at45(&page_256);
+			if (ret)
+				goto err;
+
+			if (page_256 == 0) {
+				sf_read = dataflash_read_fast_at45;
+				sf_erase = dataflash_erase_at45;
+			} else {
+				sf_read = sf_cmd_read_fast;
+				sf_erase = dataflash_erase_p2;
+			}
+			break;
+
+		case DF_FAMILY_AT26F:
+		case DF_FAMILY_AT26DF:
+			sf_read = sf_cmd_read_fast;
+			sf_erase = dataflash_erase_at25;
+			break;
+
+		default:
+			dbg_log(1, "SF: Unsupported SerialFlash family %d\n\r", family);
+			goto err;
+		}
+
+	} else {
+		dbg_log(1, "SF: Unsupported SerialFlash Manufacturer ID %d\n\r", manu_id);
+		goto err;
+	}
+
+	dbg_log(1, "SF: Detected flash %s\n\r", sf_params->name);
+
+	at91_spi_disable();
+
+	return 0;
+
+err:
+	at91_spi_disable();
+
+	return -1;
+}
+
+#ifdef CONFIG_DATAFLASH_RECOVERY
+static int dataflash_page_erase(void)
+{
+	unsigned int offset = 0;
+	unsigned int len = BLOCK_SIZE_4K;
+	int ret;
+
+	ret = (*sf_erase)(offset, len);
+	return ret;
+}
+
+static int dataflash_recovery(void)
+{
+	/*
+	 * If Recovery Button is pressed during boot sequence,
+	 * erase dataflash page0
+	*/
+	if ((pio_get_value(CONFIG_SYS_RECOVERY_BUTTON_PIN)) == 0) {
+		dbg_log(1, "SF: The recovery button (%s) has been pressed,\n\r", RECOVERY_BUTTON_NAME);
+		dbg_log(1, "SF: The page 0 is erasing...\n\r");
+
+		if (dataflash_page_erase() == 0) {
+			dbg_log(1, "SF: The erasing is done\n\r");
+			return 0;
+		} else {
+			dbg_log(1, "SF: The erasing failed\n\r");
+			return -1;
+		}
+
+	}
+
+	return 1;
+}
+#endif /* #ifdef CONFIG_DATAFLASH_RECOVERY */
+
+int load_dataflash(struct image_info *img_info)
+{
+	unsigned int offset = img_info->offset;
+	unsigned int size = img_info->length;
+	unsigned char *dest = img_info->dest;
+	int ret;
+
+	at91_spi0_hw_init();
+
+	ret = atmel_sf_probe(CONFIG_SYS_SPI_CLOCK, CONFIG_SYS_SPI_MODE);
+	if (ret) {
+		dbg_log(1, "SF: Fail to probe atmel serial flash\n\r");
+		return -1;
+	}
+
+#ifdef CONFIG_DATAFLASH_RECOVERY
+	if (dataflash_recovery() == 0)
+		return -2;
+#endif
+
+	dbg_log(1, "SF: Copy %d bytes from %d to %d\n\r", size, offset, dest);
+
+	ret = (*sf_read)(offset, size, dest);
+	if (ret) {
+		dbg_log(1, "** SF: Serial flash read error**\n\r");
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/elf32-littlearm.lds b/elf32-littlearm.lds
old mode 100644
new mode 100755
diff --git a/fs/include/diskio.h b/fs/include/diskio.h
old mode 100644
new mode 100755
diff --git a/fs/include/ff.h b/fs/include/ff.h
old mode 100644
new mode 100755
diff --git a/fs/include/ffconf.h b/fs/include/ffconf.h
old mode 100644
new mode 100755
diff --git a/fs/include/integer.h b/fs/include/integer.h
old mode 100644
new mode 100755
diff --git a/fs/include/media.h b/fs/include/media.h
old mode 100644
new mode 100755
index 823d936..5994775
--- a/fs/include/media.h
+++ b/fs/include/media.h
@@ -28,9 +28,7 @@
 #ifndef __MEDIA_H__
 #define __MEDIA_H__
 
-extern int sdcard_initialize(void);
-extern unsigned int sdcard_block_read(unsigned int start,
-					unsigned int blkcnt,
-					void *dest);
+extern int mmc_initialize(void);
+extern unsigned int mmc_bread(unsigned int start, unsigned int blkcnt, void *dest);
 
 #endif
diff --git a/fs/src/diskio.c b/fs/src/diskio.c
old mode 100644
new mode 100755
index 9983fac..4ba88f1
--- a/fs/src/diskio.c
+++ b/fs/src/diskio.c
@@ -23,7 +23,7 @@ DSTATUS disk_initialize(BYTE drv        /* Physical drive number (0..) */
 {
 	if (drv) return STA_NOINIT;	
 	
-	if (sdcard_initialize() == 0)
+	if (mmc_initialize() == 0)
 		Stat &= ~STA_NOINIT;
 
 	return Stat;
@@ -54,9 +54,7 @@ DRESULT disk_read(BYTE drv,     /* Physical drive number (0..) */
 	if (drv || !count) return RES_PARERR;
 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 
-	if (sdcard_block_read((unsigned int)sector,
-				(unsigned int)count,
-				(void *)buff) == count)
+	if (mmc_bread((unsigned int)sector, (unsigned int)count, (void *)buff) == count)
 		return RES_OK;
 	else
 		return RES_ERROR;
diff --git a/fs/src/fat.mk b/fs/src/fat.mk
old mode 100644
new mode 100755
diff --git a/fs/src/ff.c b/fs/src/ff.c
old mode 100644
new mode 100755
diff --git a/glue.c b/glue.c
new file mode 100644
index 0000000..cf8e4b5
--- /dev/null
+++ b/glue.c
@@ -0,0 +1,27 @@
+/* 2013/01/16 Mathias Langer (www.taskit.de): gluecode for malloc & free */
+
+#ifndef MEM_ALLOC_BASE
+#define MEM_ALLOC_BASE  OS_MEM_BANK
+#endif
+
+#ifndef NULL
+#define NULL  0
+#endif
+
+static void *brkp = (void*)MEM_ALLOC_BASE;
+
+void *_sbrk(int increment)
+{
+	void *tmp;
+
+	tmp = brkp;
+	brkp += increment;
+	return(tmp);
+}
+
+int *_brk(void *p)
+{
+	brkp = p;
+	return(0);
+}
+
diff --git a/host-utilities/host.mk b/host-utilities/host.mk
old mode 100644
new mode 100755
diff --git a/include/arch/at91_ccfg.h b/include/arch/at91_ccfg.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_dbgu.h b/include/arch/at91_dbgu.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_ddrsdrc.h b/include/arch/at91_ddrsdrc.h
old mode 100644
new mode 100755
index 56e141e..6adf407
--- a/include/arch/at91_ddrsdrc.h
+++ b/include/arch/at91_ddrsdrc.h
@@ -89,22 +89,16 @@
 #define 	AT91C_DDRC2_CAS_2		(0x2UL << 4)
 #define 	AT91C_DDRC2_CAS_3		(0x3UL << 4)
 #define 	AT91C_DDRC2_CAS_4		(0x4UL << 4)
-#define 	AT91C_DDRC2_CAS_5		(0x5UL << 4)
 #define 	AT91C_DDRC2_CAS_2_5		(0x6UL << 4)
 #define AT91C_DDRC2_DLL		(0x1UL << 7)
 #define 	AT91C_DDRC2_DLL_RESET_DISABLED	(0x0UL << 7)
 #define 	AT91C_DDRC2_DLL_RESET_ENABLED	(0x1UL << 7)
 #define AT91C_DDRC2_DIC_DS	(0x1UL << 8)
 #define AT91C_DDRC2_DIS_DLL	(0x1UL << 9)
-#define 	AT91C_DDRC2_DIS_DLL_DISABLED	(0x0UL << 9)
-#define 	AT91C_DDRC2_DIS_DLL_ENABLED	(0x1UL << 9)
 #define AT91C_DDRC2_OCD		(0x7UL << 12)
 #define 	AT91C_DDRC2_OCD_EXIT		(0x0UL << 12)
 #define 	AT91C_DDRC2_OCD_DEFAULT		(0x7UL << 12)
 #define AT91C_DDRC2_EBISHARE	(0x1UL << 16)
-#define AT91C_DDRC2_ENRDM	(0x1UL << 17)
-#define 	AT91C_DDRC2_ENRDM_DISABLE	(0x0UL << 17)
-#define 	AT91C_DDRC2_ENRDM_ENABLE	(0x1UL << 17)
 #define AT91C_DDRC2_ACTBST	(0x1UL << 18)
 #define AT91C_DDRC2_NB_BANKS	(0x1UL << 20)
 #define 	AT91C_DDRC2_NB_BANKS_4		(0x0UL << 20)
@@ -116,8 +110,8 @@
 #define 	AT91C_DDRC2_DECOD_SEQUENTIAL	(0x0UL << 22)
 #define 	AT91C_DDRC2_DECOD_INTERLEAVED	(0x1UL << 22)
 #define AT91C_DDRC2_UNAL	(0x1UL << 23)	/* Support Unaligned Access(sama5d3x only) */
-#define 	AT91C_DDRC2_UNAL_UNSUPPORTED		(0x0UL << 23)
-#define 	AT91C_DDRC2_UNAL_SUPPORTED		(0x1UL << 23)
+#define 	AT91C_DDRC2_UNSUPPORTED		(0x0UL << 23)
+#define 	AT91C_DDRC2_SUPPORTED		(0x1UL << 23)
 
 /* -------- HDDRSDRC2_T0PR : (HDDRSDRC2 Offset: 0xc) Timing0 Register --------*/ 
 #define AT91C_DDRC2_TRAS	(0xFUL <<  0)
@@ -285,8 +279,6 @@
 #define 	AT91C_DDRC2_TXSNR_0		(0x0UL << 8)
 #define 	AT91C_DDRC2_TXSNR_8		(0x8UL << 8)
 #define 	AT91C_DDRC2_TXSNR_16		(0x10UL << 8)
-#define 	AT91C_DDRC2_TXSNR_19		(0x13UL << 8)
-#define 	AT91C_DDRC2_TXSNR_28		(0x1CUL << 8)
 #define 	AT91C_DDRC2_TXSNR_32		(0x20UL << 8)
 #define 	AT91C_DDRC2_TXSNR_48		(0x30UL << 8)
 #define 	AT91C_DDRC2_TXSNR_64		(0x40UL << 8)
@@ -317,7 +309,6 @@
 #define 	AT91C_DDRC2_TXSRD_160		(0xA0UL << 16)
 #define 	AT91C_DDRC2_TXSRD_176		(0xB0UL << 16)
 #define 	AT91C_DDRC2_TXSRD_192		(0xC0UL << 16)
-#define 	AT91C_DDRC2_TXSRD_200		(0xC8UL << 16)
 #define 	AT91C_DDRC2_TXSRD_208		(0xD0UL << 16)
 #define 	AT91C_DDRC2_TXSRD_224		(0xE0UL << 16)
 #define 	AT91C_DDRC2_TXSRD_240		(0xF0UL << 16)
@@ -466,41 +457,6 @@
 /* -------- HDDRSDRC2_HS : (HDDRSDRC2 Offset: 0x2c) High Speed Register --------*/ 
 #define AT91C_DDRC2_NO_ANT	(0x1UL << 2)
 
-/* -------- MPDDRC_IO_CALIBR : (MPDDRC Offset: 0x34) IO Calibration --------*/
-#define AT91C_MPDDRC_RDIV	(0x7UL << 0)
-#define 	AT91C_MPDDRC_RDIV_LPDDR2_RZQ_34		(0x1UL << 0)
-#define 	AT91C_MPDDRC_RDIV_LPDDR2_RZQ_48		(0x3UL << 0)
-#define 	AT91C_MPDDRC_RDIV_LPDDR2_RZQ_60		(0x4UL << 0)
-#define 	AT91C_MPDDRC_RDIV_LPDDR2_RZQ_120	(0x7UL << 0)
-
-#define 	AT91C_MPDDRC_RDIV_DDR2_RZQ_33_3		(0x2UL << 0)
-#define 	AT91C_MPDDRC_RDIV_DDR2_RZQ_50		(0x4UL << 0)
-#define 	AT91C_MPDDRC_RDIV_DDR2_RZQ_100		(0x7UL << 0)
-
-#define AT91C_MPDDRC_TZQIO	(0x1FUL << 8)
-#define 	AT91C_MPDDRC_TZQIO_0			(0x0UL << 8)
-#define 	AT91C_MPDDRC_TZQIO_1			(0x1UL << 8)
-#define 	AT91C_MPDDRC_TZQIO_4			(0x4UL << 8)
-#define 	AT91C_MPDDRC_TZQIO_31			(0x1FUL << 8)
-
-/* -------- MPDDRC_DLL_MOR : (MPDDRC Offset: 0x74) DLL Master Offset Register --------*/
-#define AT91C_MPDDRC_MOFF	(0xFUL << 0)
-#define 	AT91C_MPDDRC_MOFF_1	(0x1UL << 0)
-#define 	AT91C_MPDDRC_MOFF_7	(0x7UL << 0)
-#define AT91C_MPDDRC_CLK90OFF	(0x1FUL << 8)
-#define 	AT91C_MPDDRC_CLK90OFF_1		(0x1UL << 8)
-#define 	AT91C_MPDDRC_CLK90OFF_31	(0x1FUL << 8)
-#define AT91C_MPDDRC_SELOFF	(0x1UL << 16)
-#define 	AT91C_MPDDRC_SELOFF_DISABLED	(0x0UL << 16)
-#define 	AT91C_MPDDRC_SELOFF_ENABLED	(0x1UL << 16)
-#define AT91C_MPDDRC_KEY	(0xC5UL << 24)
-
-/* -------- MPDDRC_DLL_SOR : (MPDDRC Offset: 0x78) DLL Slave Offset Register --------*/
-#define AT91C_MPDDRC_S0OFF_1	(0x1UL << 0)
-#define AT91C_MPDDRC_S1OFF_1	(0x1UL << 8)
-#define AT91C_MPDDRC_S2OFF_1	(0x1UL << 16)
-#define AT91C_MPDDRC_S3OFF_1	(0x1UL << 24)
-
 /* -------- HDDRSDRC2_WPCR : (HDDRSDRC2 Offset: 0xe4) Write Protect Control Register --------*/ 
 #define AT91C_DDRC2_WPEN	(0x1UL << 0)
 #define AT91C_DDRC2_WPKEY	(0xFFFFFFUL << 8)
diff --git a/include/arch/at91_eefc.h b/include/arch/at91_eefc.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_matrix.h b/include/arch/at91_matrix.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_mci.h b/include/arch/at91_mci.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_nand_ecc.h b/include/arch/at91_nand_ecc.h
old mode 100644
new mode 100755
index 5645b0f..c271101
--- a/include/arch/at91_nand_ecc.h
+++ b/include/arch/at91_nand_ecc.h
@@ -49,7 +49,7 @@
 #define 	AT91C_PMECC_BCH_ERR2		(0x0UL)
 #define 	AT91C_PMECC_BCH_ERR4		(0x1UL)
 #define 	AT91C_PMECC_BCH_ERR8		(0x2UL)
-#define 	AT91C_PMECC_BCH_ERR12		(0x3UL)
+#define 	AT91C_PMECC_BCH_ERR16		(0x3UL)
 #define 	AT91C_PMECC_BCH_ERR24		(0x4UL)
 #define AT91C_PMECC_SECTORSZ	(0x1UL <<  4)	/* Sector Size */
 #define 	AT91C_PMECC_SECTORSZ_512	(0x0UL << 4)
@@ -113,12 +113,7 @@
 #define PMERRLOC_ELIER		0x014	/* Error Location Interrupt Enable Register */
 #define PMERRLOC_ELIDR		0x018	/* Error Location Interrupt Disable Register */
 #define PMERRLOC_ELIMR		0x01C	/* Error Location Interrupt Mask Register */
-
 #define PMERRLOC_ELISR		0x020	/* Error Location Interrupt Status Register */
-/* -------- PMERRLOC_ELISR: (Offset: 0x20) Error Location Interrupt Status Register --------*/
-#define PMERRLOC_ELISR_DONE		(0x1)
-#define PMERRLOC_ELISR_ERR_CNT		(0x1f << 8)
-
 /* 0x24 reserved */
 #define PMERRLOC_SIGMA0		0x028	/* PMECC Error Location SIGMA0 Register */
 
diff --git a/include/arch/at91_pio.h b/include/arch/at91_pio.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_pit.h b/include/arch/at91_pit.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_pmc.h b/include/arch/at91_pmc.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_rstc.h b/include/arch/at91_rstc.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_sdramc.h b/include/arch/at91_sdramc.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_slowclk.h b/include/arch/at91_slowclk.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_smc.h b/include/arch/at91_smc.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_spi.h b/include/arch/at91_spi.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91_wdt.h b/include/arch/at91_wdt.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91sam9260.h b/include/arch/at91sam9260.h
old mode 100644
new mode 100755
index 07ec101..125a6ac
--- a/include/arch/at91sam9260.h
+++ b/include/arch/at91sam9260.h
@@ -32,7 +32,7 @@
  * Peripheral identifiers/interrupts.
  */
 #define AT91C_ID_AIC		0	/* Advanced Interrupt Controller */
-#define AT91C_ID_SYS		1	/* System Controller Interrupt */
+#define AT91C_ID_SYSC		1	/* System Controller Interrupt */
 #define AT91C_ID_PIOA		2	/* Parallel I/O Controller A */
 #define AT91C_ID_PIOB		3	/* Parallel I/O Controller B */
 #define AT91C_ID_PIOC		4	/* Parallel I/O Controller C */
@@ -102,7 +102,7 @@
 #define AT91C_BASE_RSTC		0xfffffd00
 #define AT91C_BASE_SHDW		0xfffffd10
 #define AT91C_BASE_RTT		0xfffffd20
-#define AT91C_BASE_PITC		0xfffffd30
+#define AT91C_BASE_PIT		0xfffffd30
 #define AT91C_BASE_WDT		0xfffffd40
 #define AT91C_BASE_GPBR		0xfffffd50
 
diff --git a/include/arch/at91sam9261.h b/include/arch/at91sam9261.h
old mode 100644
new mode 100755
index e02631f..b34f3a4
--- a/include/arch/at91sam9261.h
+++ b/include/arch/at91sam9261.h
@@ -32,7 +32,7 @@
  * Peripheral identifiers/interrupts.
  */
 #define AT91C_ID_AIC		0	/* Advanced Interrupt Controller (FIQ) */
-#define AT91C_ID_SYS		1	/* System Controller Interrupt */
+#define AT91C_ID_SYSC		1	/* System Controller Interrupt */
 #define AT91C_ID_PIOA		2	/* Parallel I/O Controller A */
 #define AT91C_ID_PIOB		3	/* Parallel I/O Controller B */
 #define AT91C_ID_PIOC		4	/* Parallel I/O Controller C */
@@ -91,7 +91,7 @@
 #define AT91C_BASE_RSTC		0xfffffd00
 #define AT91C_BASE_SHDW		0xfffffd10
 #define AT91C_BASE_RTT		0xfffffd20
-#define AT91C_BASE_PITC		0xfffffd30
+#define AT91C_BASE_PIT		0xfffffd30
 #define AT91C_BASE_WDT		0xfffffd40
 #define AT91C_BASE_GPBR		0xfffffd50
 
diff --git a/include/arch/at91sam9263.h b/include/arch/at91sam9263.h
old mode 100644
new mode 100755
index a8d28b3..ba8569c
--- a/include/arch/at91sam9263.h
+++ b/include/arch/at91sam9263.h
@@ -32,7 +32,7 @@
  * Peripheral identifiers/interrupts.
  */
 #define AT91C_ID_FIQ		0	/* Advanced Interrupt Controller (FIQ) */
-#define AT91C_ID_SYS		1	/* System Controller */
+#define AT91C_ID_SYSC		1	/* System Controlleri */
 #define AT91C_ID_PIOA		2	/* Parallel IO Controller A */
 #define AT91C_ID_PIOB		3	/* Parallel IO Controller B */
 #define AT91C_ID_PIOCDE		4	/* Parallel IO Controller C, D, and E */
@@ -111,7 +111,7 @@
 #define AT91C_BASE_RSTC		0xfffffd00
 #define AT91C_BASE_SHDWC	0xfffffd10
 #define AT91C_BASE_RTT0		0xfffffd20
-#define AT91C_BASE_PITC		0xfffffd30
+#define AT91C_BASE_PIT		0xfffffd30
 #define AT91C_BASE_WDT		0xfffffd40
 #define AT91C_BASE_RTT1		0xfffffd50
 #define AT91C_BASE_GPBR		0xfffffd60
diff --git a/include/arch/at91sam9g10.h b/include/arch/at91sam9g10.h
old mode 100644
new mode 100755
index 9760547..5556696
--- a/include/arch/at91sam9g10.h
+++ b/include/arch/at91sam9g10.h
@@ -32,7 +32,7 @@
  * Peripheral identifiers/interrupts.
  */
 #define AT91C_ID_AIC		0	/* Advanced Interrupt Controller (FIQ) */
-#define AT91C_ID_SYS		1	/* System Controller Interrupt */
+#define AT91C_ID_SYSC		1	/* System Controller Interrupt */
 #define AT91C_ID_PIOA		2	/* Parallel I/O Controller A */
 #define AT91C_ID_PIOB		3	/* Parallel I/O Controller B */
 #define AT91C_ID_PIOC		4	/* Parallel I/O Controller C */
@@ -91,7 +91,7 @@
 #define AT91C_BASE_RSTC		0xfffffd00
 #define AT91C_BASE_SHDW		0xfffffd10
 #define AT91C_BASE_RTT		0xfffffd20
-#define AT91C_BASE_PITC		0xfffffd30
+#define AT91C_BASE_PIT		0xfffffd30
 #define AT91C_BASE_WDT		0xfffffd40
 #define AT91C_BASE_GPBR		0xfffffd50
 
diff --git a/include/arch/at91sam9g10_matrix.h b/include/arch/at91sam9g10_matrix.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91sam9g20.h b/include/arch/at91sam9g20.h
old mode 100644
new mode 100755
index ea81e5b..47e5d93
--- a/include/arch/at91sam9g20.h
+++ b/include/arch/at91sam9g20.h
@@ -32,7 +32,7 @@
  * Peripheral identifiers/interrupts.
  */
 #define AT91C_ID_AIC	0	/* Advanced Interrupt Controller (FIQ) */
-#define AT91C_ID_SYS	1	/* System Controller Interrupt */
+#define AT91C_ID_SYSC	1	/* System Controller Interrupt */
 #define AT91C_ID_PIOA	2	/* Parallel IO Controller A */
 #define AT91C_ID_PIOB	3	/* Parallel IO Controller B */
 #define AT91C_ID_PIOC	4	/* Parallel IO Controller C */
@@ -106,7 +106,7 @@
 #define AT91C_BASE_RSTC		0xfffffd00
 #define AT91C_BASE_SHDW		0xfffffd10
 #define AT91C_BASE_RTT		0xfffffd20
-#define AT91C_BASE_PITC		0xfffffd30
+#define AT91C_BASE_PIT		0xfffffd30
 #define AT91C_BASE_WDT		0xfffffd40
 #define AT91C_BASE_GPBR		0xfffffd50
 
diff --git a/include/arch/at91sam9g45.h b/include/arch/at91sam9g45.h
old mode 100644
new mode 100755
index ee0efdd..2a78056
--- a/include/arch/at91sam9g45.h
+++ b/include/arch/at91sam9g45.h
@@ -111,7 +111,7 @@
 #define AT91C_BASE_SHDC		0xfffffd10
 #define AT91C_BASE_RTTC		0xfffffd20
 #define AT91C_BASE_PITC		0xfffffd30
-#define AT91C_BASE_WDT		0xfffffd40
+#define AT91C_BASE_WDTC		0xfffffd40
 #define AT91C_BASE_SCKCR	0xfffffd50
 #define AT91C_BASE_GPBR		0xfffffd60
 #define AT91C_BASE_RTCC		0xfffffdb0
diff --git a/include/arch/at91sam9n12.h b/include/arch/at91sam9n12.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91sam9rl.h b/include/arch/at91sam9rl.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91sam9x5.h b/include/arch/at91sam9x5.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91sam9xe.h b/include/arch/at91sam9xe.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91sama5_smc.h b/include/arch/at91sama5_smc.h
old mode 100644
new mode 100755
diff --git a/include/arch/at91sama5d3x.h b/include/arch/at91sama5d3x.h
old mode 100644
new mode 100755
diff --git a/include/bch/bch.h b/include/bch/bch.h
new file mode 100644
index 0000000..ce5199e
--- /dev/null
+++ b/include/bch/bch.h
@@ -0,0 +1,85 @@
+/*
+ * Generic binary BCH encoding/decoding library
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 51
+ * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright  2011 Parrot S.A.
+ *
+ * Author: Ivan Djelic <ivan.djelic@parrot.com>
+ *
+ * Description:
+ *
+ * This library provides runtime configurable encoding/decoding of binary
+ * Bose-Chaudhuri-Hocquenghem (BCH) codes.
+*/
+#ifndef _BCH_H
+#define _BCH_H
+
+#include <stdint.h>
+
+/**
+ * struct bch_control - BCH control structure
+ * @m:          Galois field order
+ * @n:          maximum codeword size in bits (= 2^m-1)
+ * @t:          error correction capability in bits
+ * @ecc_bits:   ecc exact size in bits, i.e. generator polynomial degree (<=m*t)
+ * @ecc_bytes:  ecc max size (m*t bits) in bytes
+ * @a_pow_tab:  Galois field GF(2^m) exponentiation lookup table
+ * @a_log_tab:  Galois field GF(2^m) log lookup table
+ * @mod8_tab:   remainder generator polynomial lookup tables
+ * @ecc_buf:    ecc parity words buffer
+ * @ecc_buf2:   ecc parity words buffer
+ * @xi_tab:     GF(2^m) base for solving degree 2 polynomial roots
+ * @syn:        syndrome buffer
+ * @cache:      log-based polynomial representation buffer
+ * @elp:        error locator polynomial
+ * @poly_2t:    temporary polynomials of degree 2t
+ */
+struct bch_control {
+	unsigned int    m;
+	unsigned int    n;
+	unsigned int    t;
+	unsigned int    ecc_bits;
+	unsigned int    ecc_bytes;
+/* private: */
+	uint16_t       *a_pow_tab;
+	uint16_t       *a_log_tab;
+	uint32_t       *mod8_tab;
+	uint32_t       *ecc_buf;
+	uint32_t       *ecc_buf2;
+	unsigned int   *xi_tab;
+	unsigned int   *syn;
+	int            *cache;
+	struct gf_poly *elp;
+	struct gf_poly *poly_2t[4];
+};
+
+#ifndef DIV_ROUND_UP
+#define DIV_ROUND_UP(x, y)  ((((x)%(y)) != 0) ? ((x)/(y) + 1) : ((x)/(y)))
+#endif
+
+int fls(int i);
+
+struct bch_control *init_bch(int m, int t, unsigned int prim_poly);
+
+void free_bch(struct bch_control *bch);
+
+void encode_bch(struct bch_control *bch, const uint8_t *data,
+		unsigned int len, uint8_t *ecc);
+
+int decode_bch(struct bch_control *bch, const uint8_t *data, unsigned int len,
+	       const uint8_t *recv_ecc, const uint8_t *calc_ecc,
+	       const unsigned int *syn, unsigned int *errloc);
+
+#endif /* _BCH_H */
diff --git a/include/board.h b/include/board.h
old mode 100644
new mode 100755
index ce75aa1..3119edd
--- a/include/board.h
+++ b/include/board.h
@@ -28,6 +28,10 @@
 #ifndef __BOARD_H__
 #define __BOARD_H__
 
+#ifdef CONFIG_AG11005
+#include "ag11005.h"
+#endif
+
 #ifdef CONFIG_AT91SAM9260EK
 #include "at91sam9260ek.h"
 #endif
@@ -72,4 +76,20 @@
 #include "at91sama5d3xek.h"
 #endif
 
+#ifdef CONFIG_STAMP9G45
+#include "stamp9g45.h"
+#endif
+
+#ifdef CONFIG_STAMP9G20
+#include "stamp9g20.h"
+#endif
+
+#ifdef CONFIG_NANOSG20
+#include "nanosg20.h"
+#endif
+
+#ifdef CONFIG_PICOSG20
+#include "picosg20.h"
+#endif
+
 #endif /* #ifndef __BOARD_H__ */
diff --git a/include/common.h b/include/common.h
old mode 100644
new mode 100755
index 53b0b1d..c8c788e
--- a/include/common.h
+++ b/include/common.h
@@ -28,10 +28,45 @@
 #ifndef __COMMON_H__
 #define __COMMON_H__
 
-#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+#define uswap_16(x) \
+	((((x) & 0xff00) >> 8) | \
+	 (((x) & 0x00ff) << 8))
+#define uswap_32(x) \
+	((((x) & 0xff000000) >> 24) | \
+	 (((x) & 0x00ff0000) >>  8) | \
+	 (((x) & 0x0000ff00) <<  8) | \
+	 (((x) & 0x000000ff) << 24))
+#define _uswap_64(x, sfx) \
+	((((x) & 0xff00000000000000##sfx) >> 56) | \
+	 (((x) & 0x00ff000000000000##sfx) >> 40) | \
+	 (((x) & 0x0000ff0000000000##sfx) >> 24) | \
+	 (((x) & 0x000000ff00000000##sfx) >>  8) | \
+	 (((x) & 0x00000000ff000000##sfx) <<  8) | \
+	 (((x) & 0x0000000000ff0000##sfx) << 24) | \
+	 (((x) & 0x000000000000ff00##sfx) << 40) | \
+	 (((x) & 0x00000000000000ff##sfx) << 56))
 
-#define ALIGN(size, align)	(((size) + (align) - 1) & (~((align) - 1)))
-#define OF_ALIGN(size)		ALIGN(size, 4)
+#define uswap_64(x) _uswap_64(x, ull)
+
+#define cpu_to_le16(x)		(x)
+#define cpu_to_le32(x)		(x)
+#define cpu_to_le64(x)		(x)
+#define le16_to_cpu(x)		(x)
+#define le32_to_cpu(x)		(x)
+#define le64_to_cpu(x)		(x)
+#define cpu_to_be16(x)		uswap_16(x)
+#define cpu_to_be32(x)		uswap_32(x)
+#define cpu_to_be64(x)		uswap_64(x)
+#define be16_to_cpu(x)		uswap_16(x)
+#define be32_to_cpu(x)		uswap_32(x)
+#define be64_to_cpu(x)		uswap_64(x)
+
+#define htonl(x)		cpu_to_be32(x)
+#define htons(x)		cpu_to_be16(x)
+#define ntohl(x)		be32_to_cpu(x)
+#define ntohs(x)		be16_to_cpu(x)
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 
 #ifndef NULL
 #define	NULL	0
@@ -44,18 +79,12 @@ struct image_info
 	unsigned int length;
 	char *filename;
 	unsigned char *dest;
-
-	unsigned char of;
-	unsigned int of_offset;
-	unsigned int of_length;
-	char *of_filename;
-	unsigned char *of_dest;
 };
 
-static inline unsigned int swap_uint32(unsigned int data)
-{
-	return ((data & 0x000000ff) << 24) | ((data & 0x0000ff00) << 8)
-		| ((data & 0xff000000) >> 24) | ((data & 0x00ff0000) >> 8);
-}
+extern unsigned char card_present;
+
+/* common function */
+extern void delay(unsigned int count);
+extern void udelay(unsigned long usec);
 
 #endif /* #ifdef __COMMON_H__ */
diff --git a/include/dataflash.h b/include/dataflash.h
old mode 100644
new mode 100755
index 8c57283..e63afc2
--- a/include/dataflash.h
+++ b/include/dataflash.h
@@ -28,7 +28,7 @@
 #ifndef __DATAFLASH_H__
 #define __DATAFLASH_H__
 
-extern int load_dataflash(struct image_info *image);
+extern int load_dataflash(struct image_info *img_info);
 
 extern int dataflash_page0_erase(void);
 
diff --git a/include/dbgu.h b/include/dbgu.h
old mode 100644
new mode 100755
diff --git a/include/ddramc.h b/include/ddramc.h
old mode 100644
new mode 100755
diff --git a/include/debug.h b/include/debug.h
old mode 100644
new mode 100755
diff --git a/include/fdt.h b/include/fdt.h
deleted file mode 100644
index 0c1ebc5..0000000
--- a/include/fdt.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* ----------------------------------------------------------------------------
- *         ATMEL Microcontroller Software Support
- * ----------------------------------------------------------------------------
- * Copyright (c) 2012, Atmel Corporation
-
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the disclaimer below.
- *
- * Atmel's name may not be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
- * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef __FDT_H__
-#define __FDT_H__
-
-extern int check_dt_blob_valid(void *blob);
-extern int fixup_chosen_node(void *blob, char *bootargs);
-extern int fixup_memory_node(void *blob,
-				unsigned int *mem_bank,
-				unsigned int *mem_size);
-#endif /* #ifndef __FDT_H__ */
diff --git a/include/flash.h b/include/flash.h
old mode 100644
new mode 100755
diff --git a/include/gpio.h b/include/gpio.h
old mode 100644
new mode 100755
diff --git a/include/hamming.h b/include/hamming.h
old mode 100644
new mode 100755
diff --git a/include/hardware.h b/include/hardware.h
old mode 100644
new mode 100755
diff --git a/include/mci_media.h b/include/mci_media.h
deleted file mode 100644
index 6a75852..0000000
--- a/include/mci_media.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/* ----------------------------------------------------------------------------
- *         ATMEL Microcontroller Software Support
- * ----------------------------------------------------------------------------
- * Copyright (c) 2012, Atmel Corporation
-
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the disclaiimer below.
- *
- * Atmel's name may not be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
- * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef __MCI_MEDIA_H__
-#define __MCI_MEDIA_H__
-
-/* Command Flag */
-#define SD_APP_CMD	0x100
-#define MMC_CMD		0x200
-
-/* SD Command */
-#define SD_CMD_GO_IDLE_STATE		0
-#define SD_CMD_ALL_SEND_CID		2
-#define	SD_CMD_SEND_RELATIVE_ADDR	3
-#define SD_CMD_SWITCH_FUN		6
-#define SD_CMD_SELECT_CARD		7
-#define SD_CMD_SEND_IF_COND		8
-#define SD_CMD_SEND_CSD			9
-#define SD_CMD_SEND_CID			10
-#define SD_CMD_STOP_TRANSMISSION	12
-#define SD_CMD_SEND_STATUS		13
-#define	SD_CMD_SET_BLOCKLEN		16
-#define SD_CMD_READ_SINGLE_BLOCK	17
-#define SD_CMD_READ_MULTIPLE_BLOCK	18
-#define SD_CMD_SET_BLOCK_COUNT		23
-#define SD_CMD_APP_CMD			55
-
-/* SD App Command */
-#define SD_CMD_APP_SET_BUS_WIDTH	(6 | SD_APP_CMD)
-#define SD_CMD_APP_SD_STATUS		(13 | SD_APP_CMD)
-#define SD_CMD_APP_SD_SEND_OP_COND	(41 | SD_APP_CMD)
-#define SD_CMD_APP_SEND_SCR		(51 | SD_APP_CMD)
-
-/* MMC specifial Command */
-#define MMC_CMD_SEND_OP_COND		(1 | MMC_CMD)
-#define MMC_CMD_SWITCH_FUN		(6 | MMC_CMD)
-#define MMC_CMD_SEND_EXT_CSD		(8 | MMC_CMD)
-#define MMC_CMD_BUSTEST_R		(14 | MMC_CMD)
-#define MMC_CMD_BUSTEST_W		(19 | MMC_CMD)
-
-/* Card State */
-#define SD_STATE_INACTIVE		0
-#define SD_STATE_IDLE			1
-#define SD_STATE_READY			2
-#define SD_STATE_IDENTIFICATION		3
-#define	SD_STATE_STAND_BY		4
-#define SD_STATE_TRANSFER		5
-#define	SD_STATE_SENDING_DATA		6
-#define SD_STATE_RECEIVE_DATA		7
-#define SD_STATE_PROGRMMING		8
-#define SD_STATE_DISCONNECT		9
-
-/* Card Type */
-#define CARD_TYPE_SD		1
-#define CARD_TYPE_MMC		2
-
-/* SDCARD Capacity Class */
-#define SD_CAP_CLASS_SDSC		0x01
-#define SD_CAP_CLASS_SDHC		0x02
-#define SD_CAP_CLASS_SDXC		0x04
-
-/* SD CARD Version */
-#define SD_VERSION_1_0			0x10
-#define SD_VERSION_1_10			0x1a
-#define SD_VERSION_2			0x20
-#define SD_VERSION_3			0x30
-
-/* MMC Card Version */
-#define MMC_VERSION_1_2			0x12
-#define MMC_VERSION_1_4			0x14
-#define MMC_VERSION_2_2			0x22
-#define MMC_VERSION_3			0x30
-#define MMC_VERSION_4			0x40
-
-/* SD OCR Voltage Range */
-#define SD_OCR_VDD_165_195		(0x01 << 7)
-#define SD_OCR_VDD_20_21		(0x01 << 8)
-#define SD_OCR_VDD_21_22		(0x01 << 9)
-#define SD_OCR_VDD_22_23		(0x01 << 10)
-#define SD_OCR_VDD_23_24		(0x01 << 11)
-#define SD_OCR_VDD_24_25		(0x01 << 12)
-#define SD_OCR_VDD_25_26		(0x01 << 13)
-#define SD_OCR_VDD_26_27		(0x01 << 14)
-#define SD_OCR_VDD_27_28		(0x01 << 15)
-#define SD_OCR_VDD_28_29		(0x01 << 16)
-#define SD_OCR_VDD_29_30		(0x01 << 17)
-#define SD_OCR_VDD_30_31		(0x01 << 18)
-#define SD_OCR_VDD_31_32		(0x01 << 19)
-#define SD_OCR_VDD_32_33		(0x01 << 20)
-#define SD_OCR_VDD_33_34		(0x01 << 21)
-#define SD_OCR_VDD_34_35		(0x01 << 22)
-#define SD_OCR_VDD_35_36		(0x01 << 23)
-
-#define OCR_VOLTAGE_27_36_MASK		0xff8000
-#define CHECK_PATTERN			0xaa
-
-#define	ERROR_TIMEOUT		-10
-#define ERROR_COMM		-11
-#define ERROR_UNUSABLE_CARD	-12
-
-struct sd_command {
-	unsigned int	cmd;
-	unsigned int	cmdreg;
-	unsigned int	argu;
-	unsigned int	error_check;
-	unsigned int	*resp;
-};
-
-struct sdcard_register {
-	unsigned int	cid[4];	/* Card identification number */
-	unsigned int	rca;	/* Relative card address */
-	unsigned int	dsr;	/* Driver Stage Register */
-	unsigned int	csd[4];	/* Card Specific Data */
-	unsigned int	scr[2];	/* SD Configuration Register */
-	unsigned int	ocr;	/* Operation condition register */
-	unsigned int	ssr[16];/* SD status */
-	unsigned int	csr;	/* Card Status */
-};
-
-struct sd_card {
-	unsigned int	card_type;
-
-	unsigned int	votage_host_support;
-	unsigned int	highspeed_host;
-
-	unsigned int	sd_spec_version;
-	unsigned int	highcapacity_card;
-	unsigned int	bus_width_support;
-	unsigned int	highspeed_card;
-	unsigned int	read_bl_len;
-
-	struct sdcard_register	*reg;
-	struct sd_command	*command;
-};
-
-extern inline unsigned int mci_readl(unsigned int reg);
-extern inline void mci_writel(unsigned int reg, unsigned int value);
-
-extern int at91_mci_init(unsigned int clock, unsigned int blklen);
-extern int at91_mci_set_clock(unsigned int clock);
-extern void at91_mci_set_blkr(unsigned int blkcnt, unsigned int blklen);
-extern int at91_mci_set_bus_width(unsigned int buswidth);
-extern int at91_mci_read_block_data(unsigned int *data,
-				unsigned int bytes_to_read,
-				unsigned int block_len);
-extern int at91_mci_write_block_data(unsigned int *data,
-				unsigned int bytes_to_write,
-				unsigned int block_len);
-extern int at91_mci_read_blocks(unsigned int *data,
-				unsigned int blocks,
-				unsigned int block_len);
-
-#endif /* #ifndef __MCI_MEDIA_H__ */
diff --git a/include/mmc.h b/include/mmc.h
new file mode 100755
index 0000000..b4ae1e5
--- /dev/null
+++ b/include/mmc.h
@@ -0,0 +1,145 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2006, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaiimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __MMC_H__
+#define __MMC_H__
+
+/* SCR definitions in different words */
+#define SD_HIGHSPEED_BUSY	0x00020000
+#define SD_HIGHSPEED_SUPPORTED	0x00020000
+
+#define MMC_HS_TIMING		0x00000100
+#define MMC_HS_52MHZ		0x2
+
+#define NO_CARD_ERR		-16 /* No SD/MMC card inserted */
+#define UNUSABLE_ERR		-17 /* Unusable Card */
+#define COMM_ERR		-18 /* Communications Error */
+#define TIMEOUT			-19
+
+#define SD_VERSION_SD		0x20000
+#define SD_VERSION_2		(SD_VERSION_SD | 0x20)
+#define SD_VERSION_1_0		(SD_VERSION_SD | 0x10)
+#define SD_VERSION_1_10		(SD_VERSION_SD | 0x1a)
+#define MMC_VERSION_MMC		0x10000
+#define MMC_VERSION_UNKNOWN	(MMC_VERSION_MMC)
+#define MMC_VERSION_1_2		(MMC_VERSION_MMC | 0x12)
+#define MMC_VERSION_1_4		(MMC_VERSION_MMC | 0x14)
+#define MMC_VERSION_2_2		(MMC_VERSION_MMC | 0x22)
+#define MMC_VERSION_3		(MMC_VERSION_MMC | 0x30)
+#define MMC_VERSION_4		(MMC_VERSION_MMC | 0x40)
+
+#define MMC_MODE_HS		0x001
+#define MMC_MODE_HS_52MHz	0x010
+#define MMC_MODE_4BIT		0x100
+#define MMC_MODE_8BIT		0x200
+//#define MMC_MODE_SPI		0x400
+
+#define SD_DATA_4BIT		0x00040000
+
+#define IS_SD(x) (x->version & SD_VERSION_SD)
+
+#define OCR_BUSY		0x80000000
+#define OCR_HCS			0x40000000
+#define OCR_VOLTAGE_MASK	0x007FFF80
+#define OCR_ACCESS_MODE		0x60000000
+
+#define MMC_STATUS_MASK		(~0x0206BF7F)
+#define MMC_STATUS_RDY_FOR_DATA (1 << 8)
+#define MMC_STATUS_CURR_STATE	(0xf << 9)
+#define MMC_STATUS_ERROR	(1 << 19)
+
+#define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
+#define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
+#define MMC_VDD_21_22		0x00000200	/* VDD voltage 2.1 ~ 2.2 */
+#define MMC_VDD_22_23		0x00000400	/* VDD voltage 2.2 ~ 2.3 */
+#define MMC_VDD_23_24		0x00000800	/* VDD voltage 2.3 ~ 2.4 */
+#define MMC_VDD_24_25		0x00001000	/* VDD voltage 2.4 ~ 2.5 */
+#define MMC_VDD_25_26		0x00002000	/* VDD voltage 2.5 ~ 2.6 */
+#define MMC_VDD_26_27		0x00004000	/* VDD voltage 2.6 ~ 2.7 */
+#define MMC_VDD_27_28		0x00008000	/* VDD voltage 2.7 ~ 2.8 */
+#define MMC_VDD_28_29		0x00010000	/* VDD voltage 2.8 ~ 2.9 */
+#define MMC_VDD_29_30		0x00020000	/* VDD voltage 2.9 ~ 3.0 */
+#define MMC_VDD_30_31		0x00040000	/* VDD voltage 3.0 ~ 3.1 */
+#define MMC_VDD_31_32		0x00080000	/* VDD voltage 3.1 ~ 3.2 */
+#define MMC_VDD_32_33		0x00100000	/* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34		0x00200000	/* VDD voltage 3.3 ~ 3.4 */
+#define MMC_VDD_34_35		0x00400000	/* VDD voltage 3.4 ~ 3.5 */
+#define MMC_VDD_35_36		0x00800000	/* VDD voltage 3.5 ~ 3.6 */
+
+#define MMC_SWITCH_MODE_CMD_SET		0x00 /* Change the command set */
+#define MMC_SWITCH_MODE_SET_BITS	0x01 /* Set bits in EXT_CSD byte
+						addressed by index which are
+						1 in value field */
+#define MMC_SWITCH_MODE_CLEAR_BITS	0x02 /* Clear bits in EXT_CSD byte
+						addressed by index, which are
+						1 in value field */
+#define MMC_SWITCH_MODE_WRITE_BYTE	0x03 /* Set target byte to value */
+
+#define SD_SWITCH_CHECK		0
+#define SD_SWITCH_SWITCH	1
+
+/*
+ * EXT_CSD fields
+ */
+
+#define EXT_CSD_PART_CONF	179	/* R/W */
+#define EXT_CSD_BUS_WIDTH	183	/* R/W */
+#define EXT_CSD_HS_TIMING	185	/* R/W */
+#define EXT_CSD_CARD_TYPE	196	/* RO */
+#define EXT_CSD_REV		192	/* RO */
+#define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
+
+/*
+ * EXT_CSD field definitions
+ */
+
+#define EXT_CSD_CMD_SET_NORMAL		(1 << 0)
+#define EXT_CSD_CMD_SET_SECURE		(1 << 1)
+#define EXT_CSD_CMD_SET_CPSECURE	(1 << 2)
+
+#define EXT_CSD_CARD_TYPE_26	(1 << 0)	/* Card can run at 26MHz */
+#define EXT_CSD_CARD_TYPE_52	(1 << 1)	/* Card can run at 52MHz */
+
+#define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
+#define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
+#define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
+
+struct mmc {
+	unsigned int voltages;
+	unsigned int version;
+	int high_capacity;
+	unsigned int card_caps;
+	unsigned int host_caps;
+	unsigned int ocr;
+	unsigned int scr[2];
+	unsigned int csd[4];
+	unsigned int cid[4];
+	unsigned short rca;
+	unsigned int read_bl_len;
+};
+
+#endif /* #ifndef __MMC_H__ */
diff --git a/include/nand.h b/include/nand.h
old mode 100644
new mode 100755
index e46d0d5..59b04a4
--- a/include/nand.h
+++ b/include/nand.h
@@ -29,13 +29,14 @@
 #define __NAND_H__
 
 #define MAX_ECC_BYTES		48 /* maximum bytes of ecc */
+#define MAX_OOB_AVAIL_BYTES	78 /* maximum bytes of oob available  */
 
 struct nand_ooblayout {
 	unsigned char	badblockpos;
 	unsigned char	eccbytes;
 	unsigned char	eccpos[MAX_ECC_BYTES];
 	unsigned char	oobavailbytes;
-	unsigned char	oobavail_offset;
+	unsigned char	oobavailpos[MAX_OOB_AVAIL_BYTES];
 };
 
 struct nand_chip {
@@ -45,21 +46,119 @@ struct nand_chip {
 	unsigned short	pagesize;
 	unsigned char	oobsize;
 	unsigned char	buswidth;
+	struct nand_ooblayout	*ecclayout;
 };
 
 struct nand_info {
-	unsigned int	blocksize;	/* size of a block */
 	unsigned int	pagesize;	/* size of a page */
 	unsigned int	oobsize;	/* size of a oob */
 	unsigned int	sectorsize;	/* size of a sector */
 
 	unsigned int	numblocks;	/* number of blocks in device */
-	unsigned int	pages_device;	/* number of pages in device */
-	unsigned int	pages_block;	/* number of pages in block */
+	unsigned int	blocksize;	/* size of a block */
+
+	unsigned int	page_shift;
 
 	unsigned int	buswidth;	/* data bus width (8/16 bits) */
 
+	unsigned int	badblockpos;	/* bad block markber offset in oob (in bytes) */
 	struct nand_ooblayout	*ecclayout;
+
+#ifdef CONFIG_ENABLE_SW_ECC_BCH
+	struct
+	{
+		unsigned int eccbytes;
+		unsigned int eccsteps;
+		struct bch_control *bchc;
+		unsigned int *errloc;
+		unsigned char *ecc;
+		unsigned char *eccmask;
+	} bch;
+#endif /* #ifdef CONFIG_ENABLE_SW_ECC_BCH */
+};
+
+
+struct nand_onfi_params {
+	/* rev info and features block */
+	/* 'O' 'N' 'F' 'I'  */
+	unsigned char sig[4];
+	unsigned short revision;
+	unsigned short features;
+	unsigned short opt_cmd;
+	unsigned char reserved[22];
+
+	/* manufacturer information block */
+	char manufacturer[12];
+	char model[20];
+	unsigned char jedec_id;
+	unsigned short date_code;
+	unsigned char reserved2[13];
+
+	/* memory organization block */
+	unsigned int byte_per_page;
+	unsigned short spare_bytes_per_page;
+	unsigned int data_bytes_per_ppage;
+	unsigned short spare_bytes_per_ppage;
+	unsigned int pages_per_block;
+	unsigned int blocks_per_lun;
+	unsigned char lun_count;
+	unsigned char addr_cycles;
+	unsigned char bits_per_cell;
+	unsigned short bb_per_lun;
+	unsigned short block_endurance;
+	unsigned char guaranteed_good_blocks;
+	unsigned short guaranteed_block_endurance;
+	unsigned char programs_per_page;
+	unsigned char ppage_attr;
+	unsigned char ecc_bits;
+	unsigned char interleaved_bits;
+	unsigned char interleaved_ops;
+	unsigned char reserved3[13];
+
+	/* electrical parameter block */
+	unsigned char io_pin_capacitance_max;
+	unsigned short async_timing_mode;
+	unsigned short program_cache_timing_mode;
+	unsigned short t_prog;
+	unsigned short t_bers;
+	unsigned short t_r;
+	unsigned short t_ccs;
+	unsigned short src_sync_timing_mode;
+	unsigned short src_ssync_features;
+	unsigned short clk_pin_capacitance_typ;
+	unsigned short io_pin_capacitance_typ;
+	unsigned short input_pin_capacitance_typ;
+	unsigned char input_pin_capacitance_max;
+	unsigned char driver_strenght_support;
+	unsigned short t_int_r;
+	unsigned short t_ald;
+	unsigned char reserved4[7];
+
+	/* vendor */
+	unsigned char reserved5[90];
+
+	unsigned short crc;
+} __attribute__((packed));
+
+/*
+ * struct nandflash_dev - NAND Flash Device ID Structure
+ * @name:	Identify the device type
+ * @id:		device ID code
+ * @pagesize:	Pagesize in bytes. Either 256 or 512 or 0
+ *		If the pagesize is 0, then the real pagesize
+ *		and the eraseize are determined from the
+ *		extended id bytes in the chip
+ * @erasesize:	Size of an erase block in the flash device.
+ * @chipsize:	Total chipsize in Mega Bytes
+ * @options:	Bitfield to store chip relevant options
+ */
+struct nandflash_dev {
+	char *name;
+	int id;
+	unsigned long pagesize;
+	unsigned long chipsize;
+	unsigned long erasesize;
+	unsigned long options;
 };
 
 #define ZONE_DATA			0x01    /* Sector data zone */
@@ -95,8 +194,8 @@ struct nand_info {
 /* NandFlash ONFI */
 #define CMD_READ_ONFI			0xEC
 
-/* Feature Operations */
-#define CMD_SET_FEATURE			0xEF
-#define CMD_GET_FEATURE			0xEE
+#define ONFI_CRC_BASE			0x4F4E
+
+#define NAND_BUSWIDTH_16		0x00000002
 
 #endif /* #ifndef __NAND_H__ */
diff --git a/include/nand_ids.h b/include/nand_ids.h
new file mode 100755
index 0000000..21412ba
--- /dev/null
+++ b/include/nand_ids.h
@@ -0,0 +1,119 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2006, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *	Chip ID list
+ *
+ *	Name. ID code, pagesize, chipsize in MegaByte, eraseblock size,
+ *	options
+ *
+ *	Pagesize; 0, 256, 512
+ *	0	get this information from the extended chip ID
+ *	256	256 Byte page size
+ *	512	512 Byte page size
+ */
+const struct nandflash_dev nandflash_ids[] = {
+	{"NAND 16MiB 1,8V 8-bit",	0x33, 512, 16, 0x4000, 0},
+	{"NAND 16MiB 3,3V 8-bit",	0x73, 512, 16, 0x4000, 0},
+	{"NAND 16MiB 1,8V 16-bit",	0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 16MiB 3,3V 16-bit",	0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 32MiB 1,8V 8-bit",	0x35, 512, 32, 0x4000, 0},
+	{"NAND 32MiB 3,3V 8-bit",	0x75, 512, 32, 0x4000, 0},
+	{"NAND 32MiB 1,8V 16-bit",	0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 32MiB 3,3V 16-bit",	0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 64MiB 1,8V 8-bit",	0x36, 512, 64, 0x4000, 0},
+	{"NAND 64MiB 3,3V 8-bit",	0x76, 512, 64, 0x4000, 0},
+	{"NAND 64MiB 1,8V 16-bit",	0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 64MiB 3,3V 16-bit",	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 128MiB 1,8V 8-bit",	0x78, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 1,8V 8-bit",	0x39, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 3,3V 8-bit",	0x79, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 1,8V 16-bit",	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 1,8V 16-bit",	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 3,3V 16-bit",	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 3,3V 16-bit",	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 256MiB 3,3V 8-bit",	0x71, 512, 256, 0x4000, 0},
+
+	/*
+	 * These are the new chips with large page size. The pagesize and the
+	 * erasesize is determined from the extended id bytes
+	 */
+	/*512 Megabit */
+	{"NAND 64MiB 1,8V 8-bit",	0xA2, 0,  64, 0, 0},
+	{"NAND 64MiB 3,3V 8-bit",	0xF2, 0,  64, 0, 0},
+	{"NAND 64MiB 1,8V 16-bit",	0xB2, 0,  64, 0, NAND_BUSWIDTH_16},
+	{"NAND 64MiB 3,3V 16-bit",	0xC2, 0,  64, 0, NAND_BUSWIDTH_16},
+
+	/* 1 Gigabit */
+	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, 0},
+	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, 0},
+	{"NAND 128MiB 3,3V 8-bit",	0xD1, 0, 128, 0, 0},
+	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, NAND_BUSWIDTH_16},
+
+	/* 2 Gigabit */
+	{"NAND 256MiB 1,8V 8-bit",	0xAA, 0, 256, 0, 0},
+	{"NAND 256MiB 3,3V 8-bit",	0xDA, 0, 256, 0, 0},
+	{"NAND 256MiB 1,8V 16-bit",	0xBA, 0, 256, 0, NAND_BUSWIDTH_16},
+	{"NAND 256MiB 3,3V 16-bit",	0xCA, 0, 256, 0, NAND_BUSWIDTH_16},
+
+	/* 4 Gigabit */
+	{"NAND 512MiB 1,8V 8-bit",	0xAC, 0, 512, 0, 0},
+	{"NAND 512MiB 3,3V 8-bit",	0xDC, 0, 512, 0, 0},
+	{"NAND 512MiB 1,8V 16-bit",	0xBC, 0, 512, 0, NAND_BUSWIDTH_16},
+	{"NAND 512MiB 3,3V 16-bit",	0xCC, 0, 512, 0, NAND_BUSWIDTH_16},
+
+	/* 8 Gigabit */
+	{"NAND 1GiB 1,8V 8-bit",	0xA3, 0, 1024, 0, 0},
+	{"NAND 1GiB 3,3V 8-bit",	0xD3, 0, 1024, 0, 0},
+	{"NAND 1GiB 1,8V 16-bit",	0xB3, 0, 1024, 0, NAND_BUSWIDTH_16},
+	{"NAND 1GiB 3,3V 16-bit",	0xC3, 0, 1024, 0, NAND_BUSWIDTH_16},
+
+	/* 16 Gigabit */
+	{"NAND 2GiB 1,8V 8-bit",	0xA5, 0, 2048, 0, 0},
+	{"NAND 2GiB 3,3V 8-bit",	0xD5, 0, 2048, 0, 0},
+	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, NAND_BUSWIDTH_16},
+	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, NAND_BUSWIDTH_16},
+
+	/*
+	 * Renesas AND 1 Gigabit. Those chips do not support extended id and
+	 * have a strange page/block layout !  The chosen minimum erasesize is
+	 * 4 * 2 * 2048 = 16384 Byte, as those chips have an array of 4 page
+	 * planes 1 block = 2 pages, but due to plane arrangement the blocks
+	 * 0-3 consists of page 0 + 4,1 + 5, 2 + 6, 3 + 7 Anyway JFFS2 would
+	 * increase the eraseblock size so we chose a combined one which can be
+	 * erased in one go There are more speed improvements for reads and
+	 * writes possible, but not implemented now
+	 */
+	{NULL,}
+};
+
diff --git a/include/nandflash.h b/include/nandflash.h
old mode 100644
new mode 100755
index 3f213e8..2a16f95
--- a/include/nandflash.h
+++ b/include/nandflash.h
@@ -28,6 +28,6 @@
 #ifndef __NANDFLASH_H__
 #define __NANDFLASH_H__
 
-extern int load_nandflash(struct image_info *image);
+extern int load_nandflash(struct image_info *img_info);
 
 #endif /* #ifndef __NANDFLASH_H__ */
diff --git a/include/onewire_info.h b/include/onewire_info.h
old mode 100644
new mode 100755
index b7e1ea2..a47751f
--- a/include/onewire_info.h
+++ b/include/onewire_info.h
@@ -28,11 +28,14 @@
 #ifndef __DS24XX_H__
 #define __DS24XX_H__
 
+#include "arch/at91_pio.h"
+
 #define VENDOR_EMBEST		1
 #define VENDOR_FLEX		2
 #define VENDOR_RONETIX		3
 #define VENDOR_COGENT		4
-#define VENDOR_PDA		5
+
+extern void one_wire_hw_init(void);
 
 extern unsigned int get_cm_sn();
 extern char get_cm_rev();
diff --git a/include/pit_timer.h b/include/pit_timer.h
new file mode 100755
index 0000000..e2bcff0
--- /dev/null
+++ b/include/pit_timer.h
@@ -0,0 +1,37 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2012, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaiimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PIT_TIMER_H__
+#define __PIT_TIMER_H__
+
+extern int start_intervl_timer(unsigned int time);
+
+extern unsigned int wait_interval_timer(unsigned int time, unsigned int timer);
+
+extern int wait_timer(unsigned int time);
+
+#endif /* #ifndef __PIT_TIMER_H__ */
diff --git a/include/pmc.h b/include/pmc.h
old mode 100644
new mode 100755
diff --git a/include/psram.h b/include/psram.h
old mode 100644
new mode 100755
diff --git a/include/sdcard.h b/include/sdcard.h
old mode 100644
new mode 100755
index 0699823..d44abdc
--- a/include/sdcard.h
+++ b/include/sdcard.h
@@ -28,6 +28,6 @@
 #ifndef __SDCARD_H__
 #define __SDCARD_H__
 
-extern int load_sdcard(struct image_info *image);
+extern int load_sdcard(struct image_info *img_info);
 
 #endif /* #ifndef __SDCARD_H__ */
diff --git a/include/sddrc.h b/include/sddrc.h
new file mode 100755
index 0000000..3be1b02
--- /dev/null
+++ b/include/sddrc.h
@@ -0,0 +1,37 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2007, Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Copyright (c) 2007 Lead Tech Design <www.leadtechdesign.com>
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaiimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __SDDRC_H__
+#define __SDDRC_H__
+
+#define AT91C_SDRAM 		((volatile unsigned int *)AT91C_EBI_SDRAM)
+
+extern int sddrc_init(unsigned int sdramc_cr, unsigned int sdramc_tr);
+extern void sddrc_hw_init(void);
+
+#endif	/* #ifndef __SDDRC_H__ */
diff --git a/include/sdramc.h b/include/sdramc.h
old mode 100644
new mode 100755
diff --git a/include/slowclk.h b/include/slowclk.h
old mode 100644
new mode 100755
diff --git a/include/spi.h b/include/spi.h
old mode 100644
new mode 100755
index 0ea41d8..90c6cac
--- a/include/spi.h
+++ b/include/spi.h
@@ -28,29 +28,36 @@
 #ifndef __SPI_H__
 #define __SPI_H__
 
+/* Controller-specific definitions: */
+
 /* SPI mode flags */
-#define	SPI_MODE0	0
-#define	SPI_MODE1	1
-#define	SPI_MODE2	2	
-#define	SPI_MODE3	3
+#define	SPI_CPHA	0x01			/* clock phase */
+#define	SPI_CPOL	0x02			/* clock polarity */
+#define	SPI_MODE0	(0|0)			/* (original MicroWire) */
+#define	SPI_MODE1	(0|SPI_CPHA)
+#define	SPI_MODE2	(SPI_CPOL|0)
+#define	SPI_MODE3	(SPI_CPOL|SPI_CPHA)
 
-/* Controller-specific definitions: */
-#define AT91C_SPI_PCS0_DATAFLASH	0
-#define AT91C_SPI_PCS1_DATAFLASH	1
-#define AT91C_SPI_PCS2_DATAFLASH	2
-#define AT91C_SPI_PCS3_DATAFLASH	3
+/* SPI transfer flags */
+#define SPI_XFER_BEGIN	0x01			/* Assert CS before transfer */
+#define SPI_XFER_END	0x02			/* Deassert CS after transfer */
 
-/* functions */
-extern void at91_spi_cs_activate(void);
-extern void at91_spi_cs_deactivate(void);
+/* Chip Select 0 : NPCS0 %1110 */
+#define AT91C_SPI_PCS0_DATAFLASH	0xE
+/* Chip Select 1 : NPCS1 %1101 */
+#define AT91C_SPI_PCS1_DATAFLASH	0xD
+/* Chip Select 2 : NPCS2 %1011 */
+#define AT91C_SPI_PCS2_DATAFLASH	0xB
+/* Chip Select 3 : NPCS3 %0111 */
+#define AT91C_SPI_PCS3_DATAFLASH	0x7
 
-extern void at91_spi_enable(void);
+/* export functions */
+extern int at91_spi_init(unsigned int clock, unsigned int mode);
+extern int at91_spi_enable(void);
 extern void at91_spi_disable(void);
-extern int at91_spi_init(unsigned int pcs,
-			unsigned int clock,
-			unsigned int mode);
-extern void at91_spi_write_data(unsigned short data);
-extern unsigned int at91_spi_read_spi(void);
-extern unsigned int at91_spi_read_sr(void);
+extern int spi_xfer(unsigned int len,
+			const void *dout,
+			void *din,
+			unsigned long flags);
 
 #endif	/* #ifndef __SPI_H__ */
diff --git a/include/string.h b/include/string.h
old mode 100644
new mode 100755
index 1657526..1f55b60
--- a/include/string.h
+++ b/include/string.h
@@ -28,15 +28,14 @@
 #ifndef __STRING_H__
 #define __STRING_H__
 
+typedef unsigned int size_t;
+
 extern void *memcpy(void *dst, const void *src, int cnt);
 extern void *memset(void *dst, int val, int cnt);
-extern int memcmp(const void *dst, const void *src, unsigned int cnt);
-extern unsigned int strlen(const char *str);
+extern int memcmp(const void *dst, const void *src, size_t cnt);
+extern size_t strlen(const char *str);
 extern char *strcpy(char *dst, const char *src);
 extern int strcmp(const char *p1, const char *p2);
-extern int strncmp(const char *p1, const char *p2, unsigned int cnt);
-extern char *strchr(const char *s, int c);
-extern void *memchr(void *ptr, int value, unsigned int num);
-extern void *memmove(void *dest, const void *src, unsigned int count);
+extern int strncmp(const char *p1, const char *p2, size_t cnt);
 
 #endif /* #ifndef __STRING_H__ */
diff --git a/include/timer.h b/include/timer.h
deleted file mode 100644
index 8c6910a..0000000
--- a/include/timer.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* ----------------------------------------------------------------------------
- *         ATMEL Microcontroller Software Support
- * ----------------------------------------------------------------------------
- * Copyright (c) 2012, Atmel Corporation
-
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the disclaiimer below.
- *
- * Atmel's name may not be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
- * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef __PIT_TIMER_H__
-#define __PIT_TIMER_H__
-
-extern int timer_init(void);
-
-extern void udelay(unsigned int usec);
-
-extern int start_interval_timer(void);
-extern int wait_interval_timer(unsigned int usec);
-
-#endif /* #ifndef __PIT_TIMER_H__ */
diff --git a/include/watchdog.h b/include/watchdog.h
deleted file mode 100644
index e1925da..0000000
--- a/include/watchdog.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/* ----------------------------------------------------------------------------
- *         ATMEL Microcontroller Software Support
- * ----------------------------------------------------------------------------
- * Copyright (c) 2012, Atmel Corporation
-
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the disclaimer below.
- *
- * Atmel's name may not be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
- * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef __WATCHDOG_H__
-#define __WATCHDOG_H__
-
-extern void at91_disable_wdt(void);
-
-#endif /* __WATCHDOG_H__ */
diff --git a/lib/_udivsi3.S b/lib/_udivsi3.S
new file mode 100755
index 0000000..4d8aa0a
--- /dev/null
+++ b/lib/_udivsi3.S
@@ -0,0 +1,80 @@
+/* # 1 "libgcc1.S" */
+@ libgcc1 routines for ARM cpu.
+@ Division routines, written by Richard Earnshaw, (rearnsha@armltd.co.uk)
+dividend	.req	r0
+divisor		.req	r1
+result		.req	r2
+curbit		.req	r3
+/* ip		.req	r12	*/
+/* sp		.req	r13	*/
+/* lr		.req	r14	*/
+/* pc		.req	r15	*/
+	.text
+	.globl	 __udivsi3
+	.type  __udivsi3       ,function
+	.globl	__aeabi_uidiv
+	.type  __aeabi_uidiv       ,function
+	.align	0
+__aeabi_uidiv:
+__udivsi3:
+	cmp	divisor, #0
+	beq	Ldiv0
+	mov	curbit, #1
+	mov	result, #0
+	cmp	dividend, divisor
+	bcc	Lgot_result
+Loop1:
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is
+	@ larger than the dividend.
+	cmp	divisor, #0x10000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #4
+	movcc	curbit, curbit, lsl #4
+	bcc	Loop1
+Lbignum:
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+	cmp	divisor, #0x80000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #1
+	movcc	curbit, curbit, lsl #1
+	bcc	Lbignum
+Loop3:
+	@ Test for possible subtractions, and note which bits
+	@ are done in the result.  On the final pass, this may subtract
+	@ too much from the dividend, but the result will be ok, since the
+	@ "bit" will have been shifted out at the bottom.
+	cmp	dividend, divisor
+	subcs	dividend, dividend, divisor
+	orrcs	result, result, curbit
+	cmp	dividend, divisor, lsr #1
+	subcs	dividend, dividend, divisor, lsr #1
+	orrcs	result, result, curbit, lsr #1
+	cmp	dividend, divisor, lsr #2
+	subcs	dividend, dividend, divisor, lsr #2
+	orrcs	result, result, curbit, lsr #2
+	cmp	dividend, divisor, lsr #3
+	subcs	dividend, dividend, divisor, lsr #3
+	orrcs	result, result, curbit, lsr #3
+	cmp	dividend, #0			@ Early termination?
+	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
+	movne	divisor, divisor, lsr #4
+	bne	Loop3
+Lgot_result:
+	mov	r0, result
+	bx	lr
+Ldiv0:
+	str	lr, [sp, #-4]!
+	bl	 __div0       (PLT)
+	mov	r0, #0			@ about as wrong as it could be
+	ldmia	sp!, {pc}
+	.size  __udivsi3       , . -  __udivsi3
+/* # 235 "libgcc1.S" */
+/* # 320 "libgcc1.S" */
+/* # 421 "libgcc1.S" */
+/* # 433 "libgcc1.S" */
+/* # 456 "libgcc1.S" */
+/* # 500 "libgcc1.S" */
+/* # 580 "libgcc1.S" */
diff --git a/lib/_umodsi3.S b/lib/_umodsi3.S
new file mode 100755
index 0000000..1e0bb02
--- /dev/null
+++ b/lib/_umodsi3.S
@@ -0,0 +1,101 @@
+/* # 1 "libgcc1.S" */
+@ libgcc1 routines for ARM cpu.
+@ Division routines, written by Richard Earnshaw, (rearnsha@armltd.co.uk)
+/* # 145 "libgcc1.S" */
+dividend	.req	r0
+divisor		.req	r1
+overdone	.req	r2
+curbit		.req	r3
+/* ip		.req	r12	*/
+/* sp		.req	r13	*/
+/* lr		.req	r14	*/
+/* pc		.req	r15	*/
+	.text
+	.globl	 __umodsi3
+	.type  __umodsi3       ,function
+	.align 0
+ __umodsi3      :
+	cmp	divisor, #0
+	beq	Ldiv0
+	mov	curbit, #1
+	cmp	dividend, divisor
+	bxcc  	lr
+Loop1:
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is
+	@ larger than the dividend.
+	cmp	divisor, #0x10000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #4
+	movcc	curbit, curbit, lsl #4
+	bcc	Loop1
+Lbignum:
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+	cmp	divisor, #0x80000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #1
+	movcc	curbit, curbit, lsl #1
+	bcc	Lbignum
+Loop3:
+	@ Test for possible subtractions.  On the final pass, this may
+	@ subtract too much from the dividend, so keep track of which
+	@ subtractions are done, we can fix them up afterwards...
+	mov	overdone, #0
+	cmp	dividend, divisor
+	subcs	dividend, dividend, divisor
+	cmp	dividend, divisor, lsr #1
+	subcs	dividend, dividend, divisor, lsr #1
+	orrcs	overdone, overdone, curbit, ror #1
+	cmp	dividend, divisor, lsr #2
+	subcs	dividend, dividend, divisor, lsr #2
+	orrcs	overdone, overdone, curbit, ror #2
+	cmp	dividend, divisor, lsr #3
+	subcs	dividend, dividend, divisor, lsr #3
+	orrcs	overdone, overdone, curbit, ror #3
+	mov	ip, curbit
+	cmp	dividend, #0			@ Early termination?
+	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
+	movne	divisor, divisor, lsr #4
+	bne	Loop3
+	@ Any subtractions that we should not have done will be recorded in
+	@ the top three bits of "overdone".  Exactly which were not needed
+	@ are governed by the position of the bit, stored in ip.
+	@ If we terminated early, because dividend became zero,
+	@ then none of the below will match, since the bit in ip will not be
+	@ in the bottom nibble.
+	ands	overdone, overdone, #0xe0000000
+	bxeq	lr
+	tst	overdone, ip, ror #3
+	addne	dividend, dividend, divisor, lsr #3
+	tst	overdone, ip, ror #2
+	addne	dividend, dividend, divisor, lsr #2
+	tst	overdone, ip, ror #1
+	addne	dividend, dividend, divisor, lsr #1
+	bx	lr
+Ldiv0:
+	str	lr, [sp, #-4]!
+	bl	 __div0       (PLT)
+	mov	r0, #0			@ about as wrong as it could be
+	ldmia	sp!, {pc}
+	.size  __umodsi3       , . -  __umodsi3
+
+        .text
+	.globl __aeabi_uidivmod
+        .type  __aeabi_uidivmod       ,function
+        .align 0
+__aeabi_uidivmod:
+	stmfd   sp!, {r0, r1, ip, lr}
+	bl	__aeabi_uidiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	bx	lr
+
+/* # 320 "libgcc1.S" */
+/* # 421 "libgcc1.S" */
+/* # 433 "libgcc1.S" */
+/* # 456 "libgcc1.S" */
+/* # 500 "libgcc1.S" */
+/* # 580 "libgcc1.S" */
diff --git a/lib/delay.c b/lib/delay.c
new file mode 100755
index 0000000..dbca7b6
--- /dev/null
+++ b/lib/delay.c
@@ -0,0 +1,43 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2006, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+void delay(unsigned int count)
+{
+	unsigned int i;
+ 
+	for (i = 0; i < count; i++)
+		asm volatile ("    nop");
+}
+
+void udelay(unsigned long usec)
+{
+	unsigned int i;
+
+	for (i = 0; i < usec; i++)
+		delay(10);
+}
diff --git a/lib/div00.c b/lib/div00.c
new file mode 100755
index 0000000..c469394
--- /dev/null
+++ b/lib/div00.c
@@ -0,0 +1,33 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2006, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+void __div0(void)
+{
+	for(;;);
+}
+
diff --git a/lib/eabi_utils.c b/lib/eabi_utils.c
old mode 100644
new mode 100755
diff --git a/lib/fdt.c b/lib/fdt.c
deleted file mode 100644
index 16614bb..0000000
--- a/lib/fdt.c
+++ /dev/null
@@ -1,630 +0,0 @@
-/* ----------------------------------------------------------------------------
- *         ATMEL Microcontroller Software Support
- * ----------------------------------------------------------------------------
- * Copyright (c) 2012, Atmel Corporation
-
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the disclaiimer below.
- *
- * Atmel's name may not be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
- * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include "common.h"
-#include "string.h"
-#include "debug.h"
-
-/* see linux document: ./Documentation/devicetree/booting-without-of.txt */
-#define OF_DT_MAGIC	0xd00dfeed
-
-#define OF_DT_TOKEN_NODE_BEGIN	0x00000001 /* Start node */
-#define OF_DT_TOKEN_NODE_END	0x00000002 /* End node */
-#define OF_DT_TOKEN_PROP	0x00000003 /* Property */
-#define OF_DT_TOKEN_NOP		0x00000004
-#define OF_DT_END		0x00000009
-
-struct boot_param_header {
-	unsigned int	magic_number;
-	unsigned int	total_size;
-	unsigned int	offset_dt_struct;
-	unsigned int	offset_dt_strings;
-	unsigned int	offset_reserve_map;
-	unsigned int	format_version;
-	unsigned int	last_compatible_version;
-
-	/* version 2 field */
-	unsigned int	mach_id;
-	/* version 3 field */
-	unsigned int	dt_strings_len;
-	/* version 17 field */
-	unsigned int	dt_struct_len;
-};
-
-static inline unsigned int of_get_magic_number(void *blob)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	return swap_uint32(header->magic_number);
-}
-
-static inline unsigned int of_get_format_version(void *blob)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	return swap_uint32(header->format_version);
-}
-
-static inline unsigned int of_get_offset_dt_strings(void *blob)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	return swap_uint32(header->offset_dt_strings);
-}
-
-static inline void of_set_offset_dt_strings(void *blob, unsigned int offset)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	header->offset_dt_strings = swap_uint32(offset);
-}
-
-static inline char *of_get_string_by_offset(void *blob, unsigned int offset)
-{
-	return (char *)((unsigned int)blob
-				+ of_get_offset_dt_strings(blob) + offset);
-}
-
-static inline unsigned int of_get_offset_dt_struct(void *blob)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	return swap_uint32(header->offset_dt_struct);
-}
-
-static inline unsigned int of_dt_struct_offset(void *blob, unsigned int offset)
-{
-	return (unsigned int)blob + of_get_offset_dt_struct(blob) + offset;
-}
-
-static inline unsigned int of_get_dt_total_size(void *blob)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	return swap_uint32(header->total_size);
-}
-
-static inline void of_set_dt_total_size(void *blob, unsigned int size)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	header->total_size = swap_uint32(size);
-}
-
-static inline unsigned int of_get_dt_strings_len(void *blob)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	return swap_uint32(header->dt_strings_len);
-}
-
-static inline void of_set_dt_strings_len(void *blob, unsigned int len)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	header->dt_strings_len = swap_uint32(len);
-}
-
-static inline unsigned int of_get_dt_struct_len(void *blob)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	return swap_uint32(header->dt_struct_len);
-}
-
-static inline void of_set_dt_struct_len(void *blob, unsigned int len)
-{
-	struct boot_param_header *header = (struct boot_param_header *)blob;
-
-	header->dt_struct_len = swap_uint32(len);
-}
-
-static inline int of_blob_data_size(void *blob)
-{
-	return (unsigned int)of_get_offset_dt_strings(blob)
-			+ of_get_dt_strings_len(blob);
-}
-
-/* -------------------------------------------------------- */
-
-/* return the token and the next token offset
- */
-static int of_get_token_nextoffset(void *blob,
-				int startoffset,
-				int *nextoffset,
-				unsigned int *token)
-{
-	const unsigned int *p, *plen;
-	unsigned int tag;
-	const char *cell;
-	unsigned int offset = startoffset;
-
-	*nextoffset = -1;
-
-	if (offset % 4) {
-		dbg_log(1, "DT: the token offset is not aligned\n\r");
-		return -1;
-	}
-
-	/* Get the token */
-	p = (unsigned int *)of_dt_struct_offset(blob, offset);
-	tag = swap_uint32(*p);
-
-	/* to get offset for the next token */
-	offset += 4;
-	if (tag  == OF_DT_TOKEN_NODE_BEGIN) {
-		/* node name */
-		cell = (char *)of_dt_struct_offset(blob, offset);
-		do {
-			cell++;
-			offset++;
-		} while (*cell != '\0');
-	} else if (tag == OF_DT_TOKEN_PROP) {
-		/* the property value size */
-		plen = (unsigned int *)of_dt_struct_offset(blob, offset);
-		/* name offset + value size + value */
-		offset += swap_uint32(*plen) + 8;
-	} else if ((tag != OF_DT_TOKEN_NODE_END)
-			&& (tag != OF_DT_TOKEN_NOP)
-			&& (tag != OF_DT_END))
-		return -1;
-
-	*nextoffset = OF_ALIGN(offset);
-	*token = tag;
-
-	return 0;
-}
-
-static int of_get_nextnode_offset(void *blob,
-				int start_offset,
-				int *offset,
-				int *nextoffset,
-				int *depth)
-{
-	int next_offset = 0;
-	int nodeoffset = start_offset;
-	unsigned int token;
-	int ret;
-
-	while(1) {
-		ret = of_get_token_nextoffset(blob, nodeoffset,
-						&next_offset, &token);
-		if (ret)
-			return ret;
-
-		if (token == OF_DT_TOKEN_NODE_BEGIN) {
-			/* find the node start token */
-			if (depth)
-				(*depth)++;
-
-			break;
-		} else {
-			nodeoffset = next_offset;
-
-			if ((token == OF_DT_TOKEN_PROP)
-				|| (token == OF_DT_TOKEN_NOP))
-				continue;
-			else if (token == OF_DT_TOKEN_NODE_END) {
-				if (depth)
-					(*depth)--;
-				if ((*depth) < 0)
-					return -1; /* not found */
-			} else if (token == OF_DT_END)
-				return -1; /* not found*/
-		}
-	};
-
-	*offset = nodeoffset;
-	*nextoffset = next_offset;
-
-	return 0;
-}
-
-static int of_get_node_offset(void *blob, char *name, int *offset)
-{
-	int start_offset = 0;
-	int nodeoffset = 0;
-	int nextoffset = 0;
-	int depth = 0;
-	unsigned int token;
-	unsigned int namelen = strlen(name);
-	char *nodename;
-	int ret;
-
-	/* find the root node*/
-	ret = of_get_token_nextoffset(blob, 0, &start_offset, &token);
-	if (ret)
-		return -1;
-
-	while (1) {
-		ret = of_get_nextnode_offset(blob, start_offset,
-					&nodeoffset, &nextoffset, &depth);
-		if (ret)
-			return ret;
-
-		if (depth < 0)
-			return -1;
-
-		nodename = (char *)of_dt_struct_offset(blob,(nodeoffset + 4));
-		if ((memcmp(nodename, name, namelen) == 0)
-			&& (nodename[namelen] == '\0'))
-			break;
-
-		start_offset = nextoffset;
-	}
-
-	*offset = nextoffset;
-
-	return 0;
-}
-
-/* -------------------------------------------------------- */
-
-static int of_blob_move_dt_struct(void *blob,
-					void *point,
-					int oldlen,
-					int newlen)
-{
-	void *dest = point + newlen;
-	void *src = point + oldlen;
-	unsigned int len = (char *)blob + of_blob_data_size(blob)
-					- (char *)point - oldlen;
-
-	int delta = newlen - oldlen;
-	unsigned int structlen = of_get_dt_struct_len(blob) + delta;
-	unsigned int stringsoffset = of_get_offset_dt_strings(blob) + delta;
-
-	memmove(dest, src, len);
-
-	of_set_dt_struct_len(blob, structlen);
-	of_set_offset_dt_strings(blob, stringsoffset);
-
-	if (delta > 0)
-		of_set_dt_total_size(blob, of_get_dt_total_size(blob) + delta);
-
-	return 0;
-}
-
-static int of_blob_move_dt_string(void *blob, int newlen)
-{
-	void *point = (void *)((unsigned int)blob
-				+ of_get_offset_dt_strings(blob)
-				+ of_get_dt_strings_len(blob));
-
-	void *dest = point + newlen;
-	unsigned int len = (char *)blob + of_blob_data_size(blob)
-					- (char *)point;
-	unsigned int stringslen = of_get_dt_strings_len(blob) + newlen;
-
-	memmove(dest, point, len);
-
-	of_set_dt_strings_len(blob, stringslen);
-	of_set_dt_total_size(blob, of_get_dt_total_size(blob) + len);
-
-	return 0;
-}
-
-static int of_get_next_property_offset(void *blob,
-				int startoffset,
-				int *offset,
-				int *nextproperty)
-{
-	unsigned int token;
-	int nextoffset;
-	int ret = -1;
-
-	while (1) {
-		ret = of_get_token_nextoffset(blob, startoffset,
-						&nextoffset, &token);
-		if (ret)
-			break;
-
-		if (token == OF_DT_TOKEN_PROP) {
-			*offset = startoffset;
-			*nextproperty = nextoffset;
-			ret = 0;
-			break;
-		} else if (token == OF_DT_TOKEN_NOP)
-			continue;
-		else {
-			ret = -1;
-			break;
-		}
-
-		startoffset = nextoffset;
-	};
-
-	return ret;
-}
-
-static int of_get_property_offset_by_name(void *blob,
-					unsigned int nodeoffset,
-					char *name,
-					int *offset)
-{
-	unsigned int nameoffset;
-	unsigned int *p;
-	unsigned int namelen = strlen(name);
-	int startoffset = nodeoffset;
-	int property_offset = 0;
-	int nextoffset = 0;
-	char *string;
-	int ret;
-
-	*offset = 0;
-
-	while (1) {
-		ret = of_get_next_property_offset(blob, startoffset,
-					&property_offset, &nextoffset);
-		if (ret)
-			return ret;
-
-		p = (unsigned int *)of_dt_struct_offset(blob,
-						property_offset + 8);
-		nameoffset = swap_uint32(*p);
-		string = of_get_string_by_offset(blob, nameoffset);
-		if ((strlen(string) == namelen)
-			&& (memcmp(string, name, namelen) == 0)) {
-			*offset = property_offset;
-			return 0;
-		}
-		startoffset = nextoffset;
-	}
-
-	return -1;
-}
-
-static int of_string_is_find_strings_blob(void *blob,
-				const char *string,
-				int *offset)
-{
-	char *dt_strings = (char *)blob + of_get_offset_dt_strings(blob);
-	int dt_stringslen = of_get_dt_strings_len(blob);
-	int len = strlen(string) + 1;
-	char *lastpoint = dt_strings + dt_stringslen - len;
-	char *p;
-
-	for (p = dt_strings; p <= lastpoint; p++) {
-		if (memcmp(p, string, len) == 0) {
-			*offset = p - dt_strings;
-			return 0;
-		}
-	}
-
-	return -1;
-}
-
-static int of_add_string_strings_blob(void *blob,
-			const char *string,
-			int *name_offset)
-{
-	char *dt_strings = (char *)blob + of_get_offset_dt_strings(blob);
-	int dt_stringslen = of_get_dt_strings_len(blob);
-	char *new_string;
-	int len = strlen(string) + 1;
-	int ret;
-
-	new_string = dt_strings + dt_stringslen;
-	ret = of_blob_move_dt_string(blob, len);
-	if (ret)
-		return ret;
-
-	memcpy(new_string, string, len);
-
-	*name_offset = new_string - dt_strings;
-
-	return 0;
-}
-
-static int of_add_property(void *blob,
-				int nextoffset,
-				const char *property_name,
-				const void *value,
-				int valuelen)
-{
-	int string_offset;
-	unsigned int *p;
-	unsigned int addr;
-	int len;
-	int ret;
-
-	/* check if the property name in the dt_strings,
-	 * else add the string in dt strings
-	 */
-	ret = of_string_is_find_strings_blob(blob,
-				property_name, &string_offset);
-	if (ret) {
-		ret = of_add_string_strings_blob(blob,
-				property_name, &string_offset);
-		if (ret)
-			return ret;
-	}
-
-	/* add the property node in dt struct */
-	len = 12 + OF_ALIGN(valuelen);
-	addr = of_dt_struct_offset(blob, nextoffset);
-	ret = of_blob_move_dt_struct(blob, (void *)addr, 0, len);
-	if (ret)
-		return ret;
-
-	p = (unsigned int *)addr;
-
-	/* set property node: token, value size, name offset, value */
-	*p++ = swap_uint32(OF_DT_TOKEN_PROP);
-	*p++ = swap_uint32(valuelen);
-	*p++ = swap_uint32(string_offset);
-	memcpy((unsigned char *)p, value, valuelen);
-
-	return 0;
-}
-
-static int of_update_property_value(void *blob,
-				int property_offset,
-				const void *value,
-				int valuelen)
-{
-	int oldlen;
-	unsigned int *plen;
-	unsigned char *pvalue;
-	void *point;
-	int ret;
-
-	plen = (unsigned int *)of_dt_struct_offset(blob, property_offset + 4);
-	pvalue = (unsigned char *)of_dt_struct_offset(blob,
-						property_offset + 12);
-	point = (void *)pvalue;
-
-	/* get the old len of value */
-	oldlen = swap_uint32(*plen);
-
-	ret = of_blob_move_dt_struct(blob, point,
-			OF_ALIGN(oldlen), OF_ALIGN(valuelen));
-	if (ret)
-		return ret;
-
-	/* set the new len and value */
-	*plen = swap_uint32(valuelen);
-	memcpy(pvalue, value, valuelen);
-
-	return 0;
-}
-
-static int of_set_property(void *blob,
-				int nodeoffset,
-				char *property_name,
-				void *value,
-				int valuelen)
-{
-	int property_offset;
-	int ret;
-
-	/* If find the property name in the dt blob, update its value,
-	 * else to add this property
-	 */
-	ret = of_get_property_offset_by_name(blob, nodeoffset,
-					property_name, &property_offset);
-	if (ret) {
-		ret = of_add_property(blob, nodeoffset,
-				property_name, value, valuelen);
-		if (ret)
-			dbg_log(1, "DT: fail to add property\n\r");
-
-		return ret;
-	}
-
-	ret = of_update_property_value(blob, property_offset, value, valuelen);
-	if (ret) {
-		dbg_log(1, "DT: fail to update property\n\r");
-		return ret;
-	}
-
-	return 0;
-}
-
-/* ---------------------------------------------------- */
-
-int check_dt_blob_valid(void *blob)
-{
-	return ((of_get_magic_number(blob) == OF_DT_MAGIC)
-			&& (of_get_format_version(blob) >= 17)) ? 0 : 1;
-}
-
-/* The /chosen node
- * property "bootargs": This zero-terminated string is passed
- * as the kernel command line.
- */
-int fixup_chosen_node(void *blob, char *bootargs)
-{
-	int nodeoffset;
-	char *value = bootargs;
-	int valuelen = strlen(value) + 1;
-	int ret;
-
-	ret = of_get_node_offset(blob, "chosen", &nodeoffset);
-	if (ret) {
-		dbg_log(1, "DT: doesn't support add node\n\r");
-		return ret;
-	}
-
-	/*
-	 * if the property doesn't exit, add it
-	 * if the property exists, update it.
-	 */
-	ret = of_set_property(blob, nodeoffset, "bootargs", value, valuelen);
-	if (ret) {
-		dbg_log(1, "fail to set bootargs property\n\r");
-		return ret;
-	}
-
-	return 0;
-}
-
-/* The /memory node
- * Required properties:
- * - device_type: has to be "memory".
- * - reg: this property contains all the physical memory ranges of your boards.
- */
-int fixup_memory_node(void *blob,
-			unsigned int *mem_bank,
-			unsigned int *mem_size)
-{
-	int nodeoffset;
-	unsigned int data[2];
-	int valuelen;
-	int ret;
-
-	ret = of_get_node_offset(blob, "memory", &nodeoffset);
-	if (ret) {
-		dbg_log(1, "DT: doesn't support add node\n\r");
-		return ret;
-	}
-
-	/*
-	 * if the property doesn't exit, add it
-	 * if the property exists, update it.
-	 */
-	/* set "device_type" property */
-	ret = of_set_property(blob, nodeoffset,
-			"device_type", "memory", sizeof("memory"));
-	if (ret) {
-		dbg_log(1, "DT: could not set device_type property\n\r");
-		return ret;
-	}
-
-	/* set "reg" property */
-	valuelen = 8;
-	data[0] = swap_uint32(*mem_bank);
-	data[1] = swap_uint32(*mem_size);
-
-	ret = of_set_property(blob, nodeoffset, "reg", data, valuelen);
-	if (ret) {
-		dbg_log(1, "DT: could not set reg property\n\r");
-		return ret;
-	}
-
-	return 0;
-}
diff --git a/lib/libc.mk b/lib/libc.mk
old mode 100644
new mode 100755
index d85bb3c..81adffb
--- a/lib/libc.mk
+++ b/lib/libc.mk
@@ -4,7 +4,9 @@
 LIBC:=$(TOPDIR)/lib/
 
 COBJS-y		+= $(LIBC)string.o
+COBJS-y		+= $(LIBC)delay.o
+COBJS-y		+= $(LIBC)div00.o
 COBJS-y		+= $(LIBC)eabi_utils.o
-COBJS-y		+= $(LIBC)raise.o
+SOBJS-y		+= $(LIBC)_udivsi3.o
+SOBJS-y		+= $(LIBC)_umodsi3.o
 
-COBJS-$(CONFIG_OF_LIBFDT) += $(LIBC)/fdt.o
diff --git a/lib/raise.c b/lib/raise.c
deleted file mode 100644
index 087e161..0000000
--- a/lib/raise.c
+++ /dev/null
@@ -1,4 +0,0 @@
-int raise(int signum)
-{
-	return 0;
-}
diff --git a/lib/string.c b/lib/string.c
old mode 100644
new mode 100755
index e9d6222..5ea84a0
--- a/lib/string.c
+++ b/lib/string.c
@@ -26,7 +26,6 @@
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "string.h"
-#include "common.h"
 
 void *memcpy(void *dst, const void *src, int cnt)
 {
@@ -49,7 +48,7 @@ void *memset(void *dst, int val, int cnt)
 	return d;
 }
 
-int memcmp(const void *dst, const void *src, unsigned int cnt)
+int memcmp(const void *dst, const void *src, size_t cnt)
 {
 	const char *d = (const char *)dst;
 	const char *s = (const char *)src;
@@ -60,7 +59,7 @@ int memcmp(const void *dst, const void *src, unsigned int cnt)
 	return r;
 }
 
-unsigned int strlen(const char *str)
+size_t strlen(const char *str)
 {
 	int i = 0;
 
@@ -94,7 +93,7 @@ int strcmp(const char *p1, const char *p2)
 	return 0;
 }
 
-int strncmp(const char *p1, const char *p2, unsigned int cnt)
+int strncmp(const char *p1, const char *p2, size_t cnt)
 {
 	unsigned char c1, c2;
 
@@ -111,49 +110,3 @@ int strncmp(const char *p1, const char *p2, unsigned int cnt)
 
 	return 0;
 }
-
-char *strchr(const char *s, int c)
-{
-	for (; *s != (char) c; ++s)
-		if (*s == '\0')
-			return NULL;
-
-	return (char *)s;
-}
-
-void *memchr(void *src, int val, unsigned int cnt)
-{
-	char *p = NULL;
-	char *s = (char *)src;
-
-	while (cnt) {
-		if (*s == val) {
-			p = s;
-			break;
-		}
-		s++;
-		cnt--;
-	}
-
-	return p;
-}
-
-void *memmove(void *dst, const void *src, unsigned int cnt)
-{
-	char *p, *s;
-
-	if (dst <= src) {
-		p = (char *)dst;
-		s = (char *)src;
-		while (cnt--)
-			*p++ = *s++;
-		}
-	else {
-		p = (char *)dst + cnt;
-		s = (char *)src + cnt;
-		while (cnt--)
-			*--p = *--s;
-		}
-
-	return dst;
-}
diff --git a/main.c b/main.c
old mode 100644
new mode 100755
index e1f694a..9799ff9
--- a/main.c
+++ b/main.c
@@ -28,94 +28,34 @@
 #include "common.h"
 #include "hardware.h"
 #include "board.h"
-#include "dbgu.h"
 #include "debug.h"
 #include "slowclk.h"
 #include "dataflash.h"
 #include "nandflash.h"
 #include "sdcard.h"
 #include "flash.h"
-#include "string.h"
-#include "onewire_info.h"
 
 extern int load_kernel(struct image_info *img_info);
 
 typedef int (*load_function)(struct image_info *img_info);
 
-static load_function load_image;
-
-static int init_loadfunction(void)
-{
-#if defined(CONFIG_LOAD_LINUX)
-	load_image = &load_kernel;
-#else
-#if defined (CONFIG_DATAFLASH)
-	load_image = &load_dataflash;
-#elif defined(CONFIG_NANDFLASH)
-	load_image = &load_nandflash;
-#elif defined(CONFIG_SDCARD)
-	load_image = &load_sdcard;
-#else
-#error "No booting media_str specified!"
-#endif
-#endif
-	return 0;
-}
+unsigned char card_present = 0;
 
 static void display_banner (void)
 {
-	char *version = "AT91Bootstrap";
-	char *ver_num = " "AT91BOOTSTRAP_VERSION" ("COMPILE_TIME")";
-
-	dbgu_print("\n\r");
-	dbgu_print("\n\r");
-	dbgu_print(version);
-	dbgu_print(ver_num);
-	dbgu_print("\n\r");
-	dbgu_print("\n\r");
+	dbg_log(1, "\n\nAT91Bootstrap %s\n\n\r",
+			AT91BOOTSTRAP_VERSION" ( "COMPILE_TIME" )");
 }
 
 int main(void)
 {
-	struct image_info image;
-	char *media_str = NULL;
-	int ret;
+	struct image_info image_info;
+	int ret = 1;
 
-	memset(&image, 0, sizeof(image));
-
-	image.dest = (unsigned char *)JUMP_ADDR;
-#ifdef CONFIG_OF_LIBFDT
-	image.of = 1;
-	image.of_dest = (unsigned char *)OF_ADDRESS;
-#endif
-
-#ifdef CONFIG_NANDFLASH
-	media_str = "NAND: ";
-	image.offset = IMG_ADDRESS;
-	image.length = IMG_SIZE;
-#ifdef CONFIG_OF_LIBFDT
-	image.of_offset = OF_OFFSET;
-	image.of_length = OF_LENGTH;
-#endif
-#endif
-
-#ifdef CONFIG_DATAFLASH
-	media_str = "SF: ";
-	image.offset = IMG_ADDRESS;
-	image.length = IMG_SIZE;
-#ifdef CONFIG_OF_LIBFDT
-	image.of_offset = OF_OFFSET;
-	image.of_length = OF_LENGTH;
-#endif
-#endif
-
-#ifdef CONFIG_SDCARD
-	media_str = "SD/MMC: ";
-	image.filename = OS_IMAGE_NAME;
-#ifdef CONFIG_OF_LIBFDT
-	image.of_filename = OF_FILENAME;
-#endif
-#endif
+	image_info.dest = (unsigned char *)JUMP_ADDR;
+	image_info.offset = IMG_ADDRESS;
+	image_info.length = IMG_SIZE;
+	image_info.filename = OS_IMAGE_NAME;
 
 #ifdef CONFIG_HW_INIT
 	hw_init();
@@ -123,28 +63,35 @@ int main(void)
 
 	display_banner();
 
-#ifdef CONFIG_LOAD_ONE_WIRE
-	/* Load one wire informaion */
-	load_1wire_info();
-#endif
-	init_loadfunction();
-
-	ret = (*load_image)(&image);
-
-	if (media_str)
-		dbgu_print(media_str);
-
-	if (ret == 0){
-		dbgu_print("Done to load image\n\r");
-	}
-	if (ret == -1) {
-		dbgu_print("Failed to load image\n\r");
-		while(1);
-	}
-	if (ret == -2) {
-		dbgu_print("Success to recovery\n\r");
-		while (1);
+	/*
+     * Choose between Nandflash or SDCard
+     */
+	if(card_present == 1)
+	{
+		dbg_log(1, "SDCard detected, attempting to load Linux kernel...\n\r");
+		
+    	ret = load_kernel(&image_info);
 	}
+	if(ret || card_present == 0)
+	{
+		dbg_log(1, "Loading u-boot from NAND...\n\r");
+		image_info.dest = (unsigned char *)NAND_JUMP_ADDR;
+	    image_info.offset = NAND_IMG_ADDRESS;
+	    image_info.length = NAND_IMG_SIZE;
+		ret = load_nandflash(&image_info);
+        if (ret == 0){
+	        dbg_log(1, "Done!\n\r");
+	        return NAND_JUMP_ADDR;
+        }
+        if (ret == -1) {
+	        dbg_log(1, "Failed to load image\n\r");
+	        while(1);
+        }
+        if (ret == -2) {
+	        dbg_log(1, "Success to recovery\n\r");
+	        while (1);
+        }
+    }
 
 #ifdef CONFIG_SCLK
 	slowclk_switch_osc32();
diff --git a/scripts/fixboot.py b/scripts/fixboot.py
new file mode 100755
index 0000000..e4c604e
--- /dev/null
+++ b/scripts/fixboot.py
@@ -0,0 +1,18 @@
+#!/usr/bin/env python
+
+import struct, sys
+
+#print sys.argv[1]
+
+fd = open(sys.argv[1], "r")
+
+line = fd.read()
+fd.close()
+
+# print len(line)
+
+vec = struct.pack("<I", len(line))
+
+fd = open(sys.argv[1]+".fixboot", "w")
+fd.write(line[0:20]+vec+line[24:])
+fd.close()
diff --git a/toplevel_cpp.mk b/toplevel_cpp.mk
old mode 100644
new mode 100755
index ca42148..a68d762
--- a/toplevel_cpp.mk
+++ b/toplevel_cpp.mk
@@ -2,16 +2,17 @@ CPPFLAGS += \
 	-DIMG_ADDRESS=$(IMG_ADDRESS)	\
 	-DIMG_SIZE=$(IMG_SIZE)		\
 	-DJUMP_ADDR=$(JUMP_ADDR)	\
-	-DOF_OFFSET=$(OF_OFFSET)	\
-	-DOF_LENGTH=$(OF_LENGTH)	\
-	-DOF_FILENAME="\"$(OF_FILENAME)\""	\
-	-DOF_ADDRESS=$(OF_ADDRESS)	\
 	-DOS_MEM_BANK=$(OS_MEM_BANK)	\
 	-DOS_MEM_SIZE=$(OS_MEM_SIZE)	\
 	-DOS_IMAGE_NAME="\"$(OS_IMAGE_NAME)\""	\
 	-DLINUX_KERNEL_ARG_STRING="\"$(LINUX_KERNEL_ARG_STRING)\"" \
 	-DTOP_OF_MEMORY=$(TOP_OF_MEMORY)	\
 	-DMACH_TYPE=$(MACH_TYPE)		\
+	-DDTIMG_ADDRESS=$(DTIMG_ADDRESS)		\
+	-DDTIMG_SIZE=$(DTIMG_SIZE)		\
+	-DDT_ADDRESS=$(DT_ADDRESS)		\
+	-DSW_ECC_BCH_BLOCKSIZE=$(SW_ECC_BCH_BLOCKSIZE)	\
+	-DSW_ECC_BCH_BITS=$(SW_ECC_BCH_BITS)	\
 
 ASFLAGS += -DJUMP_ADDR=$(JUMP_ADDR)		\
 	-DTOP_OF_MEMORY=$(TOP_OF_MEMORY)	\
